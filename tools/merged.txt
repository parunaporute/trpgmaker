characterCreate.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>エレメント作成</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
</head>
<body>
    <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>
    <div class="container" style="max-width:800px;">
      <h1>エレメント作成</h1>
      <button id="gacha-btn" style="margin:10px;">エレメントガチャ</button>
      <button id="move-gacha-to-warehouse-btn" style="margin:10px;">ガチャ箱のカードを倉庫に入れる</button>
      <button id="toggle-selection-mode-btn" style="margin:10px;">選択モード</button>
      <button id="move-selected-to-warehouse-btn" style="display:none; margin:10px;">選択したものを倉庫に送る</button>

      <div id="gacha-confirm-modal" class="modal" style="display:none;">
        <div class="modal-content">
          <p>現在ガチャ箱に入っているカードは削除されます。よろしいですか？</p>
          <button id="gacha-confirm-ok">OK</button>
          <button id="gacha-confirm-cancel">キャンセル</button>
        </div>
      </div>

      <div id="gacha-modal" class="modal" style="display:none;">
        <div class="modal-content">
          <p>生成中...</p>
          <button id="cancel-gacha-btn">キャンセル</button>
        </div>
      </div>

      <div id="card-container"></div>
    </div>

    <!-- IndexedDBなどの共通スクリプト -->
    <script src="js/indexedDB.js"></script>

    <!-- ★ ここで先にgachaCore.jsを読み込む -->
    <script src="js/gachaCore.js"></script>

    <!-- その後、characterCreate.jsを読み込む -->
    <script src="js/characterCreate.js"></script>

    <script>
      // メニューに戻るボタン
      document.getElementById("back-to-menu").addEventListener("click", function () {
        window.location.href = "index.html";
      });
    </script>
</body>
</html>
--- 
index.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>TRPG メニュー</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="container" style="text-align:center; margin-top:50px;">
    <h1>TRPG メニュー</h1>
    <div class="api-key-section">
      <label for="api-key-input">ChatGPT APIキーを入力：</label>
      <input type="text" id="api-key-input" placeholder="APIキーを入力" />
      <button id="set-api-key-button">APIキー設定</button>
      <button id="clear-api-key-button" style="background-color:#f44336;">APIキーをクリア</button>
    </div>
    <div class="element-section">
      <!-- キャラクタ作成ボタン -->
      <button id="character-create">エレメント作成</button>
      <!-- パーティ作成ボタン -->
      <button id="party-create">パーティ作成</button>
      <!-- 全エレメントクリアボタン -->
      <button id="clear-character-btn" style="background-color:#f44336;">全エレメントをクリア</button>
    </div>
    <div class="scenario-section">
      <button id="scenario">フリーシナリオ</button>
      <!-- 履歴クリアボタン -->
      <button id="clear-history-button" style="background-color:#f44336">シナリオをクリア</button>
    </div>

    <!-- ★ 新しいシナリオを始めるボタンを追加 -->
    <div class="scenario-wizard-section" style="margin-top:20px;">
      <button id="start-new-scenario-button" style="background-color:#2196F3;">
        新しいシナリオを始める
      </button>
    </div>
  </div>

  <!-- 外部JavaScript -->
  <script src="js/menu.js"></script>
  <script>
    // キャラクタ作成ボタン押下時、characterCreate.htmlへ遷移
    document.getElementById("character-create").addEventListener("click", function () {
      window.location.href = "characterCreate.html";
    });
    // パーティ作成ボタン押下時、partyCreate.htmlへ遷移
    document.getElementById("party-create").addEventListener("click", function () {
      window.location.href = "partyCreate.html";
    });

    // ★ 新しいシナリオを始める
    document.getElementById("start-new-scenario-button").addEventListener("click", function() {
      window.location.href = "scenarioWizard.html";
    });
  </script>
</body>
</html>
--- 
partyCreate.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>パーティ編成</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>パーティ編成</h1>
    <!-- 倉庫ボタン -->
    <button id="show-warehouse-btn">倉庫</button>

    <!-- 選択モードボタン（パーティ側） -->
    <button id="toggle-party-selection-mode-btn" style="margin-left:10px;">選択モード</button>
    <!-- 選択したカードを倉庫に戻すボタン -->
    <button id="move-selected-to-warehouse-btn" style="margin-left:10px; display:none;">選択したカードを倉庫に戻す</button>

    <!-- パーティ枠（group="Party" のカードを表示）-->
    <div id="party-card-container" style="margin-top:20px;"></div>

    <!-- 倉庫モーダル -->
    <div id="warehouse-modal" class="modal" style="display:none;">
      <div class="modal-content">
        <h2>倉庫</h2>
        <!-- 選択モードボタン（倉庫側） -->
        <button id="toggle-warehouse-selection-mode-btn">選択モード</button>
        <!-- 倉庫選択カードをパーティに入れるボタン -->
        <button id="add-to-party-btn" style="display:none; margin:10px;">パーティに入れる</button>
        <button id="close-warehouse-btn" style="margin:10px;">閉じる</button>
        
        <div id="warehouse-card-container" style="margin:10px 0;"></div>
      </div>
    </div>

    <!-- 戻るボタン -->
    <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>
  </div>

  <!-- スクリプト読み込み -->
  <script src="js/indexedDB.js"></script>
  <script src="js/partyCreate.js"></script>
</body>
</html>
--- 
scenario.html 
<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <title>シンプルTRPG</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
</head>

<body>
  <!-- メニューに戻るボタン -->
  <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>

  <!-- 目的達成型の場合のみ表示する「ネタバレ」ボタン -->
  <button id="spoiler-button" style="display:none; background-color:#E91E63; margin-top:20px; float:right;">
    ネタバレ
  </button>

  <!-- ネタバレ（クリア条件）表示モーダル -->
  <div id="spoiler-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:600px;">
      <h2>クリア条件</h2>
      <p id="clear-condition-text" style="white-space:pre-wrap;"></p>
      <button id="close-spoiler-modal">閉じる</button>
    </div>
  </div>

  <div class="container">
    <!-- シーン履歴 -->
    <div id="scene-history" class="scene-history"></div>

    <!-- シナリオ入力セクション -->
    <div class="input-section">
      <label for="scenario-input">シナリオを入力してください：</label>
      <textarea id="scenario-input" rows="6" placeholder="シナリオを入力..."></textarea>
      <button id="start-button">ゲーム開始</button>
    </div>

    <!-- ゲーム画面セクション -->
    <div class="game-section" style="display:none;">
      <div id="story" style="margin-bottom:20px;"></div>
      <div id="last-scene-images" style="margin-bottom:20px;"></div>
      <div>
        <button id="image-auto-generate-button">自動生成(現シーンから)</button>
        <button id="image-prompt-modal-button">編集して生成(カスタム)</button>
      </div>
      <div id="player-action" style="margin-top:20px;"></div>
      <textarea id="player-input" rows="4" placeholder="プレイヤーの行動を入力..."></textarea>
      <button id="next-scene" style="display:none; margin-top:10px;">次のシーン</button>

      <!-- 探索型なら表示する「カードを取得する」ボタン -->
      <button id="get-card-button" style="display:none; margin-top:20px;">
        カードを取得する
      </button>
    </div>
  </div>

  <!-- ローディングモーダル -->
  <div id="loading-modal" class="modal" style="display:none;">
    <div class="modal-content">
      <p>応答を待っています...</p>
      <button id="cancel-request-button">キャンセル</button>
    </div>
  </div>

  <!-- カスタム画像生成モーダル -->
  <div id="image-prompt-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:400px;">
      <p>画像生成のプロンプトを編集してください</p>
      <textarea id="image-custom-prompt" rows="5" style="width:100%;"></textarea>
      <div style="margin-top:10px;">
        <button id="image-custom-generate-button">生成</button>
        <button id="image-custom-cancel-button">キャンセル</button>
      </div>
    </div>
  </div>

  <!-- ---------- スクリプト群 ---------- -->
  <!-- 各種共通JS -->
  <script src="js/indexedDB.js"></script>
  <script src="js/scene.js"></script>
  <script src="js/image.js"></script>
  <script src="js/main.js"></script>
  <script src="js/gachaCore.js"></script>
  <script src="js/scenarioPage.js"></script>
</body>

</html>--- 
scenarioWizard.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>新しいシナリオ作成ウィザード</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

  <!-- 戻るボタン -->
  <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>

  <div class="container">
    <h1>シナリオ作成ウィザード</h1>

    <!-- ステップ1：ジャンル選択 -->
    <div id="wizard-step1" style="display:block;">
      <h2>ステップ1：ジャンルを選択してください</h2>
      <p>候補をChatGPTで生成します。</p>
      <button id="generate-genre-button">ジャンル候補を生成</button>
      <div id="genre-list" style="margin-top:10px;"></div>
    </div>

    <!-- ステップ2：目的達成型 or 探索型 -->
    <div id="wizard-step2" style="display:none;">
      <h2>ステップ2：シナリオタイプ</h2>
      <button id="type-objective-btn">目的達成型</button>
      <button id="type-exploration-btn">探索型</button>
      <p style="margin-top:10px;">
        ※ 目的達成型では、<strong>クリア条件</strong>が密かに生成されます。  
        ※ 探索型では、シーン中で<span style="text-decoration:underline;">カード(エレメント)取得</span>が可能になります。
      </p>
    </div>

    <!-- ステップ3：最終確認(シナリオ要約表示) -->
    <div id="wizard-step3" style="display:none;">
      <h2>ステップ3：シナリオ要約</h2>
      <div id="scenario-summary" style="border:1px solid #ccc; padding:10px; margin-bottom:10px;">
        <!-- 生成されたシナリオ概要を表示 -->
      </div>
      <button id="start-scenario-button" style="background-color:#4CAF50;">
        このシナリオで始める
      </button>
    </div>
  </div>

  <!-- ChatGPT応答待ちモーダル -->
  <div id="loading-modal" class="modal" style="display:none;">
    <div class="modal-content">
      <p>応答を待っています...</p>
      <button id="cancel-request-button">キャンセル</button>
    </div>
  </div>

  <!-- Script -->
  <script src="js/indexedDB.js"></script>
  <script src="js/scenarioWizard.js"></script>

  <!-- 戻るボタン用 -->
  <script>
    document.getElementById("back-to-menu").addEventListener("click", function() {
      window.location.href = "index.html";
    });
  </script>
</body>
</html>
--- 
styles.css 
/* styles.css */

/* ベース */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f5f5f5;
}

.container {
  max-width: 1000px;
  margin: 20px auto;
  padding: 20px;
  background-color: #fff;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
  text-align: center;
}

h2 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

.api-key-section {
  margin-bottom: 20px;
}

input,
textarea {
  width: 100%;
  padding: 10px;
  font-size: 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

button {
  padding: 10px 20px;
  background-color: #4CAF50;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-bottom: 10px;
}

button:hover {
  background-color: #45a049;
}

/* シーン履歴 */
.scene-history {
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 10px;
  background-color: #f9f9f9;
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 20px;
}

.history-tile {
  padding: 10px;
  border: 1px solid #ccc;
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* テキスト編集領域 */
.scene-text,
.action-text,
.scenario-text {
  margin: 0;
  padding: 5px;
  font-size: 14px;
  border: 1px dashed transparent;
  cursor: text;
}

.scene-text[contenteditable]:focus,
.action-text[contenteditable]:focus,
.scenario-text[contenteditable]:focus {
  border: 1px dashed #4CAF50;
  outline: none;
}

/* メイン表示するシーン部分 */
#story {
  font-size: 1.4rem;
  padding-bottom: 10px;
  border-bottom: 1px solid #ccc;
  min-height: 60px;
}

/* モーダル */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.modal-content {
  box-sizing: border-box;
  width: calc(100% - 20px);
  background-color: #fff;
  padding: 20px 40px;
  border-radius: 5px;
  text-align: center;
  max-height: 90vh;
  overflow-y: auto;
}


/* --- styles.css --- */

/* 既存の共通部分はそのままで */

/* カードコンテナをCSS Gridに変更 */
#card-container {
  display: grid;
  gap: 20px;
  /* 1列(スマホ)～3列(PC)になるようにレスポンシブに設定 */
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

/* カードコンテナの共通設定 */
.card {
  /* 横幅はセル幅に合わせる */
  width: 100%;
  /* ブラウザ対応の場合、aspect-ratioプロパティで比率を指定 */
  aspect-ratio: 63 / 88;
  perspective: 1000px;
  /* 3D効果用 */
  cursor: pointer;
  transition: transform 0.3s ease;
  position: relative;
}

/* マウスオーバー時に少し大きく */
.card:hover {
  transform: scale(1.05);
}

/* 内部要素 */
.card-inner {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 0.6s;
}

/* クリックで反転 */
.card.flipped .card-inner {
  transform: rotateY(180deg);
}

/* 表面 */
.card-front,
.card-back {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 15px;
  backface-visibility: hidden;
  box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2);
}

.card-front {
  box-sizing: border-box;
  padding: 3%;
  border-radius: 3%;
}

/* 表面のスタイル */
.card-front {
  background-color: #fff;
  display: flex;
  flex-direction: column;
  position: relative;
}

.card-front h3 {
  padding: 0;
  margin: 0;
  font-size: 1rem;
}

/* 左上にタイプ表示用 */
.card-front .card-type {
  position: absolute;
  right: 10px;
  background-color: rgba(255, 255, 255, 0.8);
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: bold;
  font-size: 0.85rem;
  z-index: 2;
}

/* 画像エリア */
.card-front .card-image {
  width: 100%;
  height: 40%;
  background: linear-gradient(135deg, #cccccc70, #eeeeee70);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

/* 画像エリア内の実際の画像 */
.card-front .card-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: top;
}

/* 画像生成ボタン（画像が無い場合のみ表示） */
.card-front .gen-image-btn {
  position: absolute;
  bottom: 8px;
  right: 8px;
  padding: 4px 8px;
  background-color: rgba(0, 0, 0, 0.6);
  color: #fff;
  border: none;
  border-radius: 4px;
  font-size: 0.8rem;
  z-index: 2;
}

/* 下部テキスト情報 */
.card-front .card-info {
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  flex-grow: 1;
  overflow: auto;
  background-color: rgba(255, 255, 255, 0.7);
}

.card-front .card-info p {
  margin: 0;
  font-size: 0.85rem;
}

.card-front .card-info p:last-child {
  padding: 0;
  height: 100%;
  font-size: 0.85rem;
  align-items: center;
  display: flex;
  background-color: #EEE;
  margin-top: 10px;
}

.card-front .card-info p:last-child span {
  transform: skew(-5deg);
  display: flex;
  padding: 10px;
}

/* 裏面：かっこよさげな背景 */
.card-back {
  box-sizing: border-box;
  background: linear-gradient(135deg, #1e3c72, #2a5298);
  color: #fff;
  transform: rotateY(180deg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  padding: 10px;
  text-align: center;
}

/* レスポンシブ */
@media (max-width: 600px) {
  #card-container {
    grid-template-columns: repeat(1, 1fr);
  }
}

.bezel {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  z-index: 100;
  border-radius: 2%;
  padding: 3%;
}

.bezel.rarity0 {
  background: linear-gradient(145deg, #C0C0C0, #D3D3D3, #E0E0E0, #A9A9A9);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity1 {
  background: linear-gradient(145deg, #B87333, #DA8A67, #E97451, #C35817);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity2 {
  background: linear-gradient(145deg, #C0C0C0, #D3D3D3, #E0E0E0, #A9A9A9);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity3 {
  background: linear-gradient(145deg, #b69a00, #ffda64, #ffda6b, #d79000);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

/* レアリティ4: プラチナ */
.bezel.rarity4 {
  position: absolute;
  background: linear-gradient(145deg, #d1d1d1, #aeb9ff, #C0C0C0, #ECEBE8);
  background-size: 400% 400%;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: platinum-shimmer 5s ease-in-out infinite;
}

/* レアリティ5: 宝石 */
.bezel.rarity5 {
  background: linear-gradient(145deg, #4B0082, #0000CD, #008080, #fff);
  background-size: 150% 150%;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: jewel-glow 5s ease-in-out infinite;
}

@keyframes platinum-shimmer {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

@keyframes jewel-glow {
  0% {
    filter: brightness(1);
    background-position: 0% 50%;
  }
  50% {
    filter: brightness(1.2);
    background-position: 100% 50%;
  }
  100% {
    filter: brightness(1);
    background-position: 0% 50%;
  }
}

/* partyCreate.htmlのカードを3列に */
#party-card-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
}

/* 倉庫モーダル内のカードも3列に */
#warehouse-card-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
}

/* 選択状態 */
.card.selected {
  outline: 4px solid #f44336;
  outline-offset: -4px;
  transform: scale(1.05);
  box-shadow: 0 0 10px rgba(244,67,54,0.6);
}
--- 
backToMenu.js 
document.getElementById("back-to-menu").addEventListener("click", function () {
    window.location.href = "index.html";
});
--- 
characterCreate.js 
// characterCreate.js

// グローバル変数
window.apiKey = localStorage.getItem("apiKey") || "";

// キャラクタ情報 [{ id, ... }, ...]
window.characterData = [];

// 選択モードフラグ
let isSelectionMode = false;

window.addEventListener("load", async function () {
    await initIndexedDB();
    const stored = await loadCharacterDataFromIndexedDB();
    if (stored) {
        window.characterData = stored;
    }
    displayCharacterCards(window.characterData);

    // ▼ ボタン要素があればイベント登録
    const gachaBtn = document.getElementById("gacha-btn");
    if (gachaBtn) {
        gachaBtn.addEventListener("click", onGachaButton);
    }

    const moveGachaBtn = document.getElementById("move-gacha-to-warehouse-btn");
    if (moveGachaBtn) {
        moveGachaBtn.addEventListener("click", onMoveGachaToWarehouse);
    }

    const toggleModeBtn = document.getElementById("toggle-selection-mode-btn");
    if (toggleModeBtn) {
        toggleModeBtn.addEventListener("click", toggleSelectionMode);
    }

    const moveSelectedBtn = document.getElementById("move-selected-to-warehouse-btn");
    if (moveSelectedBtn) {
        moveSelectedBtn.addEventListener("click", moveSelectedCardsToWarehouse);
    }
});

/** ガチャボタン押下 */
function onGachaButton() {
    const confirmModal = document.getElementById("gacha-confirm-modal");
    confirmModal.style.display = "flex";

    const okBtn = document.getElementById("gacha-confirm-ok");
    const cancelBtn = document.getElementById("gacha-confirm-cancel");

    okBtn.onclick = async () => {
        confirmModal.style.display = "none";
        clearGachaBox();
        // ★ 以前はrunGacha(10,"...")を自前で定義していたが
        //   今回は gachaCore.js からインポートされた runGacha() を呼ぶ
        document.getElementById("gacha-modal").style.display = "flex";
        await runGacha(10, "ランダムで");
        hideGachaModal();
        displayCharacterCards(window.characterData);
    };

    cancelBtn.onclick = () => {
        confirmModal.style.display = "none";
    };
}

/** ガチャ箱クリア */
function clearGachaBox() {
    window.characterData = window.characterData.filter(card => card.group !== "GachaBox");
}

/** ガチャモーダルを隠す */
function hideGachaModal() {
    const m = document.getElementById("gacha-modal");
    if(m) m.style.display = "none";
}

/** ガチャ箱のカードを倉庫へ */
async function onMoveGachaToWarehouse() {
    let changed = false;
    window.characterData.forEach(card => {
        if (card.group === "GachaBox") {
            card.group = "Warehouse";
            changed = true;
        }
    });
    if (changed) {
        await saveCharacterDataToIndexedDB(window.characterData);
        displayCharacterCards(window.characterData);
        alert("ガチャ箱のカードを倉庫に移動しました。");
    } else {
        alert("ガチャ箱にカードがありません。");
    }
}

/** カード表示更新 */
function displayCharacterCards(characters) {
    const container = document.getElementById("card-container");
    if(!container) return;

    container.innerHTML = "";
    const visibleCards = characters.filter(
        card => card.group !== "Warehouse" && card.group !== "Party"
    );
    if (visibleCards.length === 0) {
        container.textContent = "エレメントが生成されていません。";
        return;
    }
    visibleCards.forEach((ch) => {
        const realIndex = window.characterData.findIndex(c => c.id === ch.id);
        const cardEl = createCardElement(ch, realIndex);
        container.appendChild(cardEl);
    });
}

/** カードDOM生成 */
function createCardElement(char, index) {
    const card = document.createElement("div");
    card.className = "card";
    card.setAttribute("data-id", char.id);

    card.addEventListener("click", (e) => {
        if (isSelectionMode) {
            e.stopPropagation();
            card.classList.toggle("selected");
            updateMoveSelectedButtonVisibility();
        } else {
            card.classList.toggle("flipped");
        }
    });

    const cardInner = document.createElement("div");
    cardInner.className = "card-inner";

    const cardFront = document.createElement("div");
    cardFront.className = "card-front";
    const bgStyle = char.backgroundcss
        .replace("background-image:", "")
        .replace("background", "")
        .trim();
    cardFront.style = "background-image:" + bgStyle;

    const rarityValue = (typeof char.rarity === "string") ? char.rarity.replace("★", "").trim() : "0";
    cardFront.innerHTML = `<div class='bezel rarity${rarityValue}'></div>`;

    const typeEl = document.createElement("div");
    typeEl.className = "card-type";
    typeEl.textContent = char.type || "不明";
    cardFront.appendChild(typeEl);

    const imageContainer = document.createElement("div");
    imageContainer.className = "card-image";
    if (char.imageData) {
        const imageEl = document.createElement("img");
        imageEl.src = char.imageData;
        imageEl.alt = char.name;
        imageContainer.appendChild(imageEl);
    } else {
        // 画像がまだ無い場合（省略）
    }
    cardFront.appendChild(imageContainer);

    // 情報
    const infoContainer = document.createElement("div");
    infoContainer.className = "card-info";

    const nameEl = document.createElement("p");
    nameEl.innerHTML = "<h3>" + DOMPurify.sanitize(char.name) + "</h3>";
    infoContainer.appendChild(nameEl);

    if (char.state) {
        const stateEl = document.createElement("p");
        stateEl.innerHTML = "<strong>状態：</strong>" + DOMPurify.sanitize(char.state);
        infoContainer.appendChild(stateEl);
    }
    const specialEl = document.createElement("p");
    specialEl.innerHTML = "<strong>特技：</strong>" + DOMPurify.sanitize(char.special);
    infoContainer.appendChild(specialEl);

    const captionEl = document.createElement("p");
    captionEl.innerHTML = "<span>" + DOMPurify.sanitize(char.caption) + "</span>";
    infoContainer.appendChild(captionEl);

    cardFront.appendChild(infoContainer);

    const cardBack = document.createElement("div");
    cardBack.className = "card-back";
    cardBack.innerHTML = `<strong>${DOMPurify.sanitize(char.type)}</strong>`;

    cardInner.appendChild(cardFront);
    cardInner.appendChild(cardBack);
    card.appendChild(cardInner);

    return card;
}

/* ===== 以下、選択モード関連処理 ===== */

function toggleSelectionMode() {
    isSelectionMode = !isSelectionMode;
    const btn = document.getElementById("toggle-selection-mode-btn");
    if (isSelectionMode) {
        btn.textContent = "選択モード解除";
    } else {
        btn.textContent = "選択モード";
        const selectedCards = document.querySelectorAll("#card-container .card.selected");
        selectedCards.forEach(card => card.classList.remove("selected"));
    }
    updateMoveSelectedButtonVisibility();
}

function updateMoveSelectedButtonVisibility() {
    const selectedCards = document.querySelectorAll("#card-container .card.selected");
    const moveBtn = document.getElementById("move-selected-to-warehouse-btn");
    if (!moveBtn) return;
    if (isSelectionMode && selectedCards.length > 0) {
        moveBtn.style.display = "inline-block";
    } else {
        moveBtn.style.display = "none";
    }
}

async function moveSelectedCardsToWarehouse() {
    const selectedCards = document.querySelectorAll("#card-container .card.selected");
    if (selectedCards.length === 0) {
        alert("カードが選択されていません。");
        return;
    }
    selectedCards.forEach(el => {
        const cardId = el.getAttribute("data-id");
        const realIndex = window.characterData.findIndex(c => c.id === cardId);
        if (realIndex !== -1) {
            window.characterData[realIndex].group = "Warehouse";
        }
    });
    await saveCharacterDataToIndexedDB(window.characterData);
    selectedCards.forEach(card => card.classList.remove("selected"));
    displayCharacterCards(window.characterData);
    updateMoveSelectedButtonVisibility();
}
--- 
gachaCore.js 
// gachaCore.js
// ------------------------------------------
// 「ガチャ処理」のロジックだけを集めたファイル
// ------------------------------------------

// グローバルに必要な変数 (characterData, apiKey など) は
// すでに window に存在すると仮定 (indexedDB や parse等も)


// --------------------------------------------------------
// 1. runGacha(cardCount, addPrompt, onlyTitle = "")
//
//   - 指定枚数のエレメントをChatGPTで生成し、window.characterDataに加える
//   - UI操作は行わず、コンソールに進捗をログ出力するだけ
// --------------------------------------------------------
async function runGacha(cardCount, addPrompt, onlyTitle = "", onlyType = "") {
  console.log("=== runGacha START ===");
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  // キャンセル用コントローラ
  window.currentGachaController = new AbortController();
  const signal = window.currentGachaController.signal;

  // レア度をランダムで決定
  const rarities = pickRaritiesForNCards(cardCount);
  const countMap = makeRarityCountMap(rarities);

  // systemプロンプト
  let systemContent = `
  あなたはTRPG用のキャラクター、装備品、モンスター作成のエキスパートです。
  以下の6段階のレア度「★0～★5」のうち、
  今回の${cardCount}件では以下の内訳を厳密に守って生成してください：
  - ★0: ${countMap["★0"]}件
  - ★1: ${countMap["★1"]}件
  - ★2: ${countMap["★2"]}件
  - ★3: ${countMap["★3"]}件
  - ★4: ${countMap["★4"]}件
  - ★5: ${countMap["★5"]}件
  
  生成するのがキャラクターやモンスターの場合
  【レア度】：...
  【名前】：...
  【タイプ】：キャラクターまたはモンスター
  【状態】：...
  【特技】：...
  【キャプション】：...
  【カード背景】：...
  【外見】：...
  
  生成するのがアイテムの場合
  【レア度】：...
  【名前】：...
  【タイプ】：アイテム
  【特技】：...
  【キャプション】：...
  【カード背景】：...
  【外見】：...
    `;

  let userContent = `${addPrompt}合計${cardCount}件、順番は問わないので上記レア度数で生成してください。`;

  if (onlyTitle != "") {
    systemContent = `
  あなたはTRPG用のキャラクター、装備品、モンスター作成のエキスパートです。
  6段階のレア度「★0～★5」のどれかを${onlyTitle}の名称から判断して設定してください。
  
  生成するのがキャラクターやモンスターの場合
  【レア度】：...
  【名前】：${onlyTitle}
  【タイプ】：${onlyType}
  【状態】：...
  【特技】：...
  【キャプション】：...
  【カード背景】：...
  【外見】：...
  
  生成するのがアイテムの場合
  【レア度】：...
  【名前】：${onlyType}
  【タイプ】：${onlyType}
  【特技】：...
  【キャプション】：...
  【カード背景】：...
  【外見】：...
    `;
    userContent = `${addPrompt}上記レア度数で生成してください。`;
  }

  const messages = [
    { role: "system", content: systemContent },
    { role: "user", content: userContent },
  ];

  try {
    console.log("runGacha: Fetch start...");
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`,
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages,
        temperature: 0.7,
      }),
      signal,
    });
    if (signal.aborted) {
      console.log("runGacha: aborted.");
      return;
    }

    const data = await response.json();
    if (data.error) {
      throw new Error(data.error.message);
    }

    const text = data?.choices?.[0]?.message?.content;
    if (typeof text !== "string") {
      throw new Error("エレメント生成APIレスポンスが不正です。");
    }

    const newCards = parseCharacterData(text);
    // 生成されたカードを GachaBox に設定
    newCards.forEach(card => {
      card.group = "GachaBox";
    });
    // 既存 characterData に追加
    window.characterData.push(...newCards);

    // IndexedDB に保存
    await saveCharacterDataToIndexedDB(window.characterData);

    console.log(`runGacha: ${newCards.length}件のカードを生成完了`);
  } catch (err) {
    if (err.name === "AbortError") {
      console.log("runGachaキャンセル");
    } else {
      console.error("runGacha失敗:", err);
      alert("エレメント生成に失敗しました:\n" + err.message);
    }
  } finally {
    console.log("=== runGacha END ===");
  }
}


// --------------------------------------------------------
// 2. parseCharacterData( text )
//    - GPTレスポンスを解析してカード配列を生成
// --------------------------------------------------------
function parseCharacterData(text) {
  const lines = text.split("\n");
  const characters = [];
  let currentChar = {
    id: "",
    type: "",
    name: "",
    state: "",
    special: "",
    caption: "",
    rarity: "★0",
    backgroundcss: "",
    imageprompt: "",
    group: "GachaBox",
  };

  function pushCurrentChar() {
    currentChar.id = "card_" + Date.now() + "_" + Math.random().toString(36).substring(2);
    characters.push({ ...currentChar });
    currentChar = {
      id: "",
      type: "",
      name: "",
      state: "",
      special: "",
      caption: "",
      rarity: "★0",
      backgroundcss: "",
      imageprompt: "",
      group: "GachaBox",
    };
  }

  lines.forEach((line) => {
    line = line.trim();
    if (line.startsWith("【名前】")) {
      if (currentChar.name) pushCurrentChar();
      currentChar.name = line.replace("【名前】", "").replace("：", "").trim();
    } else if (line.startsWith("【タイプ】")) {
      currentChar.type = line.replace("【タイプ】", "").replace("：", "").trim();
    } else if (line.startsWith("【状態】")) {
      currentChar.state = line.replace("【状態】", "").replace("：", "").trim();
    } else if (line.startsWith("【特技】")) {
      currentChar.special = line.replace("【特技】", "").replace("：", "").trim();
    } else if (line.startsWith("【キャプション】")) {
      currentChar.caption = line.replace("【キャプション】", "").replace("：", "").trim();
    } else if (line.startsWith("【レア度】")) {
      currentChar.rarity = line.replace("【レア度】", "").replace("：", "").trim();
    } else if (line.startsWith("【カード背景】")) {
      currentChar.backgroundcss = line.replace("【カード背景】", "").replace("：", "").trim();
    } else if (line.startsWith("【外見】")) {
      currentChar.imageprompt = line.replace("【外見】", "").replace("：", "").trim();
    }
  });
  if (currentChar.name) {
    pushCurrentChar();
  }
  return characters;
}


// --------------------------------------------------------
// 3. pickRaritiesForNCards( n ), makeRarityCountMap( rarities )
// --------------------------------------------------------
function pickRaritiesForNCards(n) {
  const rarityDist = [
    { star: "★0", probability: 0.50 },
    { star: "★1", probability: 0.20 },
    { star: "★2", probability: 0.15 },
    { star: "★3", probability: 0.10 },
    { star: "★4", probability: 0.045 },
    { star: "★5", probability: 0.005 },
  ];
  const results = [];
  for (let i = 0; i < n; i++) {
    const rand = Math.random();
    let cum = 0;
    for (const r of rarityDist) {
      cum += r.probability;
      if (rand <= cum) {
        results.push(r.star);
        break;
      }
    }
  }
  return results;
}

function makeRarityCountMap(rarities) {
  const counts = { "★0": 0, "★1": 0, "★2": 0, "★3": 0, "★4": 0, "★5": 0 };
  rarities.forEach((r) => {
    counts[r] = (counts[r] || 0) + 1;
  });
  return counts;
}

// ----------------------------------------------
// ↑ これらをまとめて gachaCore.js として管理
// ----------------------------------------------
--- 
image.js 
/********************************
 * image.js - 画像生成関連
 ********************************/

/**
 * DALL·E API からBase64形式で直接画像を受け取り、CORSを回避する方法。
 * OpenAIの画像生成では以下のパラメータを指定することで、直接base64を返してもらうことが可能。
 *   response_format: "b64_json"
 */

/** 自動生成(現シーン) */
async function generateImageFromCurrentScene() {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  const lastSceneEntry = [...window.sceneHistory].reverse().find((e) => e.type === "scene");
  if (!lastSceneEntry) {
    alert("まだシーンがありません。");
    return;
  }
  const promptText = `シーンのイメージ: ${lastSceneEntry.content}`;
  const sceneId = lastSceneEntry.sceneId;

  window.cancelRequested = false;
  showLoadingModal(true);

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const response = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`,
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: promptText,
        n: 1,
        size: "1024x1024",
        response_format: "b64_json"
      }),
      signal,
    });

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }

    const data = await response.json();

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }
    if (data.error) {
      throw new Error(data.error.message);
    }

    // Base64文字列を取り出し、data:image/png;base64, に変換
    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    window.sceneHistory.push({
      type: "image",
      sceneId,
      prompt: promptText,
      dataUrl: dataUrl,
    });

    // IndexedDBに保存
    await saveSceneHistoryToIndexedDB(window.sceneHistory);

    updateSceneHistory();
    showLastScene();
  } catch (error) {
    if (error.name === "AbortError") {
      console.warn("画像生成キャンセル");
    } else {
      console.error("画像生成失敗:", error);
      alert("画像生成に失敗:\n" + error.message);
    }
  } finally {
    showLoadingModal(false);
  }
}

/** カスタム画像生成モーダルを開く */
function openImagePromptModal(prompt = "", index = null) {
  window.editingImageEntry = null;
  if (index !== null) {
    // 再生成の場合
    window.editingImageEntry = { index };
    const entry = window.sceneHistory[index];
    if (entry && entry.type === "image") {
      prompt = entry.prompt;
    }
  } else {
    // 新規
    const lastSceneEntry = [...window.sceneHistory].reverse().find((e) => e.type === "scene");
    if (lastSceneEntry) {
      prompt = lastSceneEntry.content;
    } else {
      prompt = window.scenario || "Fantasy scene";
    }
  }
  document.getElementById("image-custom-prompt").value = prompt;
  document.getElementById("image-prompt-modal").style.display = "flex";
}

/** カスタム画像生成モーダルを閉じる */
function closeImagePromptModal() {
  document.getElementById("image-prompt-modal").style.display = "none";
  window.editingImageEntry = null;
}

/** カスタム画像生成ボタン押下 */
async function onCustomImageGenerate() {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  const promptText = document.getElementById("image-custom-prompt").value.trim() || "Fantasy scene";

  window.cancelRequested = false;
  showLoadingModal(true);
  closeImagePromptModal();

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const response = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`,
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: promptText,
        n: 1,
        size: "1024x1024",
        response_format: "b64_json"
      }),
      signal,
    });

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }

    const data = await response.json();

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }
    if (data.error) {
      throw new Error(data.error.message);
    }

    // Base64文字列を取り出し、data:image/png;base64, に変換
    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    if (window.editingImageEntry) {
      // 既存画像を再生成
      const idx = window.editingImageEntry.index;
      const entry = window.sceneHistory[idx];
      if (entry && entry.type === "image") {
        entry.dataUrl = dataUrl;
        entry.prompt = promptText;
      }
    } else {
      // 新規
      const lastSceneEntry = [...window.sceneHistory].reverse().find((e) => e.type === "scene");
      if (!lastSceneEntry) {
        alert("シーンがありません。");
        showLoadingModal(false);
        return;
      }
      window.sceneHistory.push({
        type: "image",
        sceneId: lastSceneEntry.sceneId,
        prompt: promptText,
        dataUrl: dataUrl,
      });
    }

    // IndexedDBに保存
    await saveSceneHistoryToIndexedDB(window.sceneHistory);

    updateSceneHistory();
    showLastScene();
  } catch (error) {
    if (error.name === "AbortError") {
      console.warn("カスタム画像生成キャンセル");
    } else {
      console.error("カスタム画像生成失敗:", error);
      alert("カスタム画像生成失敗:\n" + error.message);
    }
  } finally {
    showLoadingModal(false);
  }
}
--- 
indexedDB.js 
/********************************
 * indexedDB.js
 * IndexedDB関連の初期化・保存・読み込み等を担当
 ********************************/

let db = null;

/**
 * DB初期化
 * "trpgDB" というDBに "sceneHistory" と "characterData" のストアを作る
 */
function initIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("trpgDB", 2);
    request.onupgradeneeded = (event) => {
      db = event.target.result;
      // sceneHistory ストアが無ければ作成
      if (!db.objectStoreNames.contains("sceneHistory")) {
        db.createObjectStore("sceneHistory", { keyPath: "id" });
      }
      // characterData ストアが無ければ作成
      if (!db.objectStoreNames.contains("characterData")) {
        db.createObjectStore("characterData", { keyPath: "id" });
      }
    };
    request.onsuccess = (event) => {
      db = event.target.result;
      resolve();
    };
    request.onerror = (event) => {
      console.error("IndexedDBの初期化に失敗:", event.target.error);
      reject(event.target.error);
    };
  });
}

/**
 * sceneHistory をまとめて IndexedDB へ保存
 * 1レコード (id=1) に配列データを保存する
 */
function saveSceneHistoryToIndexedDB(sceneHistory) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve();
      return;
    }
    const tx = db.transaction("sceneHistory", "readwrite");
    const store = tx.objectStore("sceneHistory");

    // まず既存データをクリア
    const clearRequest = store.clear();
    clearRequest.onsuccess = () => {
      // クリア後に、id=1 として保存
      const record = { id: 1, data: sceneHistory };
      const putReq = store.put(record);
      putReq.onsuccess = () => {
        resolve();
      };
      putReq.onerror = (err) => {
        reject(err);
      };
    };
    clearRequest.onerror = (err) => {
      reject(err);
    };
  });
}

/**
 * IndexedDBから sceneHistory をロード
 */
function loadSceneHistoryFromIndexedDB() {
  return new Promise((resolve) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve([]);
      return;
    }
    const tx = db.transaction("sceneHistory", "readonly");
    const store = tx.objectStore("sceneHistory");
    const getReq = store.get(1);
    getReq.onsuccess = (event) => {
      if (event.target.result && event.target.result.data) {
        resolve(event.target.result.data);
      } else {
        resolve([]);
      }
    };
    getReq.onerror = () => {
      resolve([]);
    };
  });
}

/**
 * キャラクターデータを IndexedDB に保存する
 */
function saveCharacterDataToIndexedDB(characterData) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve();
      return;
    }
    const tx = db.transaction("characterData", "readwrite");
    const store = tx.objectStore("characterData");
    const record = { id: "characterData", data: characterData };
    const putReq = store.put(record);
    putReq.onsuccess = () => {
      resolve();
    };
    putReq.onerror = (err) => {
      reject(err);
    };
  });
}

/**
 * IndexedDBからキャラクターデータをロードする
 */
function loadCharacterDataFromIndexedDB() {
  return new Promise((resolve) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve([]);
      return;
    }
    const tx = db.transaction("characterData", "readonly");
    const store = tx.objectStore("characterData");
    const getReq = store.get("characterData");
    getReq.onsuccess = (event) => {
      if (event.target.result && event.target.result.data) {
        resolve(event.target.result.data);
      } else {
        resolve([]);
      }
    };
    getReq.onerror = () => {
      resolve([]);
    };
  });
}
--- 
main.js 
/********************************
 * main.js - ページ全体の初期化・イベント登録
 ********************************/

window.onload = async () => {
  // まずIndexedDB初期化（sceneHistory と characterData の両方を利用）
  await initIndexedDB();

  // ローカルストレージから各種情報を取得
  const savedApiKey = localStorage.getItem('apiKey');
  if (savedApiKey) {
    window.apiKey = savedApiKey;
  }

  // ▼ ウィザードデータがあるかどうかをチェック
  let wizardData = null;
  const wizardDataStr = localStorage.getItem("wizardData");
  if(wizardDataStr){
    try {
      wizardData = JSON.parse(wizardDataStr);
    } catch(e){}
  }

  // scenario(フリー入力) を優先するが、URLクエリにfromWizard=true ならウィザードデータを使う
  const urlParams = new URLSearchParams(window.location.search);
  const fromWizard = urlParams.get("fromWizard") === "true";

  if(fromWizard && wizardData){
    // ウィザードのサマリを window.scenario に設定
    window.scenario = wizardData.scenarioSummary || "";
    // さらに scenarioType / clearCondition も持っておく
    window.scenarioType = wizardData.scenarioType;  // "objective" or "exploration"
    window.clearCondition = wizardData.clearCondition; // 目的達成型でのみ使う

    // localStorageにも一応保存（リロードに備える）
    localStorage.setItem('scenario', window.scenario);
    // ただし クリア条件は表シナリオに含めない
  } else {
    // フリーシナリオ時と同じ扱い
    const savedScenario = localStorage.getItem('scenario');
    if (savedScenario) {
      window.scenario = savedScenario;
      if (window.scenario === '（シナリオは未入力です）') {
        window.scenario = '';
        localStorage.removeItem('scenario');
      }
    }
  }

  // sceneHistory は IndexedDB から取得
  const loadedHistory = await loadSceneHistoryFromIndexedDB();
  window.sceneHistory = loadedHistory || [];

  // currentScene は localStorage から読み取る
  const savedCurrentScene = localStorage.getItem('currentScene');
  if (savedCurrentScene) {
    window.currentScene = parseInt(savedCurrentScene, 10);
  } else {
    window.currentScene = 0;
  }

  // scenarioType をチェックして、目的達成型ならネタバレボタン表示、探索型なら「カードを取得する」ボタンを表示
  if(window.scenarioType === "objective"){
    document.getElementById("spoiler-button").style.display = "inline-block";
    // クリア条件をモーダルに表示
    const spoilerTextEl = document.getElementById("clear-condition-text");
    if(spoilerTextEl){
      spoilerTextEl.textContent = window.clearCondition || "（クリア条件なし）";
    }
  } else if(window.scenarioType === "exploration"){
    document.getElementById("get-card-button").style.display = "inline-block";
  }

  // APIキーが無い場合 -> .input-section や .game-section を非表示
  if (!window.apiKey) {
    const inputSection = document.querySelector('.input-section');
    const gameSection = document.querySelector('.game-section');
    if (inputSection) inputSection.style.display = 'none';
    if (gameSection) gameSection.style.display = 'none';
  } else {
    // シナリオがあればゲーム画面を表示、なければシナリオ入力画面を表示
    if (window.scenario && window.scenario.trim() !== '') {
      if (document.querySelector('.input-section')) {
        document.querySelector('.input-section').style.display = 'none';
      }
      if (document.querySelector('.game-section')) {
        document.querySelector('.game-section').style.display = 'block';
      }
    } else {
      if (document.querySelector('.input-section')) {
        document.querySelector('.input-section').style.display = 'block';
      }
      if (document.querySelector('.game-section')) {
        document.querySelector('.game-section').style.display = 'none';
      }
    }
  }

  // シナリオタイルと履歴を表示、最後のシーンをメインに表示
  displayScenarioTile();
  updateSceneHistory();
  showLastScene();

  // 各種イベントリスナーの登録

  // 応答キャンセルボタン
  const cancelRequestBtn = document.getElementById('cancel-request-button');
  if (cancelRequestBtn) {
    cancelRequestBtn.addEventListener('click', onCancelFetch);
  }

  // APIキー設定
  const setApiKeyBtn = document.getElementById('set-api-key-button');
  if (setApiKeyBtn) {
    setApiKeyBtn.addEventListener('click', () => {
      setApiKey();
    });
  }

  // APIキークリア
  const clearApiKeyBtn = document.getElementById('clear-api-key-button');
  if (clearApiKeyBtn) {
    clearApiKeyBtn.addEventListener('click', () => {
      clearApiKey();
    });
  }

  // ゲーム開始ボタン
  const startBtn = document.getElementById('start-button');
  if (startBtn) {
    startBtn.addEventListener('click', () => {
      startGame();
    });
  }

  // 次のシーンボタン
  const nextSceneBtn = document.getElementById('next-scene');
  if (nextSceneBtn) {
    nextSceneBtn.addEventListener('click', () => {
      nextScene();
    });
  }

  // 画像生成関連のボタン
  const autoGenBtn = document.getElementById('image-auto-generate-button');
  if (autoGenBtn) {
    autoGenBtn.addEventListener('click', () => {
      generateImageFromCurrentScene();
    });
  }

  const promptModalBtn = document.getElementById('image-prompt-modal-button');
  if (promptModalBtn) {
    promptModalBtn.addEventListener('click', () => {
      openImagePromptModal();
    });
  }

  const customGenBtn = document.getElementById('image-custom-generate-button');
  if (customGenBtn) {
    customGenBtn.addEventListener('click', () => {
      onCustomImageGenerate();
    });
  }

  const customCancelBtn = document.getElementById('image-custom-cancel-button');
  if (customCancelBtn) {
    customCancelBtn.addEventListener('click', () => {
      closeImagePromptModal();
    });
  }
};

/** もしプレイヤーに「クリア条件は？」など聞かれても答えないようにする場合は、scene.js の getNextScene()で
 *  messagesに追加する前にフィルタする等の実装を行う。今回はサンプルとしてコメントで示すのみ。
 */
--- 
menu.js 
// menu.js

// 「シナリオ」ボタン押下で scenario.html へ遷移
document.getElementById("scenario").addEventListener("click", function () {
    window.location.href = "scenario.html";
});

// APIキー設定
document.getElementById("set-api-key-button").addEventListener("click", function () {
    const apiKey = document.getElementById("api-key-input").value.trim();
    if (apiKey) {
        localStorage.setItem("apiKey", apiKey);
        alert("APIキーが設定されました。");
    } else {
        alert("APIキーを入力してください。");
    }
});

// APIキークリア
document.getElementById("clear-api-key-button").addEventListener("click", function () {
    const confirmClear = confirm("APIキーをクリアすると操作ができなくなります。よろしいですか？");
    if (confirmClear) {
        localStorage.removeItem("apiKey");
        alert("APIキーがクリアされました。");
    }
});

// ページ読み込み時にAPIキーを入力欄に表示
window.addEventListener("load", function () {
    const savedApiKey = localStorage.getItem("apiKey");
    if (savedApiKey) {
        document.getElementById("api-key-input").value = savedApiKey;
    }
});

/** パーティ作成ボタン押下時、partyCreate.htmlへ */
document.getElementById("party-create").addEventListener("click", () => {
    window.location.href = "partyCreate.html";
});

// エレメントクリアボタン
document.getElementById("clear-character-btn").addEventListener("click", async () => {
    const confirmClear = confirm("エレメント情報をクリアします。よろしいですか？");
    if (confirmClear) {
        window.characterData = [];
        await saveCharacterDataToIndexedDB(window.characterData);
        document.getElementById("card-container").innerHTML = "";
        alert("エレメント情報をクリアしました。");
    }
});

// 履歴クリアボタン
const clearHistoryBtn = document.getElementById('clear-history-button');
if (clearHistoryBtn) {
    clearHistoryBtn.addEventListener('click', async () => {
        const isOk = confirm('履歴をすべて削除します。（シナリオも削除されます）よろしいですか？');
        if (!isOk) return;

        // IndexedDB の sceneHistory をクリア
        if (window.sceneHistory && window.sceneHistory.length > 0) {
            // IndexedDBのストアを直接クリアするためにトランザクションを利用
            if (window.indexedDB) {
                try {
                    const tx = db.transaction("sceneHistory", "readwrite");
                    const store = tx.objectStore("sceneHistory");
                    await new Promise((resolve, reject) => {
                        const clearRequest = store.clear();
                        clearRequest.onsuccess = () => resolve();
                        clearRequest.onerror = (err) => reject(err);
                    });
                } catch (err) {
                    console.error("IndexedDBクリア失敗:", err);
                }
            }
            window.sceneHistory = [];
            await saveSceneHistoryToIndexedDB(window.sceneHistory);
        }

        localStorage.removeItem('currentScene');

        // シナリオも削除する
        localStorage.removeItem('scenario');
        window.scenario = '';

        window.sceneHistory = [];
        window.currentScene = 0;

        document.getElementById('story').textContent = '';
        document.getElementById('player-action').textContent = '';
        document.getElementById('player-input').value = '';
        document.getElementById('next-scene').style.display = 'none';
        document.getElementById('player-input').style.display = 'none';

        // 状態に応じたセクションの表示切替
        // ※ シナリオが削除されているので input-section を表示、game-section を非表示とする
        document.querySelector('.input-section').style.display = 'block';
        document.querySelector('.game-section').style.display = 'none';

        // 履歴とシナリオタイル再表示
        displayScenarioTile();
        updateSceneHistory();
    });
}--- 
partyCreate.js 
// partyCreate.js

// グローバル変数
window.partySelectionMode = false;    // パーティ側の選択モードフラグ
window.warehouseSelectionMode = false; // 倉庫側の選択モードフラグ

window.addEventListener("load", async function(){
    await initIndexedDB();
    const stored = await loadCharacterDataFromIndexedDB();
    if(stored) {
      window.characterData = stored;
    } else {
      window.characterData = [];
    }

    // パーティ表示
    renderParty();

    // 倉庫モーダル管理
    document.getElementById("show-warehouse-btn").addEventListener("click", () => {
      showWarehouseModal();
    });

    // 倉庫モーダルを閉じる
    document.getElementById("close-warehouse-btn").addEventListener("click", () => {
      document.getElementById("warehouse-modal").style.display = "none";
      // 倉庫側の選択をリセット
      warehouseSelectionMode = false;
      document.getElementById("toggle-warehouse-selection-mode-btn").textContent = "選択モード";
      document.getElementById("add-to-party-btn").style.display = "none";
      // 全カードの selected を外す
      const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
      selectedCards.forEach(el => el.classList.remove("selected"));
    });

    // 「選択モード（パーティ側）」ボタン
    document.getElementById("toggle-party-selection-mode-btn").addEventListener("click", () => {
      window.partySelectionMode = !window.partySelectionMode;
      const btn = document.getElementById("toggle-party-selection-mode-btn");
      if(partySelectionMode) {
        btn.textContent = "選択モード解除";
      } else {
        btn.textContent = "選択モード";
        // 解除時、選択を全リセット
        const selectedCards = document.querySelectorAll("#party-card-container .card.selected");
        selectedCards.forEach(el => el.classList.remove("selected"));
      }
      updatePartyMoveButtonVisibility();
    });

    // 「パーティ選択カードを倉庫に戻す」ボタン
    document.getElementById("move-selected-to-warehouse-btn").addEventListener("click", async () => {
      const selectedCards = document.querySelectorAll("#party-card-container .card.selected");
      if(selectedCards.length === 0) {
        alert("カードが選択されていません。");
        return;
      }
      selectedCards.forEach(el => {
        const cardId = el.getAttribute("data-id");
        const idx = window.characterData.findIndex(c => c.id === cardId);
        if(idx !== -1) {
          window.characterData[idx].group = "Warehouse";
        }
      });
      await saveCharacterDataToIndexedDB(window.characterData);
      // 選択解除 & 再描画
      selectedCards.forEach(el => el.classList.remove("selected"));
      renderParty();
      updatePartyMoveButtonVisibility();
    });

    // 「選択モード（倉庫側）」ボタン
    document.getElementById("toggle-warehouse-selection-mode-btn").addEventListener("click", () => {
      window.warehouseSelectionMode = !window.warehouseSelectionMode;
      const btn = document.getElementById("toggle-warehouse-selection-mode-btn");
      if(warehouseSelectionMode) {
        btn.textContent = "選択モード解除";
      } else {
        btn.textContent = "選択モード";
        // 解除時、選択を全リセット
        const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
        selectedCards.forEach(el => el.classList.remove("selected"));
      }
      updateWarehouseAddButtonVisibility();
    });

    // 「倉庫選択カードをパーティへ」ボタン
    document.getElementById("add-to-party-btn").addEventListener("click", async () => {
      const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
      if(selectedCards.length === 0) {
        alert("カードが選択されていません。");
        return;
      }
      selectedCards.forEach(el => {
        const cardId = el.getAttribute("data-id");
        const realIndex = window.characterData.findIndex(c => c.id === cardId);
        if(realIndex !== -1){
          window.characterData[realIndex].group = "Party";
        }
      });

      await saveCharacterDataToIndexedDB(window.characterData);
      // 選択解除
      selectedCards.forEach(el => el.classList.remove("selected"));
      // 倉庫再描画 & パーティ再描画
      showWarehouseModal();
      renderParty();
      updateWarehouseAddButtonVisibility();
    });

    // 戻るボタン
    document.getElementById("back-to-menu").addEventListener("click", () => {
      window.location.href = "index.html";
    });
});


/** パーティのカードを表示 */
function renderParty(){
  const partyContainer = document.getElementById("party-card-container");
  partyContainer.innerHTML = "";
  // group==="Party" のみ抽出
  const partyCards = window.characterData.filter(c => c.group === "Party");

  if(partyCards.length === 0){
    partyContainer.textContent = "パーティにカードがありません。";
    return;
  }

  partyCards.forEach((card) => {
    const cardEl = createPartyCardElement(card);
    partyContainer.appendChild(cardEl);
  });
}

/** パーティカード生成 */
function createPartyCardElement(card){
  const cardEl = document.createElement("div");
  cardEl.className = "card";
  cardEl.setAttribute("data-id", card.id);

  // クリック時の動作
  cardEl.addEventListener("click", (e) => {
    if(window.partySelectionMode) {
      e.stopPropagation();
      cardEl.classList.toggle("selected");
      updatePartyMoveButtonVisibility();
    } else {
      // 通常時はカードを反転
      cardEl.classList.toggle("flipped");
    }
  });

  const cardInner = document.createElement("div");
  cardInner.className = "card-inner";

  const cardFront = document.createElement("div");
  cardFront.className = "card-front";

  const bgStyle = card.backgroundcss
      .replace("background-image:", "")
      .replace("background", "")
      .trim();
  cardFront.style = "background-image:" + bgStyle;

  const rarityValue = (typeof card.rarity === "string") ? card.rarity.replace("★", "").trim() : "0";
  cardFront.innerHTML = `<div class='bezel rarity${rarityValue}'></div>`;

  const typeEl = document.createElement("div");
  typeEl.className = "card-type";
  typeEl.textContent = card.type || "不明";
  cardFront.appendChild(typeEl);

  const imageContainer = document.createElement("div");
  imageContainer.className = "card-image";
  if(card.imageData){
    const imageEl = document.createElement("img");
    imageEl.src = card.imageData;
    imageEl.alt = card.name;
    imageContainer.appendChild(imageEl);
  }
  cardFront.appendChild(imageContainer);

  const infoContainer = document.createElement("div");
  infoContainer.className = "card-info";

  const nameEl = document.createElement("p");
  nameEl.innerHTML = "<h3>" + DOMPurify.sanitize(card.name) + "</h3>";
  infoContainer.appendChild(nameEl);

  if (card.state) {
    const stateEl = document.createElement("p");
    stateEl.innerHTML = "<strong>状態：</strong>" + DOMPurify.sanitize(card.state);
    infoContainer.appendChild(stateEl);
  }
  const specialEl = document.createElement("p");
  specialEl.innerHTML = "<strong>特技：</strong>" + DOMPurify.sanitize(card.special);
  infoContainer.appendChild(specialEl);

  const captionEl = document.createElement("p");
  captionEl.innerHTML = "<span>" + DOMPurify.sanitize(card.caption) + "</span>";
  infoContainer.appendChild(captionEl);

  cardFront.appendChild(infoContainer);

  const cardBack = document.createElement("div");
  cardBack.className = "card-back";
  cardBack.innerHTML = `<strong>${DOMPurify.sanitize(card.type)}</strong>`;

  cardInner.appendChild(cardFront);
  cardInner.appendChild(cardBack);
  cardEl.appendChild(cardInner);

  return cardEl;
}

/** 倉庫モーダルを表示 */
function showWarehouseModal(){
  const modal = document.getElementById("warehouse-modal");
  modal.style.display = "flex";

  const warehouseContainer = document.getElementById("warehouse-card-container");
  warehouseContainer.innerHTML = "";

  // group==="Warehouse" のみ
  const warehouseCards = window.characterData.filter(c => c.group === "Warehouse");
  if(warehouseCards.length === 0) {
    warehouseContainer.textContent = "倉庫にカードがありません。";
    return;
  }

  warehouseCards.forEach((card) => {
    const cardEl = createWarehouseCardElement(card);
    warehouseContainer.appendChild(cardEl);
  });
  updateWarehouseAddButtonVisibility();
}

/** 倉庫カード生成 */
function createWarehouseCardElement(card){
  const cardEl = document.createElement("div");
  cardEl.className = "card";
  cardEl.setAttribute("data-id", card.id);

  // クリック時
  cardEl.addEventListener("click", (e) => {
    if(window.warehouseSelectionMode) {
      e.stopPropagation();
      cardEl.classList.toggle("selected");
      updateWarehouseAddButtonVisibility();
    } else {
      cardEl.classList.toggle("flipped");
    }
  });

  const cardInner = document.createElement("div");
  cardInner.className = "card-inner";

  const cardFront = document.createElement("div");
  cardFront.className = "card-front";
  const bgStyle = card.backgroundcss
      .replace("background-image:", "")
      .replace("background", "")
      .trim();
  cardFront.style = "background-image:" + bgStyle;

  const rarityValue = (typeof card.rarity === "string") ? card.rarity.replace("★", "").trim() : "0";
  cardFront.innerHTML = `<div class='bezel rarity${rarityValue}'></div>`;

  const typeEl = document.createElement("div");
  typeEl.className = "card-type";
  typeEl.textContent = card.type || "不明";
  cardFront.appendChild(typeEl);

  const imageContainer = document.createElement("div");
  imageContainer.className = "card-image";
  if(card.imageData){
    const imageEl = document.createElement("img");
    imageEl.src = card.imageData;
    imageEl.alt = card.name;
    imageContainer.appendChild(imageEl);
  }
  cardFront.appendChild(imageContainer);

  const infoContainer = document.createElement("div");
  infoContainer.className = "card-info";

  const nameEl = document.createElement("p");
  nameEl.innerHTML = "<h3>" + DOMPurify.sanitize(card.name) + "</h3>";
  infoContainer.appendChild(nameEl);

  if (card.state) {
    const stateEl = document.createElement("p");
    stateEl.innerHTML = "<strong>状態：</strong>" + DOMPurify.sanitize(card.state);
    infoContainer.appendChild(stateEl);
  }
  const specialEl = document.createElement("p");
  specialEl.innerHTML = "<strong>特技：</strong>" + DOMPurify.sanitize(card.special);
  infoContainer.appendChild(specialEl);

  const captionEl = document.createElement("p");
  captionEl.innerHTML = "<span>" + DOMPurify.sanitize(card.caption) + "</span>";
  infoContainer.appendChild(captionEl);

  cardFront.appendChild(infoContainer);

  const cardBack = document.createElement("div");
  cardBack.className = "card-back";
  cardBack.innerHTML = `<strong>${DOMPurify.sanitize(card.type)}</strong>`;

  cardInner.appendChild(cardFront);
  cardInner.appendChild(cardBack);
  cardEl.appendChild(cardInner);

  return cardEl;
}

/** パーティへ入れるボタンの表示・非表示制御（倉庫側） */
function updateWarehouseAddButtonVisibility(){
  const addBtn = document.getElementById("add-to-party-btn");
  if(!warehouseSelectionMode) {
    // 選択モードOFF時は非表示
    addBtn.style.display = "none";
    return;
  }
  // 選択モードON
  const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
  if(selectedCards.length > 0){
    addBtn.style.display = "inline-block";
  } else {
    addBtn.style.display = "none";
  }
}

/** 倉庫に戻すボタンの表示・非表示制御（パーティ側） */
function updatePartyMoveButtonVisibility(){
  const moveBtn = document.getElementById("move-selected-to-warehouse-btn");
  if(!partySelectionMode){
    moveBtn.style.display = "none";
    return;
  }
  const selectedCards = document.querySelectorAll("#party-card-container .card.selected");
  if(selectedCards.length > 0) {
    moveBtn.style.display = "inline-block";
  } else {
    moveBtn.style.display = "none";
  }
}
--- 
scenarioPage.js 
// scenarioPage.js
window.addEventListener("load", async () => {
    // 1. IndexedDB 初期化
    await initIndexedDB();
  
    // 2. もしwindow.characterDataが無ければ空配列を用意
    if (!window.characterData) {
      window.characterData = [];
    }
  
    // 3. IndexedDBからキャラクタ配列をロードし、上書き
    const stored = await loadCharacterDataFromIndexedDB();
    if (stored && stored.length > 0) {
      window.characterData = stored;
    }
  
    console.log(
      "scenarioPage.js: IndexedDB init & characterData loaded. length=",
      window.characterData.length
    );
  
    // --------------- 以下、画面のイベント設定 ---------------
    document.getElementById("back-to-menu").addEventListener("click", () => {
      window.location.href = "index.html";
    });
  
    const spoilerModal = document.getElementById("spoiler-modal");
    const spoilerButton = document.getElementById("spoiler-button");
    const closeSpoilerModalBtn = document.getElementById("close-spoiler-modal");
  
    spoilerButton.addEventListener("click", () => {
      spoilerModal.style.display = "flex";
    });
    closeSpoilerModalBtn.addEventListener("click", () => {
      spoilerModal.style.display = "none";
    });
  
    // 「カードを取得する」ボタン
    const getCardButton = document.getElementById("get-card-button");
    getCardButton.addEventListener("click", async () => {
      // シーン全文を要約
      const sceneSummary = await getLastSceneSummary();
  
      // GPTから取得したテキストをパース
      const lines = sceneSummary.split("\n");
      let onlyTitle = "", onlyType = "", addPrompt = "";
      lines.forEach((line) => {
        line = line.trim();
        if (line.startsWith("【名前】")) {
          onlyTitle = line.replace("【名前】", "").replace("：", "").trim();
        } else if (line.startsWith("【タイプ】")) {
          onlyType = line.replace("【タイプ】", "").replace("：", "").trim();
        } else if (line.startsWith("【外見】")) {
          addPrompt = line.replace("【外見】", "").replace("：", "").trim();
        }
      });
  
      alert(sceneSummary);
      // 実際には↓を有効にして倉庫へ送る:
      // await runGacha(1, addPrompt, onlyTitle, onlyType);
  
      alert("シーンで新たなカードを取得しました。\n『エレメント作成』画面のガチャBOXに追加されます。");
    });
  
    async function getLastSceneSummary() {
      // ① 最新シーンを取得
      const lastSceneEntry = [...window.sceneHistory]
        .reverse()
        .find((e) => e.type === "scene");
      if (!lastSceneEntry) return "シーンがありません。";
  
      const fullText = lastSceneEntry.content;
  
      // ② GPTに「短い要約を返して」とリクエスト
      const systemPrompt = `あなたは優秀なカード作成用プロンプト製造者です。以下のフォーマットでプロンプトを製造してください。
  【名前】：...
  【タイプ】：キャラクター、モンスター、アイテム、のいずれか
  【外見】：...
  `;
      const userPrompt = `
  以下のシナリオの1シーンから関連がありそうで見栄えがしそうなエレメントを1件だけ抜き出してください。
  エレメントは
  ・シーンに出現するキャラクター
  ・シーンに出現する武器
  ・シーンに出現するアイテム
  のいずれかです。
  ---
  ${fullText}
  ---
      `;
  
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${window.apiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4",
            messages: [
              { role: "system", content: systemPrompt },
              { role: "user", content: userPrompt }
            ]
          }),
        });
  
        const data = await response.json();
        if (data.error) throw new Error(data.error.message);
  
        return data.choices[0].message.content.trim();
      } catch (err) {
        console.error("要約取得失敗:", err);
        return "(要約失敗)";
      }
    }
  });
  --- 
scenarioWizard.js 
/********************************
 * scenarioWizard.js
 * 新しいシナリオ作成ウィザード
 ********************************/

let wizardData = {
    genre: "",
    scenarioType: "",          // "objective" or "exploration"
    clearCondition: "",        // 目的達成型ならChatGPTから取得
    scenarioSummary: ""        // 全体のシナリオ要約
  };
  
  window.addEventListener("load", async function(){
    await initIndexedDB();
    // ローカルに保存してたら読み込み（ユーザーが再度ウィザード画面に戻った場合）
    loadWizardDataFromLocalStorage();
  
    // イベント設定
    document.getElementById("generate-genre-button").addEventListener("click", onGenerateGenre);
    document.getElementById("type-objective-btn").addEventListener("click", onSelectScenarioTypeObjective);
    document.getElementById("type-exploration-btn").addEventListener("click", onSelectScenarioTypeExploration);
    document.getElementById("start-scenario-button").addEventListener("click", onStartScenario);
  
    document.getElementById("cancel-request-button").addEventListener("click", onCancelFetch);
  });
  
  /** ステップ1：ジャンル候補をChatGPTで生成 */
  async function onGenerateGenre(){
    const genreListDiv = document.getElementById("genre-list");
    genreListDiv.innerHTML = "";
    wizardData.genre = ""; //リセット
  
    const apiKey = localStorage.getItem("apiKey") || "";
    if(!apiKey){
      alert("APIキーが設定されていません。");
      return;
    }
  
    showLoadingModal(true);
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;
  
    try {
      // ChatGPT呼び出し
      const messages = [
        { role: "system", content: "あなたはTRPGのプロです。ジャンルを5つ提案してください。" },
        { role: "user", content: "SF, 中世ファンタジー, 現代など、TRPGに使いやすいジャンル候補を5つ、箇条書きで出してください。" }
      ];
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method:"POST",
        headers:{
          "Content-Type":"application/json",
          "Authorization":`Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model:"gpt-4",
          messages: messages,
          temperature: 0.7
        }),
        signal
      });
  
      const data = await response.json();
      if(data.error){
        throw new Error(data.error.message);
      }
  
      const content = data.choices[0].message.content;
      // 例: 「1. SF\n2. 中世ファンタジー\n3. ...」のように返ってくる想定
      const lines = content.split("\n").map(l=>l.trim()).filter(l=>l);
      // UIに表示
      lines.forEach(line=>{
        const btn = document.createElement("button");
        btn.textContent = line.replace(/^\d+\.\s*/, ""); // 「1. 」を除去
        btn.style.display = "block";
        btn.style.margin = "5px 0";
        btn.addEventListener("click", ()=>{
          wizardData.genre = btn.textContent;
          // 選択状態を視覚化
          const allButtons = genreListDiv.querySelectorAll("button");
          allButtons.forEach(b => b.style.backgroundColor = "");
          btn.style.backgroundColor = "#8BC34A";
          // 保存
          saveWizardDataToLocalStorage();
          // ステップ2へ進む
          document.getElementById("wizard-step1").style.display = "none";
          document.getElementById("wizard-step2").style.display = "block";
        });
        genreListDiv.appendChild(btn);
      });
    } catch(err) {
      if(err.name === "AbortError"){
        console.log("ジャンル生成キャンセル");
      } else {
        console.error(err);
        alert("ジャンル生成に失敗しました。: " + err.message);
      }
    } finally {
      showLoadingModal(false);
    }
  }
  
  /** キャンセル */
  function onCancelFetch(){
    if(window.currentRequestController){
      window.currentRequestController.abort();
    }
    showLoadingModal(false);
  }
  
  /** ステップ2：目的達成型を選択 */
  async function onSelectScenarioTypeObjective(){
    wizardData.scenarioType = "objective";
    wizardData.clearCondition = ""; // 取得前は空
    await generateScenarioSummaryAndClearCondition();
    // ステップ2終了→ステップ3
    document.getElementById("wizard-step2").style.display = "none";
    document.getElementById("wizard-step3").style.display = "block";
  }
  
  /** ステップ2：探索型を選択 */
  async function onSelectScenarioTypeExploration(){
    wizardData.scenarioType = "exploration";
    wizardData.clearCondition = ""; // 探索型なので不要
    await generateScenarioSummary();
    // ステップ2終了→ステップ3
    document.getElementById("wizard-step2").style.display = "none";
    document.getElementById("wizard-step3").style.display = "block";
  }
  
  /** ステップ3へ移行する際に、シナリオ要約をChatGPTから生成する (探索型) */
  async function generateScenarioSummary(){
    wizardData.scenarioSummary = "";
    saveWizardDataToLocalStorage();
  
    const apiKey = localStorage.getItem("apiKey") || "";
    if(!apiKey){
      alert("APIキーが設定されていません。");
      return;
    }
  
    showLoadingModal(true);
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;
  
    try {
      const prompt = `
  あなたはTRPG用のシナリオ作成に長けたアシスタントです。
  ジャンルは「${wizardData.genre}」、シナリオタイプは「探索型」です。
  探索型はストーリー内でエレメントを手に入れることができるようにしてください。
  ストーリーは短い概要だけでOKですが、プレイヤーキャラが興味を持ちそうな情報を盛り込んでください。
      `;
  
      const messages = [
        { role: "system", content: "あなたは優秀なTRPGシナリオメーカーです。" },
        { role: "user", content: prompt }
      ];
  
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method:"POST",
        headers:{
          "Content-Type":"application/json",
          "Authorization":`Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model:"gpt-4",
          messages,
          temperature:0.7
        }),
        signal
      });
      const data = await response.json();
      if(data.error){
        throw new Error(data.error.message);
      }
      const text = data.choices[0].message.content;
      wizardData.scenarioSummary = text;
    } catch(err){
      if(err.name === "AbortError"){
        console.log("探索型シナリオ生成キャンセル");
      } else {
        console.error(err);
        alert("探索型シナリオ生成に失敗:\n" + err.message);
      }
    } finally {
      showLoadingModal(false);
      saveWizardDataToLocalStorage();
      updateSummaryUI();
    }
  }
  
  /** ステップ3へ移行する際に、シナリオ要約とクリア条件をChatGPTから生成する (目的達成型) */
  async function generateScenarioSummaryAndClearCondition(){
    wizardData.scenarioSummary = "";
    wizardData.clearCondition = "";
    saveWizardDataToLocalStorage();
  
    const apiKey = localStorage.getItem("apiKey") || "";
    if(!apiKey){
      alert("APIキーが設定されていません。");
      return;
    }
  
    showLoadingModal(true);
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;
  
    try {
      const prompt = `
  あなたはTRPG用のシナリオ作成に長けたアシスタントです。
  ジャンルは「${wizardData.genre}」、シナリオタイプは「目的達成型」です。
  以下を生成してください：
  1. シナリオの概要（短め）。
  2. このシナリオのクリア条件（【クリア条件】という見出しで書いてください）。
     ただし、【クリア条件】の内容はプレイヤーに公開しません。
      `;
  
      const messages = [
        { role: "system", content: "あなたは優秀なTRPGシナリオメーカーです。" },
        { role: "user", content: prompt }
      ];
  
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method:"POST",
        headers:{
          "Content-Type":"application/json",
          "Authorization":`Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model:"gpt-4",
          messages,
          temperature:0.7
        }),
        signal
      });
      const data = await response.json();
      if(data.error){
        throw new Error(data.error.message);
      }
      const text = data.choices[0].message.content;
      // 例:「シナリオ概要: ...\n【クリア条件】...」など
      // クリア条件の部分だけ取り出す
      // 簡易的に split
      let clearConditionPart = "";
      let summaryPart = text;
      if(text.includes("【クリア条件】")){
        const arr = text.split("【クリア条件】");
        summaryPart = arr[0].trim();
        clearConditionPart = arr[1] ? arr[1].trim() : "";
      }
  
      wizardData.scenarioSummary = summaryPart;
      wizardData.clearCondition = clearConditionPart;
    } catch(err){
      if(err.name === "AbortError"){
        console.log("目的達成型シナリオ生成キャンセル");
      } else {
        console.error(err);
        alert("目的達成型シナリオ生成に失敗:\n" + err.message);
      }
    } finally {
      showLoadingModal(false);
      saveWizardDataToLocalStorage();
      updateSummaryUI();
    }
  }
  
  /** ステップ3：サマリ表示 */
  function updateSummaryUI(){
    const summaryDiv = document.getElementById("scenario-summary");
    const scenario = wizardData.scenarioSummary || "（シナリオ概要なし）";
    summaryDiv.textContent = scenario;
  }
  
  /** 「このシナリオで始める」ボタン */
  function onStartScenario(){
    // wizardDataを localStorage に保存 → scenario.html で読めるように
    saveWizardDataToLocalStorage();
    // シナリオ開始ページへ遷移
    window.location.href = "scenario.html?fromWizard=true";
  }
  
  /** LocalStorageへの保存 */
  function saveWizardDataToLocalStorage(){
    localStorage.setItem("wizardData", JSON.stringify(wizardData));
  }
  
  /** LocalStorageから読み込み */
  function loadWizardDataFromLocalStorage(){
    const dataStr = localStorage.getItem("wizardData");
    if(!dataStr) return;
    try {
      const obj = JSON.parse(dataStr);
      wizardData = obj;
    } catch(e){
      console.warn("wizardData parse失敗");
    }
  }
  
  /** ローディングモーダルの表示/非表示 */
  function showLoadingModal(show){
    const modal = document.getElementById("loading-modal");
    if(!modal) return;
    modal.style.display = show ? "flex" : "none";
  }
  --- 
scene.js 
/********************************
 * scene.js - シナリオ/シーン管理関連
 ********************************/

// グローバル変数
window.apiKey = '';
window.scenario = '';
window.currentScene = 0;
window.sceneHistory = [];
// 例: {type:'scene'|'action'|'image', sceneId?: string, content?:string, dataUrl?:string, prompt?:string}
window.currentRequestController = null;
window.cancelRequested = false;
window.editingImageEntry = null;

/** ユニークIDを生成 */
function generateUniqueId() {
  return Date.now() + '_' + Math.random().toString(36).slice(2, 9);
}

/** ゲーム開始 */
async function startGame() {
  window.scenario = document.getElementById('scenario-input').value.trim();
  if (!window.scenario) {
    alert('シナリオを入力してください');
    return;
  }
  localStorage.setItem('scenario', window.scenario);

  document.querySelector('.input-section').style.display = 'none';
  document.querySelector('.game-section').style.display = 'block';

  displayScenarioTile();
  await getNextScene();
}

/** シナリオタイルの表示 */
function displayScenarioTile() {
  const historyContainer = document.getElementById('scene-history');
  if (!historyContainer) return;

  let scenarioTile = document.getElementById('scenario-tile');
  if (!scenarioTile) {
    scenarioTile = document.createElement('div');
    scenarioTile.id = 'scenario-tile';
    scenarioTile.className = 'history-tile';
  } else {
    scenarioTile.innerHTML = '';
  }

  // シナリオ本文（contenteditable）
  const scenarioText = document.createElement('p');
  scenarioText.className = 'scenario-text';
  if (!window.apiKey) {
    scenarioText.removeAttribute('contenteditable');
  } else {
    scenarioText.setAttribute('contenteditable', 'true');
  }

  // 表示上は「（シナリオは未入力です）」をプレースホルダーに
  const displayText = (window.scenario && window.scenario.trim() !== '')
    ? window.scenario
    : '（シナリオは未入力です）';
  scenarioText.innerHTML = DOMPurify.sanitize(displayText);

  // 変更があったら保存
  scenarioText.addEventListener('blur', () => {
    if (!window.apiKey) return;
    const rawText = scenarioText.textContent.trim();

    if (!rawText || rawText === '（シナリオは未入力です）') {
      window.scenario = '';
      localStorage.removeItem('scenario');
    } else {
      window.scenario = rawText;
      localStorage.setItem('scenario', rawText);
    }

    showLastScene();
  });

  scenarioTile.appendChild(scenarioText);

  // 履歴コンテナを一旦クリアし、シナリオタイルを追加
  historyContainer.innerHTML = '';
  historyContainer.appendChild(scenarioTile);
}

/** 次のシーンを取得 */
async function getNextScene(){
  if(!window.apiKey){
    alert('APIキーが設定されていません。');
    return;
  }
  
  const playerInput = document.getElementById('player-input').value.trim();
  // シーンが既にある場合のみ、プレイヤー行動が未入力ならアラートを出す
  const hasScene = window.sceneHistory.some(e => e.type === 'scene');
  if(hasScene && !playerInput){
    alert('プレイヤーの行動を入力してください');
    return;
  }

  window.cancelRequested = false;
  showLoadingModal(true);

  const messages = [
    {role:'system', content:'あなたはTRPGのゲームマスターです。HTMLタグOK。'},
    {role:'user', content:`シナリオ概要:${window.scenario}`}
  ];

  // これまでのシーンとプレイヤー行動をすべて messages に詰める
  window.sceneHistory.forEach(e=>{
    if(e.type === 'scene'){
      messages.push({role:'assistant', content:e.content});
    } else if(e.type === 'action'){
      messages.push({role:'user', content:`プレイヤーの行動:${e.content}`});
    }
  });

  // 今回の新しい行動
  if(playerInput){
    messages.push({role:'user', content:`プレイヤーの行動:${playerInput}`});
    window.sceneHistory.push({ type:'action', content:playerInput });
  }

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'Authorization':`Bearer ${window.apiKey}`
      },
      body:JSON.stringify({
        model:'gpt-4',
        messages
      }),
      signal
    });
    if(window.cancelRequested){
      showLoadingModal(false);
      return;
    }
    const data = await response.json();
    if(window.cancelRequested){
      showLoadingModal(false);
      return;
    }
    if(data.error){
      throw new Error(data.error.message);
    }

    // 次のシーン内容
    const nextScene = data.choices[0].message.content;

    // ユニークIDを付与
    const newSceneId = generateUniqueId();
    window.sceneHistory.push({
      type: 'scene',
      sceneId: newSceneId,
      content: nextScene
    });
    window.currentScene++;

    // IndexedDB保存 & currentSceneはlocalStorageに保存
    await saveSceneHistoryToIndexedDB(window.sceneHistory);
    localStorage.setItem('currentScene', window.currentScene);

    // もしプレイヤー入力欄に入力があったならリセット
    if(playerInput){
      document.getElementById('player-input').value = '';
    }

    updateSceneHistory();
    showLastScene();
  } catch(error) {
    if(error.name === 'AbortError'){
      console.warn('シーン取得キャンセル');
    } else {
      console.error('シーン取得失敗:', error);
      alert('シーン取得に失敗:\n' + error.message);
    }
  } finally {
    showLoadingModal(false);
  }
}

/**
 * シーン履歴表示
 */
function updateSceneHistory() {
  const historyContainer = document.getElementById('scene-history');
  if (!historyContainer) return;

  // すでに作成していたシナリオタイルを復帰
  const scenarioTile = document.getElementById('scenario-tile');
  historyContainer.innerHTML = '';
  if (scenarioTile) {
    historyContainer.appendChild(scenarioTile);
  }

  // 最新シーンのIDを取得
  const latestScene = [...window.sceneHistory].reverse().find(e => e.type === 'scene');
  const latestSceneId = latestScene ? latestScene.sceneId : null;

  // 履歴を表示
  window.sceneHistory.forEach((entry, index) => {
    // APIキーがあれば「最新シーン」は除外してメイン表示へ回す
    if (window.apiKey) {
      if (entry.sceneId && entry.sceneId === latestSceneId) {
        return;
      }
    }

    if (entry.type === 'scene') {
      // シーン表示
      const tile = document.createElement('div');
      tile.className = 'history-tile';

      // シーン削除ボタン
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = '削除';
      deleteBtn.style.marginBottom = '5px';
      deleteBtn.addEventListener('click', async () => {
        if (!window.apiKey) return;
        // シーン + それに紐づく画像を削除
        const delId = entry.sceneId;
        window.sceneHistory = window.sceneHistory.filter(e => {
          if (e.type === 'scene' && e.sceneId === delId) return false;
          if (e.type === 'image' && e.sceneId === delId) return false;
          return true;
        });
        await saveSceneHistoryToIndexedDB(window.sceneHistory);
        updateSceneHistory();
        showLastScene();
      });
      tile.appendChild(deleteBtn);

      // シーン本文
      const sceneText = document.createElement('p');
      sceneText.className = 'scene-text';
      if (!window.apiKey) {
        sceneText.removeAttribute('contenteditable');
      } else {
        sceneText.setAttribute('contenteditable', 'true');
      }
      sceneText.innerHTML = DOMPurify.sanitize(entry.content);
      sceneText.addEventListener('blur', async () => {
        if (!window.apiKey) return;
        entry.content = sceneText.textContent.trim();
        await saveSceneHistoryToIndexedDB(window.sceneHistory);
      });
      tile.appendChild(sceneText);

      historyContainer.appendChild(tile);

    } else if (entry.type === 'action') {
      // プレイヤー行動
      const tile = document.createElement('div');
      tile.className = 'history-tile';

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = '削除';
      deleteBtn.style.marginBottom = '5px';
      deleteBtn.addEventListener('click', async () => {
        if (!window.apiKey) return;

        // 最新アクションなら、最新シーンも削除
        let lastActionIndex = -1;
        for (let i = window.sceneHistory.length - 1; i >= 0; i--) {
          if (window.sceneHistory[i].type === 'action') {
            lastActionIndex = i;
            break;
          }
        }
        if (index === lastActionIndex) {
          let lastSceneIndex = -1;
          for (let i = window.sceneHistory.length - 1; i >= 0; i--) {
            if (window.sceneHistory[i].type === 'scene') {
              lastSceneIndex = i;
              break;
            }
          }
          if (lastSceneIndex !== -1) {
            window.sceneHistory.splice(lastSceneIndex, 1);
          }
        }

        window.sceneHistory.splice(index, 1);
        await saveSceneHistoryToIndexedDB(window.sceneHistory);
        updateSceneHistory();
        showLastScene();
      });
      tile.appendChild(deleteBtn);

      const actionText = document.createElement('p');
      actionText.className = 'action-text';
      if (!window.apiKey) {
        actionText.removeAttribute('contenteditable');
      } else {
        actionText.setAttribute('contenteditable', 'true');
      }
      actionText.innerHTML = DOMPurify.sanitize(entry.content);
      actionText.addEventListener('blur', async () => {
        if (!window.apiKey) return;
        entry.content = actionText.textContent.trim();
        await saveSceneHistoryToIndexedDB(window.sceneHistory);
      });
      tile.appendChild(actionText);

      historyContainer.appendChild(tile);

    } else if (entry.type === 'image') {
      // 古いシーンの画像
      const tile = document.createElement('div');
      tile.className = 'history-tile';

      const img = document.createElement('img');
      img.src = entry.dataUrl;
      img.alt = '生成画像';
      img.style.maxWidth = '100%';
      tile.appendChild(img);

      // 画像再生成
      const regenBtn = document.createElement('button');
      regenBtn.textContent = '再生成';
      regenBtn.addEventListener('click', () => {
        if (!window.apiKey) return;
        const idxInHistory = window.sceneHistory.indexOf(entry);
        if (idxInHistory >= 0) {
          openImagePromptModal(entry.prompt, idxInHistory);
        }
      });
      tile.appendChild(regenBtn);

      // 画像削除
      const imgDeleteBtn = document.createElement('button');
      imgDeleteBtn.textContent = '画像だけ削除';
      imgDeleteBtn.addEventListener('click', async () => {
        if (!window.apiKey) return;
        const idxInHistory = window.sceneHistory.indexOf(entry);
        if (idxInHistory >= 0) {
          window.sceneHistory.splice(idxInHistory, 1);
          await saveSceneHistoryToIndexedDB(window.sceneHistory);
          updateSceneHistory();
          showLastScene();
        }
      });
      tile.appendChild(imgDeleteBtn);

      historyContainer.appendChild(tile);
    }
  });

  historyContainer.scrollTop = historyContainer.scrollHeight;
}

/** 最新のシーン(末尾) をメイン表示 (APIキーがある時のみ利用) */
function showLastScene() {
  const lastSceneEntry = [...window.sceneHistory].reverse().find(e => e.type === 'scene');
  const storyDiv = document.getElementById('story');
  const lastSceneImagesDiv = document.getElementById('last-scene-images');
  if (!storyDiv || !lastSceneImagesDiv) return;

  // APIキーがあるときはボタン類表示／非表示の処理も行う
  const nextSceneBtn = document.getElementById('next-scene');
  const playerInput = document.getElementById('player-input');
  const playerActionLabel = document.getElementById('player-action');

  // シーンが存在する場合
  if (lastSceneEntry) {
    const safeHTML = DOMPurify.sanitize(lastSceneEntry.content);
    storyDiv.innerHTML = safeHTML;

    lastSceneImagesDiv.innerHTML = '';

    // 最新シーンに紐づく画像を表示
    const sId = lastSceneEntry.sceneId;
    const images = window.sceneHistory.filter(e => e.type === 'image' && e.sceneId === sId);
    images.forEach(imgEntry => {
      const container = document.createElement('div');
      container.style.marginBottom = '10px';

      const img = document.createElement('img');
      img.src = imgEntry.dataUrl;
      img.alt = 'シーン画像';
      img.style.maxWidth = '100%';
      container.appendChild(img);

      // 再生成
      const regenBtn = document.createElement('button');
      regenBtn.textContent = '再生成';
      regenBtn.addEventListener('click', () => {
        if (!window.apiKey) return;
        const idxInHistory = window.sceneHistory.indexOf(imgEntry);
        if (idxInHistory >= 0) {
          openImagePromptModal(imgEntry.prompt, idxInHistory);
        }
      });
      container.appendChild(regenBtn);

      // 画像削除
      const imgDeleteBtn = document.createElement('button');
      imgDeleteBtn.textContent = '画像削除';
      imgDeleteBtn.addEventListener('click', async () => {
        if (!window.apiKey) return;
        const idxInHistory = window.sceneHistory.indexOf(imgEntry);
        if (idxInHistory >= 0) {
          window.sceneHistory.splice(idxInHistory, 1);
          await saveSceneHistoryToIndexedDB(window.sceneHistory);
          showLastScene();
          updateSceneHistory();
        }
      });
      container.appendChild(imgDeleteBtn);

      lastSceneImagesDiv.appendChild(container);
    });

    if (window.apiKey) {
      nextSceneBtn.style.display = 'inline-block';
      playerInput.style.display = 'inline-block';
      playerActionLabel.textContent = 'プレイヤーがどんな行動を取るか？';
    } else {
      nextSceneBtn.style.display = 'none';
      playerInput.style.display = 'none';
      playerActionLabel.textContent = '';
    }
  } else {
    // シーンがまだ無い場合
    storyDiv.innerHTML = '';
    lastSceneImagesDiv.innerHTML = '';
    nextSceneBtn.style.display = 'none';
    playerInput.style.display = 'none';
    playerActionLabel.textContent = '';

    // 「シーンを生成する」ボタンを追加
    let generateBtn = document.getElementById('generate-scene-button');
    if (!generateBtn) {
      generateBtn = document.createElement('button');
      generateBtn.id = 'generate-scene-button';
      generateBtn.textContent = 'シーンを生成する';
      generateBtn.addEventListener('click', () => {
        generateBtn.remove();
        getNextScene();
      });
      storyDiv.appendChild(generateBtn);
    }
  }
}

/** 次のシーン ボタン */
function nextScene() {
  getNextScene();
}

/** キャンセルボタン */
function onCancelFetch() {
  window.cancelRequested = true;
  if (window.currentRequestController) {
    window.currentRequestController.abort();
  }
  showLoadingModal(false);
}

/** ローディングモーダル表示/非表示 */
function showLoadingModal(show) {
  const modal = document.getElementById('loading-modal');
  if (!modal) return;
  modal.style.display = show ? 'flex' : 'none';
}
--- 
