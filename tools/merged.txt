貴方は会社の中で一番のエンジニアです。
・scenarioWizardにジャンル候補を作成するボタンがあるが、コストが高いので、辞める。
・代わりにcharacterCreate.htmlのジャンル選択方式を付けたい
・舞台、テーマ、雰囲気のそれぞれの選択肢の最後に「その他」を作成し、押下するとモーダルが表示される
- モーダルには生成ボタンとテキストボックスとOKボタンとキャンセルボタンを設置する
-- 生成ボタンを押下すると、舞台、テーマ、雰囲気で現在の選択肢にはない選択肢を生成。生成中は、いつものモーダルを出す。生成後、テキストボックスに書き出す。
-- OKボタンを押下するとモーダルは閉じ、舞台、テーマ、雰囲気のいずれかに新たな選択肢が追加される
--- この追加された選択肢は右に×が付いていて、選択肢が消えますが良いですか？というモーダルで確認した後に消すことが出来る。
--- この追加された選択肢はローカルストレージに保存しておき、次回のscenarioWizardでも用いる事ができる
--- この追加された選択肢はcharacterCreateでも用いる事ができる
---- characterCreateでも選択肢は右に×が付いていて、選択肢が消えますが良いですか？というモーダルで確認した後に消すことが出来る。
-- OKボタンを押下したときにテキストボックスに値が入っていない時は、何もせずモーダルを閉じる
-- キャンセルボタンを押下したときは、何もせずモーダルを閉じる
・舞台、テーマ、雰囲気のそれぞれの選択肢を押下すると、自由入力ジャンルのテキストボックスにテキストが入る
- テキストの形式は【舞台】XXX【テーマ】XXX【雰囲気】XXXとする
-- 仮に舞台、テーマ、雰囲気の中で選択が無い場合は、項目そのものを無くす
以上を実施し、編集しないファイルを除き完全なコードを下さい。
characterCreate.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>エレメント作成</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
</head>
<body>
    <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>
    <div class="container" style="max-width:800px;">
      <h1>エレメント作成</h1>
      <button id="gacha-btn" style="margin:10px;">エレメントガチャ</button>
      <button id="move-gacha-to-warehouse-btn" style="margin:10px;">ガチャ箱のカードを倉庫に入れる</button>
      <button id="toggle-selection-mode-btn" style="margin:10px;">選択モード</button>
      <button id="move-selected-to-warehouse-btn" style="display:none; margin:10px;">選択したものを倉庫に送る</button>

      <!-- ▼ ガチャ前確認モーダル -->
      <div id="gacha-confirm-modal" class="modal" style="display:none;">
        <div class="modal-content">
          <p>現在ガチャ箱に入っているカードは削除されます。よろしいですか？</p>
          <button id="gacha-confirm-ok">OK</button>
          <button id="gacha-confirm-cancel">キャンセル</button>
        </div>
      </div>

      <!-- ▼ ガチャ生成中モーダル -->
      <div id="gacha-modal" class="modal" style="display:none;">
        <div class="modal-content">
          <p>生成中...</p>
          <button id="cancel-gacha-btn">キャンセル</button>
        </div>
      </div>

      <!-- ▼ エレメントのジャンル設定モーダル -->
      <div id="element-genre-modal" class="modal" style="display:none;">
        <div class="modal-content" style="max-width:600px;">
          <h2>エレメントのジャンルを設定</h2>
          <p style="font-size: 0.9em; margin-bottom: 10px;">
            下記の軸を選択してください。<br>
            一度選択すると、ストレージに保存され次回以降も復元されます。
          </p>

          <!-- 舞台（複数可） -->
          <div style="margin-top:10px;">
            <strong>舞台（複数選択可）</strong><br>
            <div id="stage-chips-container" class="chips-container">
              <!-- 例：ファンタジー, SF, 歴史・時代劇... -->
            </div>
          </div>

          <!-- テーマ（単一・非表示） -->
          <!-- 画面には出さないが、チップ形式で実装して display:none; -->
          <div id="theme-chips-wrapper" style="display:none;">
            <strong>テーマ(非表示・単一)</strong><br>
            <div id="theme-chips-container" class="chips-container">
              <!-- 例：アクション, ミステリー, ロマンス... -->
            </div>
          </div>

          <!-- 雰囲気（単一） -->
          <div style="margin-top:10px;">
            <strong>雰囲気（単一選択）</strong><br>
            <div id="mood-chips-container" class="chips-container">
              <!-- 例：ライト/ポップ, 中間/バランス, ダーク/シリアス -->
            </div>
          </div>

          <div style="margin-top:20px;">
            <button id="genre-setting-ok-btn" style="margin-right:10px;">OK</button>
            <button id="genre-setting-cancel-btn">キャンセル</button>
          </div>
        </div>
      </div>

      <div id="card-container"></div>
    </div>

    <!-- IndexedDBなどの共通スクリプト -->
    <script src="js/indexedDB.js"></script>

    <!-- 先にgachaCore.jsを読み込む -->
    <script src="js/gachaCore.js"></script>

    <!-- その後、characterCreate.jsを読み込む -->
    <script src="js/characterCreate.js"></script>

    <script>
      // メニューに戻るボタン
      document.getElementById("back-to-menu").addEventListener("click", function () {
        window.location.href = "index.html";
      });
    </script>
</body>
</html>
--- 
index.html 
<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <title>TRPG メニュー</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />

  <!-- 追加：カード表示などでDOMPurifyを使用するため -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
</head>

<body>
  <div class="container" style="text-align:center; margin-top:50px;">
    <h1>TRPG メニュー</h1>
    <div class="api-key-section">
      <label for="api-key-input">ChatGPT APIキーを入力：</label>
      <input type="text" id="api-key-input" placeholder="APIキーを入力" />
      <button id="set-api-key-button">APIキー設定</button>
      <button id="clear-api-key-button" style="background-color:#f44336;">APIキーをクリア</button>
    </div>

    <div class="element-section">
      <!-- エレメント作成ボタン -->
      <button id="character-create">エレメント作成</button>
      <!-- パーティ作成ボタン -->
      <button id="party-create">パーティ作成</button>
      <!-- 全エレメントクリアボタン -->
      <button id="clear-character-btn" style="background-color:#f44336;">全エレメントをクリア</button>
      <!-- ★ 追加：倉庫確認ボタン -->
      <button id="show-warehouse-btn" style="margin-left:10px;">倉庫確認</button>
    </div>

    <!-- 新しいシナリオを始めるボタン -->
    <div class="scenario-wizard-section" style="margin-top:20px;">
      <button id="start-new-scenario-button" style="background-color:#2196F3;">
        新しいシナリオを始める
      </button>
    </div>

    <!-- 進行中のシナリオ一覧 -->
    <div id="ongoing-scenarios" style="margin-top:30px;">
      <h2>進行中のシナリオ</h2>
      <div id="active-scenarios-container">
        <!-- 進行中シナリオのリンクがここに表示されます（現在未使用） -->
      </div>
      <div id="scenario-list-container">
        <!-- JavaScriptで一覧表示 & 削除ボタンを付与 -->
      </div>
    </div>
  </div>

  <!-- ▼ シナリオ削除用の確認モーダル -->
  <div id="delete-scenario-modal" class="modal" style="display:none;">
    <div class="modal-content">
      <h3>シナリオ削除の確認</h3>
      <p>このシナリオを削除します。よろしいですか？</p>
      <button id="delete-scenario-ok">OK</button>
      <button id="delete-scenario-cancel">キャンセル</button>
    </div>
  </div>

  <!-- ★ 倉庫モーダル（新規追加） -->
  <div id="warehouse-modal" class="modal" style="display:none;">
    <div class="modal-content">
      <h2>倉庫</h2>
      <!-- 倉庫側の選択モードボタン -->
      <button id="toggle-warehouse-selection-mode-btn">選択モード</button>
      <!-- 倉庫選択カードを削除するボタン -->
      <button id="delete-selected-warehouse-btn" style="display:none; margin:10px;">選択したカードを削除</button>
      <button id="close-warehouse-btn" style="margin:10px;">閉じる</button>

      <div id="warehouse-card-container" style="margin:10px 0;"></div>
    </div>
  </div>

  <!-- 外部JavaScript -->
  <script src="js/indexedDB.js"></script>
  <script>
    // ページ読み込み完了後にDB初期化 -> menu.js を動的に読み込む
    window.addEventListener("load", async () => {
      await initIndexedDB();

      const scriptEl = document.createElement("script");
      scriptEl.src = "js/menu.js";
      document.head.appendChild(scriptEl);
    });
  </script>

  <script>
    // エレメント作成ボタン押下時
    document.getElementById("character-create").addEventListener("click", function () {
      window.location.href = "characterCreate.html";
    });
    // パーティ作成ボタン押下時
    document.getElementById("party-create").addEventListener("click", function () {
      window.location.href = "partyCreate.html";
    });
    // 新しいシナリオを始めるボタン押下時
    document.getElementById("start-new-scenario-button").addEventListener("click", function () {
      window.location.href = "scenarioWizard.html";
    });
  </script>

  <!-- サンプルのテストボタン（任意） -->
  <button id="sample-btn">hoge</button>
</body>

</html>
--- 
partyCreate.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>パーティ編成</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>パーティ編成</h1>
    <!-- 倉庫ボタン -->
    <button id="show-warehouse-btn">倉庫</button>

    <!-- パーティ側の選択モードボタン -->
    <button id="toggle-party-selection-mode-btn" style="margin-left:10px;">選択モード</button>
    <!-- 選択したカードを倉庫に戻すボタン -->
    <button id="move-selected-to-warehouse-btn" style="margin-left:10px; display:none;">選択したカードを倉庫に戻す</button>

    <!-- ▼ プレイヤーの分身（1つだけ選べる） -->
    <section style="margin-top:20px;">
      <h2>プレイヤーの分身（アバター）</h2>
      <p style="color:#555; font-size:14px;">
        ※ ここに配置できるのは1つだけ。複数設定された場合、自動で以前のアバター設定が解除されます。
      </p>
      <div id="avatar-card-container" style="display:grid; grid-template-columns:repeat(3,1fr); gap:20px;"></div>
    </section>

    <!-- ▼ パートナー（複数選べる） -->
    <section style="margin-top:20px;">
      <h2>パートナー（複数可）</h2>
      <div id="partner-card-container" style="display:grid; grid-template-columns:repeat(3,1fr); gap:20px;"></div>
    </section>

    <!-- ▼ その他パーティ枠（アバターでもパートナーでもないもの） -->
    <section style="margin-top:20px;">
      <h2>その他パーティ枠</h2>
      <div id="party-card-container" style="display:grid; grid-template-columns:repeat(3,1fr); gap:20px;"></div>
    </section>

    <!-- 倉庫モーダル -->
    <div id="warehouse-modal" class="modal" style="display:none;">
      <div class="modal-content">
        <h2>倉庫</h2>
        <!-- 選択モードボタン（倉庫側） -->
        <button id="toggle-warehouse-selection-mode-btn">選択モード</button>
        <!-- 倉庫選択カードをパーティに入れるボタン -->
        <button id="add-to-party-btn" style="display:none; margin:10px;">パーティに入れる</button>
        <button id="close-warehouse-btn" style="margin:10px;">閉じる</button>
        
        <div id="warehouse-card-container" style="margin:10px 0; display:grid; grid-template-columns:repeat(3,1fr); gap:20px;"></div>
      </div>
    </div>

    <!-- 戻るボタン -->
    <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>
  </div>

  <!-- スクリプト読み込み -->
  <script src="js/indexedDB.js"></script>
  <script src="js/partyCreate.js"></script>
</body>
</html>
--- 
scenario.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>シンプルTRPG</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
  <!-- 追加：内部的にZIP圧縮するためのpakoライブラリ -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
  <!-- メニューに戻るボタン -->
  <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>

  <!-- 目的達成型の場合のみ表示する「ネタバレ」ボタン -->
  <button id="spoiler-button" style="display:none; background-color:#E91E63; margin-top:20px; float:right;">
    ネタバレ
  </button>

  <!-- ネタバレ（クリア条件）表示モーダル -->
  <div id="spoiler-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:600px;">
      <h2>クリア条件</h2>
      <p id="clear-condition-text" style="white-space:pre-wrap;"></p>
      <button id="close-spoiler-modal">閉じる</button>
    </div>
  </div>

  <div class="container">
    <!-- ★ 追加: パーティーを確認ボタン (scene-historyより上に配置) -->
    <button id="show-party-button">パーティーを確認</button>

    <!-- シーン履歴 -->
    <div id="scene-history" class="scene-history"></div>

    <!-- ゲーム画面セクション -->
    <div class="game-section" style="display:none;">
      <div id="story" style="margin-bottom:20px;"></div>
      <div id="last-scene-images" style="margin-bottom:20px;"></div>
      <div>
        <button id="image-auto-generate-button">自動生成(現シーンから)</button>
        <button id="image-prompt-modal-button">編集して生成(カスタム)</button>
      </div>
      <div id="player-action" style="margin-top:20px;">プレイヤーの行動を入力してください</div>
      <div style="margin-top:10px;">
        <button id="generate-action-candidates-button">回答候補を生成</button>
      </div>
      <div id="action-candidates-container" style="margin-top:10px;"></div>
      <textarea id="player-input" rows="4" placeholder="プレイヤーの行動を入力..."></textarea>
      <button id="next-scene" style="display:none; margin-top:10px;">次のシーン</button>

      <!-- 探索型なら表示する「カードを取得する」ボタン -->
      <button id="get-card-button" style="display:none; margin-top:20px;">
        カードを取得する
      </button>
    </div>
  </div>

  <!-- ▼ 追加: 全セクションを閲覧ボタン -->
  <button id="view-all-sections-button" style="margin-top:20px;">全セクションを閲覧する</button>

  <!-- ▼ 追加: 全セクション表示モーダル -->
  <div id="all-sections-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:600px;">
      <h2>全セクション一覧</h2>
      <div id="all-sections-content" style="white-space:pre-wrap; text-align:left;"></div>
      <button id="close-all-sections-modal" style="margin-top:10px;">閉じる</button>
    </div>
  </div>

  <!-- ローディングモーダル -->
  <div id="loading-modal" class="modal" style="display:none;">
    <div class="modal-content">
      <p>応答を待っています...</p>
      <button id="cancel-request-button">キャンセル</button>
    </div>
  </div>

  <!-- カスタム画像生成モーダル -->
  <div id="image-prompt-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:400px;">
      <p>画像生成のプロンプトを編集してください</p>
      <textarea id="image-custom-prompt" rows="5" style="width:100%;"></textarea>
      <div style="margin-top:10px;">
        <button id="image-custom-generate-button">生成</button>
        <button id="image-custom-cancel-button">キャンセル</button>
      </div>
    </div>
  </div>

  <!-- カードプレビューモーダル -->
  <div id="card-preview-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:400px;">
      <h2>新しいカード</h2>
      <div id="preview-card-container"></div>

      <div style="margin-top:10px;">
        <button id="add-to-gachabox-button">ガチャ箱に追加</button>
        <button id="cancel-card-preview-button">キャンセル</button>
      </div>
    </div>
  </div>

  <!-- ★ 追加: パーティ表示用モーダル -->
  <div id="party-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:600px;">
      <h2>パーティ確認</h2>
      <button id="close-party-modal" style="margin:10px;">閉じる</button>
      <div id="party-modal-card-container" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(250px,1fr)); gap:20px;"></div>
    </div>
  </div>

  <!-- スクリプト群 -->
  <script src="js/indexedDB.js"></script>
  <script src="js/scene.js"></script>
  <script src="js/image.js"></script>
  <script src="js/main.js"></script>
  <script src="js/gachaCore.js"></script>
  <!-- ★ 修正：scenarioPage.js を最後に読み込む（改変版） -->
  <script src="js/scenarioPage.js"></script>
</body>

</html>
--- 
scenarioSections.html 
--- 
scenarioWizard.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>新しいシナリオ作成ウィザード</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <!-- 戻るボタン -->
  <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>

  <div class="container">
    <h1>シナリオ作成ウィザード</h1>

    <!-- ステップ1：ジャンル選択 -->
    <div id="wizard-step1" style="display:block;">
      <h2>ステップ1：ジャンルを選択してください</h2>
      <p>候補をChatGPTで生成します。</p>

      <!-- 生成した候補の表示領域 -->
      <div id="genre-list" style="margin-top:10px;"></div>

      <!-- 「ジャンル候補を作成」「ジャンルをクリア」ボタン群 -->
      <div style="margin-top:10px;">
        <button id="generate-genre-button">ジャンル候補を作成</button>
        <button id="clear-genre-button">候補クリア</button>
      </div>

      <!-- 自由入力用テキストボックス＋ジャンル確定ボタン -->
      <div style="margin-top:10px;">
        <input type="text" id="free-genre-input" placeholder="自由入力ジャンル..." />
        <button id="confirm-genre-button">ジャンル確定</button>
      </div>
    </div>

    <!-- ステップ2：シナリオタイプ -->
    <div id="wizard-step2" style="display:none;">
      <h2>ステップ2：シナリオタイプ</h2>

      <!-- 選択したジャンルの表示 -->
      <p>
        選択したジャンル：
        <span id="selected-genre-display" style="font-weight:bold; color:#2196F3;">（未選択）</span>
      </p>

      <!-- シナリオタイプのボタン -->
      <button id="type-objective-btn">目的達成型</button>
      <button id="type-exploration-btn">探索型</button>

      <!-- ステップ1に戻るボタン -->
      <div style="margin-top:10px;">
        <button id="back-to-step1-button">ステップ1に戻る</button>
      </div>

      <p style="margin-top:10px;">
        ※ 目的達成型では、<strong>クリア条件</strong>が密かに生成されます。<br />
        ※ 探索型では、シーン中で<span style="text-decoration:underline;">カード(エレメント)取得</span>が可能になります。
      </p>
    </div>

    <!-- ステップ3：最終確認(シナリオ要約表示) -->
    <div id="wizard-step3" style="display:none;">
      <h2>ステップ3：シナリオ要約</h2>
      <div id="scenario-summary" style="border:1px solid #ccc; padding:10px; margin-bottom:10px;"></div>

      <!-- ステップ2に戻るボタン -->
      <button id="back-to-step2-button" style="margin-right:10px;">ステップ2に戻る</button>
      <button id="start-scenario-button" style="background-color:#4CAF50;">このシナリオで始める</button>
    </div>
  </div>

  <!-- ChatGPT応答待ちモーダル -->
  <div id="loading-modal" class="modal" style="display:none;">
    <div class="modal-content">
      <p>応答を待っています...</p>
      <button id="cancel-request-button">キャンセル</button>
    </div>
  </div>

  <!-- シナリオ作成確認モーダル（ステップ2でタイプ選択時に出す） -->
  <div id="confirm-scenario-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:500px;">
      <h3>シナリオ生成の確認</h3>
      <p id="confirm-genre-type-text" style="white-space:pre-wrap;"></p>
      <p>これでシナリオを作成します。よろしいですか？</p>
      <div style="margin-top:10px;">
        <button id="confirm-scenario-ok">OK</button>
        <button id="confirm-scenario-cancel">キャンセル</button>
      </div>
    </div>
  </div>

  <!-- ★ pakoを先に読み込む -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

  <!-- IndexedDBなどの共通スクリプト -->
  <script src="js/indexedDB.js"></script>
  <!-- シナリオウィザード用スクリプト -->
  <script src="js/scenarioWizard.js"></script>

  <!-- 戻るボタン -->
  <script>
    document.getElementById("back-to-menu").addEventListener("click", function () {
      window.location.href = "index.html";
    });
  </script>
</body>
</html>
--- 
styles.css 
/* styles.css */

/* ベース */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f5f5f5;
}

.container {
  max-width: 1000px;
  margin: 20px auto;
  padding: 20px;
  background-color: #fff;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
  text-align: center;
}

h2 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

.api-key-section {
  margin-bottom: 20px;
}

input,
textarea {
  width: 100%;
  padding: 10px;
  font-size: 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

button {
  padding: 10px 20px;
  background-color: #4CAF50;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-bottom: 10px;
}

button:hover {
  background-color: #45a049;
}

/* シーン履歴 */
.scene-history {
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 10px;
  background-color: #f9f9f9;
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 20px;
}

.history-tile {
  padding: 10px;
  border: 1px solid #ccc;
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* テキスト編集領域 */
.scene-text,
.action-text,
.scenario-text {
  margin: 0;
  padding: 5px;
  font-size: 14px;
  border: 1px dashed transparent;
  cursor: text;
}

.scene-text[contenteditable]:focus,
.action-text[contenteditable]:focus,
.scenario-text[contenteditable]:focus {
  border: 1px dashed #4CAF50;
  outline: none;
}

/* メイン表示するシーン部分 */
#story {
  font-size: 1.4rem;
  padding-bottom: 10px;
  border-bottom: 1px solid #ccc;
  min-height: 60px;
}

/* モーダル */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.modal-content {
  box-sizing: border-box;
  width: calc(100% - 20px);
  background-color: #fff;
  padding: 20px 40px;
  border-radius: 5px;
  text-align: center;
  max-height: 90vh;
  overflow-y: auto;
}


/* --- styles.css --- */

/* 既存の共通部分はそのままで */

/* カードコンテナをCSS Gridに変更 */
#card-container {
  display: grid;
  gap: 20px;
  /* 1列(スマホ)～3列(PC)になるようにレスポンシブに設定 */
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

/* カードコンテナの共通設定 */
.card {
  /* 横幅はセル幅に合わせる */
  width: 100%;
  /* ブラウザ対応の場合、aspect-ratioプロパティで比率を指定 */
  aspect-ratio: 63 / 88;
  perspective: 1000px;
  /* 3D効果用 */
  cursor: pointer;
  transition: transform 0.3s ease;
  position: relative;
}

/* マウスオーバー時に少し大きく */
.card:hover {
  transform: scale(1.05);
}

/* 内部要素 */
.card-inner {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 0.6s;
}

/* クリックで反転 */
.card.flipped .card-inner {
  transform: rotateY(180deg);
}

/* 表面 */
.card-front,
.card-back {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 15px;
  backface-visibility: hidden;
  box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2);
}

.card-front {
  box-sizing: border-box;
  padding: 3%;
  border-radius: 3%;
}

/* 表面のスタイル */
.card-front {
  background-color: #fff;
  display: flex;
  flex-direction: column;
  position: relative;
}

.card-front h3 {
  padding: 0;
  margin: 0;
  font-size: 1rem;
}

/* 左上にタイプ表示用 */
.card-front .card-type {
  position: absolute;
  right: 10px;
  background-color: rgba(255, 255, 255, 0.8);
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: bold;
  font-size: 0.85rem;
  z-index: 2;
}

/* 画像エリア */
.card-front .card-image {
  width: 100%;
  height: 40%;
  background: linear-gradient(135deg, #cccccc70, #eeeeee70);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

/* 画像エリア内の実際の画像 */
.card-front .card-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: top;
}

/* 画像生成ボタン（画像が無い場合のみ表示） */
.card-front .gen-image-btn {
  position: absolute;
  bottom: 8px;
  right: 8px;
  padding: 4px 8px;
  background-color: rgba(0, 0, 0, 0.6);
  color: #fff;
  border: none;
  border-radius: 4px;
  font-size: 0.8rem;
  z-index: 2;
}

/* 例：画像生成ボタン(.gen-image-btn)が disable 時 */
.gen-image-btn:disabled {
  background-color: #999;    /* 背景色をやや暗めに */
  color: #ccc;               /* 文字色も薄く */
  cursor: not-allowed;       /* カーソルを禁止マークに */
  opacity: 0.6;             /* 全体的に薄く */
}


/* 下部テキスト情報 */
.card-front .card-info {
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  flex-grow: 1;
  overflow: auto;
  background-color: rgba(255, 255, 255, 0.7);
}

.card-front .card-info p {
  margin: 0;
  font-size: 0.85rem;
}

.card-front .card-info p:last-child {
  padding: 0;
  height: 100%;
  font-size: 0.85rem;
  align-items: center;
  display: flex;
  background-color: #EEE;
  margin-top: 10px;
}

.card-front .card-info p:last-child span {
  transform: skew(-5deg);
  display: flex;
  padding: 10px;
}

/* 裏面：かっこよさげな背景 */
.card-back {
  box-sizing: border-box;
  background: linear-gradient(135deg, #1e3c72, #2a5298);
  color: #fff;
  transform: rotateY(180deg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  padding: 10px;
  text-align: center;
}

/* レスポンシブ */
@media (max-width: 600px) {
  #card-container {
    grid-template-columns: repeat(1, 1fr);
  }
}

.bezel {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  z-index: 100;
  border-radius: 2%;
  padding: 3%;
}

.bezel.rarity0 {
  background: linear-gradient(145deg, #C0C0C0, #D3D3D3, #E0E0E0, #A9A9A9);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity1 {
  background: linear-gradient(145deg, #B87333, #DA8A67, #E97451, #C35817);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity2 {
  background: linear-gradient(145deg, #C0C0C0, #D3D3D3, #E0E0E0, #A9A9A9);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity3 {
  background: linear-gradient(145deg, #b69a00, #ffda64, #ffda6b, #d79000);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

/* レアリティ4: プラチナ */
.bezel.rarity4 {
  position: absolute;
  background: linear-gradient(145deg, #d1d1d1, #aeb9ff, #C0C0C0, #ECEBE8);
  background-size: 400% 400%;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: platinum-shimmer 5s ease-in-out infinite;
}

/* レアリティ5: 宝石 */
.bezel.rarity5 {
  background: linear-gradient(145deg, #4B0082, #0000CD, #008080, #fff);
  background-size: 150% 150%;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: jewel-glow 5s ease-in-out infinite;
}

@keyframes platinum-shimmer {
  0% {
    background-position: 0% 50%;
  }

  50% {
    background-position: 100% 50%;
  }

  100% {
    background-position: 0% 50%;
  }
}

@keyframes jewel-glow {
  0% {
    filter: brightness(1);
    background-position: 0% 50%;
  }

  50% {
    filter: brightness(1.2);
    background-position: 100% 50%;
  }

  100% {
    filter: brightness(1);
    background-position: 0% 50%;
  }
}

/* partyCreate.htmlのカードを3列に */
#party-card-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
}

/* 倉庫モーダル内のカードも3列に */
#warehouse-card-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
}

/* 選択状態 */
.card.selected {
  outline: 4px solid #f44336;
  outline-offset: -4px;
  transform: scale(1.05);
  box-shadow: 0 0 10px rgba(244, 67, 54, 0.6);
}

/* ベース */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f5f5f5;
}

.container {
  max-width: 1000px;
  margin: 20px auto;
  padding: 20px;
  background-color: #fff;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
  text-align: center;
}

h2 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

.api-key-section {
  margin-bottom: 20px;
}

input,
textarea {
  width: 100%;
  padding: 10px;
  font-size: 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

button {
  padding: 10px 20px;
  background-color: #4CAF50;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-bottom: 10px;
}

button:hover {
  background-color: #45a049;
}

/* シーン履歴 */
.scene-history {
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 10px;
  background-color: #f9f9f9;
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 20px;
}

.history-tile {
  padding: 10px;
  border: 1px solid #ccc;
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* scene, actionテキスト */
.scene-text,
.action-text {
  margin: 0;
  padding: 5px;
  font-size: 14px;
  border: 1px dashed transparent;
  cursor: text;
}

.scene-text[contenteditable]:focus,
.action-text[contenteditable]:focus {
  border: 1px dashed #4CAF50;
  outline: none;
}

/* メイン表示するシーン部分 */
#story {
  font-size: 1.4rem;
  padding-bottom: 10px;
  border-bottom: 1px solid #ccc;
  min-height: 60px;
}

/* モーダル */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.modal-content {
  box-sizing: border-box;
  width: calc(100% - 20px);
  background-color: #fff;
  padding: 20px 40px;
  border-radius: 5px;
  text-align: center;
  max-height: 90vh;
  overflow-y: auto;
}

.chips-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.chip {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  border-radius: 20px;
  background-color: #e0e0e0;
  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s;
}

.chip:hover {
  background-color: #cfcfcf;
}

.chip.selected {
  background-color: #8BC34A;
  color: #fff;
}
--- 
backToMenu.js 
document.getElementById("back-to-menu").addEventListener("click", function () {
    window.location.href = "index.html";
});
--- 
characterCreate.js 
// characterCreate.js

// トースト表示用の簡易関数
function showToast(message) {
    const oldToast = document.getElementById("toast-message");
    if (oldToast) {
        oldToast.remove();
    }

    const toast = document.createElement("div");
    toast.id = "toast-message";
    toast.textContent = message;

    toast.style.position = "fixed";
    toast.style.bottom = "20px";
    toast.style.left = "50%";
    toast.style.transform = "translateX(-50%)";
    toast.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    toast.style.color = "#fff";
    toast.style.padding = "10px 20px";
    toast.style.borderRadius = "4px";
    toast.style.fontSize = "14px";
    toast.style.zIndex = "9999";
    toast.style.opacity = "0";
    toast.style.transition = "opacity 0.3s ease";

    document.body.appendChild(toast);

    requestAnimationFrame(() => {
        toast.style.opacity = "1";
    });

    setTimeout(() => {
        toast.style.opacity = "0";
        toast.addEventListener("transitionend", () => {
            toast.remove();
        });
    }, 3000);
}

// グローバル変数
window.apiKey = localStorage.getItem("apiKey") || "";
window.characterData = [];
let isSelectionMode = false;  // 選択モードフラグ

// 「舞台」は複数 => 配列にする
// 「テーマ」は単一だが非表示 => 文字列1つ
// 「雰囲気」は単一 => 文字列1つ
let storedStageArr = [];  // 舞台の配列
let storedTheme = "";     // テーマ(非表示)
let storedMood = "";      // 雰囲気(単一)

window.addEventListener("load", async function () {
    // 1) IndexedDB初期化 & キャラデータロード
    await initIndexedDB();
    const storedChars = await loadCharacterDataFromIndexedDB();
    if (storedChars) {
        window.characterData = storedChars;
    }
    displayCharacterCards(window.characterData);

    // 2) localStorage から読み込み
    // 舞台は配列を JSON文字列 で保存している想定
    const stageJson = localStorage.getItem("elementStageArr");
    if (stageJson) {
      try {
        storedStageArr = JSON.parse(stageJson);
      } catch(e) {
        storedStageArr = [];
      }
    } else {
      storedStageArr = []; // 初期状態
    }
    storedTheme = localStorage.getItem("elementTheme") || "アクション / 冒険"; 
    storedMood  = localStorage.getItem("elementMood")  || "ライト / ポップ";

    // 3) UIイベント登録
    document.getElementById("gacha-btn").addEventListener("click", onGachaButton);
    document.getElementById("move-gacha-to-warehouse-btn").addEventListener("click", onMoveGachaToWarehouse);
    document.getElementById("toggle-selection-mode-btn").addEventListener("click", toggleSelectionMode);
    document.getElementById("move-selected-to-warehouse-btn").addEventListener("click", moveSelectedCardsToWarehouse);

    // モーダルのOK/Cancel
    document.getElementById("genre-setting-ok-btn").addEventListener("click", onGenreSettingOk);
    document.getElementById("genre-setting-cancel-btn").addEventListener("click", onGenreSettingCancel);

    // 4) 舞台/テーマ/雰囲気 用のチップを生成
    initStageChips();
    initThemeChips(); // 非表示だけど初期化
    initMoodChips();
});

/** 「舞台」チップを生成 (複数選択可) */
function initStageChips() {
    const stageCandidates = [
      "ファンタジー", "SF", "歴史・時代劇", "現代", "ホラー / ダーク"
    ];
    const container = document.getElementById("stage-chips-container");
    container.innerHTML = "";  // クリア

    stageCandidates.forEach(label => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.textContent = label;
      // 既に storedStageArr に含まれていれば selected表示
      if (storedStageArr.includes(label)) {
        chip.classList.add("selected");
      }
      chip.addEventListener("click", () => {
        // toggle
        if (chip.classList.contains("selected")) {
          chip.classList.remove("selected");
          // 配列から削除
          storedStageArr = storedStageArr.filter(x => x !== label);
        } else {
          chip.classList.add("selected");
          // 配列に追加
          storedStageArr.push(label);
        }
      });
      container.appendChild(chip);
    });
}

/** 「テーマ」チップを生成 (単一選択, ただしUIは非表示) */
function initThemeChips() {
    const themeCandidates = [
      "アクション / 冒険",
      "ミステリー / サスペンス",
      "ロマンス / ドラマ",
      "コメディ / ほのぼの",
      "ホラー / スリラー"
    ];
    const container = document.getElementById("theme-chips-container");
    container.innerHTML = "";

    themeCandidates.forEach(label => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.textContent = label;

      if (storedTheme === label) {
        chip.classList.add("selected");
      }
      // 単一なので、クリックされたら他を解除
      chip.addEventListener("click", () => {
        // いったん全部クリア
        const allChips = container.querySelectorAll(".chip");
        allChips.forEach(c => c.classList.remove("selected"));
        // 自分だけON
        chip.classList.add("selected");
        storedTheme = label;
      });
      container.appendChild(chip);
    });
}

/** 「雰囲気」チップを生成 (単一選択) */
function initMoodChips() {
    const moodCandidates = [
      "ライト / ポップ",
      "中間 / バランス型",
      "ダーク / シリアス"
    ];
    const container = document.getElementById("mood-chips-container");
    container.innerHTML = "";

    moodCandidates.forEach(label => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.textContent = label;

      if (storedMood === label) {
        chip.classList.add("selected");
      }
      // 単一なので、クリックされたら他を解除
      chip.addEventListener("click", () => {
        const allChips = container.querySelectorAll(".chip");
        allChips.forEach(c => c.classList.remove("selected"));
        chip.classList.add("selected");
        storedMood = label;
      });
      container.appendChild(chip);
    });
}

/** ガチャボタン押下時 → 3軸モーダルを開く */
function onGachaButton() {
    openGenreModal();
}

/** 3軸モーダルを開く */
function openGenreModal() {
    // 一度、現在のチップ状態を反映(念のため再描画)
    initStageChips();
    initThemeChips();
    initMoodChips();

    document.getElementById("element-genre-modal").style.display = "flex";
}

/** 3軸モーダル: OK */
function onGenreSettingOk() {
    // 1) 現在の舞台（複数）を localStorage に JSON保存
    localStorage.setItem("elementStageArr", JSON.stringify(storedStageArr));
    // 2) テーマ/雰囲気も保存
    localStorage.setItem("elementTheme", storedTheme);
    localStorage.setItem("elementMood", storedMood);

    // モーダル閉じる
    document.getElementById("element-genre-modal").style.display = "none";

    // ガチャ確認モーダルを開く
    const confirmModal = document.getElementById("gacha-confirm-modal");
    confirmModal.style.display = "flex";

    const okBtn = document.getElementById("gacha-confirm-ok");
    const cancelBtn = document.getElementById("gacha-confirm-cancel");

    okBtn.onclick = async () => {
        confirmModal.style.display = "none";
        clearGachaBox();

        // プロンプト組み立て
        // 舞台が複数の場合、つなげて表現する or 箇条書きにする
        // 例："ファンタジー / SF / 現代" など
        let stageLine = "";
        if (storedStageArr.length > 0) {
          stageLine = "【舞台】" + storedStageArr.join(" / ");
        }

        let themeLine = "";
        if (storedTheme) {
          themeLine = "【テーマ】" + storedTheme;
        }

        let moodLine = "";
        if (storedMood) {
          moodLine = "【雰囲気】" + storedMood;
        }

        const lines = [];
        if (stageLine) lines.push(stageLine);
        if (themeLine) lines.push(themeLine);
        if (moodLine)  lines.push(moodLine);

        const axisPrompt = lines.join("\n");

        // ガチャ実行
        document.getElementById("gacha-modal").style.display = "flex";
        await runGacha(10, axisPrompt);
        hideGachaModal();

        displayCharacterCards(window.characterData);
    };

    cancelBtn.onclick = () => {
        confirmModal.style.display = "none";
    };
}

/** 3軸モーダル: キャンセル */
function onGenreSettingCancel() {
    document.getElementById("element-genre-modal").style.display = "none";
}


/** ガチャ箱クリア */
function clearGachaBox() {
    window.characterData = window.characterData.filter(card => card.group !== "GachaBox");
}

/** ガチャモーダルを隠す */
function hideGachaModal() {
    const m = document.getElementById("gacha-modal");
    if (m) m.style.display = "none";
}

/** ガチャ箱のカードを倉庫へ */
async function onMoveGachaToWarehouse() {
    let changed = false;
    window.characterData.forEach(card => {
        if (card.group === "GachaBox") {
            card.group = "Warehouse";
            changed = true;
        }
    });
    if (changed) {
        await saveCharacterDataToIndexedDB(window.characterData);
        displayCharacterCards(window.characterData);
        alert("ガチャ箱のカードを倉庫に移動しました。");
    } else {
        alert("ガチャ箱にカードがありません。");
    }
}

/** エレメント一覧の表示 */
function displayCharacterCards(characters) {
    const container = document.getElementById("card-container");
    if (!container) return;

    container.innerHTML = "";
    const visibleCards = characters.filter(
        card => card.group !== "Warehouse" && card.group !== "Party"
    );
    if (visibleCards.length === 0) {
        container.textContent = "エレメントが生成されていません。";
        return;
    }
    visibleCards.forEach((ch) => {
        const realIndex = window.characterData.findIndex(c => c.id === ch.id);
        const cardEl = createCardElement(ch, realIndex);
        container.appendChild(cardEl);
    });
}

/** カードDOM生成 */
function createCardElement(char, index) {
    const card = document.createElement("div");
    card.className = "card";
    card.setAttribute("data-id", char.id);

    card.addEventListener("click", (e) => {
        if (isSelectionMode) {
            e.stopPropagation();
            card.classList.toggle("selected");
            updateMoveSelectedButtonVisibility();
        } else {
            card.classList.toggle("flipped");
        }
    });

    const cardInner = document.createElement("div");
    cardInner.className = "card-inner";

    const cardFront = document.createElement("div");
    cardFront.className = "card-front";
    const bgStyle = (char.backgroundcss || "")
        .replace("background-image:", "")
        .replace("background", "")
        .trim();
    cardFront.style = "background-image:" + bgStyle;

    // レア度
    const rarityValue = (typeof char.rarity === "string") ? char.rarity.replace("★", "").trim() : "0";
    cardFront.innerHTML = `<div class='bezel rarity${rarityValue}'></div>`;

    // タイプ表示
    const typeEl = document.createElement("div");
    typeEl.className = "card-type";
    typeEl.textContent = char.type || "不明";
    cardFront.appendChild(typeEl);

    // 画像
    const imageContainer = document.createElement("div");
    imageContainer.className = "card-image";
    if (char.imageData) {
        // すでに画像がある
        const imageEl = document.createElement("img");
        imageEl.src = char.imageData;
        imageEl.alt = char.name;
        imageContainer.appendChild(imageEl);
    } else {
        // 画像が無い → 生成ボタン
        const genImgBtn = document.createElement("button");
        genImgBtn.setAttribute("data-imageprompt", char.imageprompt);
        genImgBtn.className = "gen-image-btn";
        genImgBtn.textContent = "画像生成";

        genImgBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            generateCharacterImage(char, index, genImgBtn);
        });
        imageContainer.appendChild(genImgBtn);
    }
    cardFront.appendChild(imageContainer);

    // 情報
    const infoContainer = document.createElement("div");
    infoContainer.className = "card-info";

    const nameEl = document.createElement("p");
    nameEl.innerHTML = "<h3>" + DOMPurify.sanitize(char.name) + "</h3>";
    infoContainer.appendChild(nameEl);

    if (char.state) {
        const stateEl = document.createElement("p");
        stateEl.innerHTML = "<strong>状態：</strong>" + DOMPurify.sanitize(char.state);
        infoContainer.appendChild(stateEl);
    }
    const specialEl = document.createElement("p");
    specialEl.innerHTML = "<strong>特技：</strong>" + DOMPurify.sanitize(char.special);
    infoContainer.appendChild(specialEl);

    const captionEl = document.createElement("p");
    captionEl.innerHTML = "<span>" + DOMPurify.sanitize(char.caption) + "</span>";
    infoContainer.appendChild(captionEl);

    cardFront.appendChild(infoContainer);

    // 裏面
    const cardBack = document.createElement("div");
    cardBack.className = "card-back";
    cardBack.innerHTML = `<strong>${DOMPurify.sanitize(char.type)}</strong>`;

    cardInner.appendChild(cardFront);
    cardInner.appendChild(cardBack);
    card.appendChild(cardInner);

    return card;
}

/** 画像生成 */
async function generateCharacterImage(char, index, btnElement) {
    if (!window.apiKey) {
        alert("APIキーが設定されていません。");
        return;
    }
    // ボタンを無効化
    if (btnElement) {
        btnElement.disabled = true;
    }
    showToast("画像を生成しています...");

    const promptText =
        "As a high-performance chatbot, you create the highest quality illustrations discreetly." +
        "Please do not include text in illustrations for any reason." +
        "If you can do that, I'll give you a super high tip." +
        "Now generate the next anime wide image.\n↓↓↓↓↓↓\n" +
        char.imageprompt;

    try {
        const response = await fetch("https://api.openai.com/v1/images/generations", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${window.apiKey}`,
            },
            body: JSON.stringify({
                model: "dall-e-3",
                prompt: promptText,
                n: 1,
                size: "1792x1024",
                response_format: "b64_json",
            }),
        });
        const data = await response.json();
        if (data.error) {
            throw new Error(data.error.message);
        }
        const base64 = data.data[0].b64_json;
        const dataUrl = "data:image/png;base64," + base64;
        window.characterData[index].imageData = dataUrl;
        await saveCharacterDataToIndexedDB(window.characterData);

        showToast("画像の生成が完了しました");
        displayCharacterCards(window.characterData);

    } catch (err) {
        console.error("画像生成失敗:", err);
        showToast("画像生成に失敗しました:\n" + err.message);
    } finally {
        if (btnElement) {
            btnElement.disabled = false;
        }
    }
}


/* ===== 選択モード関連 ===== */

function toggleSelectionMode() {
    isSelectionMode = !isSelectionMode;
    const btn = document.getElementById("toggle-selection-mode-btn");
    if (isSelectionMode) {
        btn.textContent = "選択モード解除";
    } else {
        btn.textContent = "選択モード";
        const selectedCards = document.querySelectorAll("#card-container .card.selected");
        selectedCards.forEach(card => card.classList.remove("selected"));
    }
    updateMoveSelectedButtonVisibility();
}

function updateMoveSelectedButtonVisibility() {
    const selectedCards = document.querySelectorAll("#card-container .card.selected");
    const moveBtn = document.getElementById("move-selected-to-warehouse-btn");
    if (!moveBtn) return;
    if (isSelectionMode && selectedCards.length > 0) {
        moveBtn.style.display = "inline-block";
    } else {
        moveBtn.style.display = "none";
    }
}

async function moveSelectedCardsToWarehouse() {
    const selectedCards = document.querySelectorAll("#card-container .card.selected");
    if (selectedCards.length === 0) {
        alert("カードが選択されていません。");
        return;
    }
    selectedCards.forEach(el => {
        const cardId = el.getAttribute("data-id");
        const realIndex = window.characterData.findIndex(c => c.id === cardId);
        if (realIndex !== -1) {
            window.characterData[realIndex].group = "Warehouse";
        }
    });
    await saveCharacterDataToIndexedDB(window.characterData);
    selectedCards.forEach(card => card.classList.remove("selected"));
    displayCharacterCards(window.characterData);
    updateMoveSelectedButtonVisibility();
}
--- 
gachaCore.js 
// gachaCore.js
// ------------------------------------------
// 「ガチャ処理」のロジックだけを集めたファイル
// ------------------------------------------

// グローバルに必要な変数 (characterData, apiKey など) は
// すでに window に存在すると仮定 (indexedDB や parse等も)


// --------------------------------------------------------
// 1. runGacha(cardCount, addPrompt, onlyTitle = "")
//
//   - 指定枚数のエレメントをChatGPTで生成し、window.characterDataに加える
//   - UI操作は行わず、コンソールに進捗をログ出力するだけ
// --------------------------------------------------------
async function runGacha(cardCount, addPrompt, onlyTitle = "", onlyType = "") {
  console.log("=== runGacha START ===");
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  // キャンセル用コントローラ
  window.currentGachaController = new AbortController();
  const signal = window.currentGachaController.signal;

  // レア度をランダムで決定
  const rarities = pickRaritiesForNCards(cardCount);
  const countMap = makeRarityCountMap(rarities);

  // systemプロンプト
  let systemContent = `
  あなたはTRPG用のキャラクター、装備品、モンスター作成のエキスパートです。
  以下の6段階のレア度「★0～★5」のうち、
  今回の${cardCount}件では以下の内訳を厳密に守って生成してください：
  - ★0: ${countMap["★0"]}件
  - ★1: ${countMap["★1"]}件
  - ★2: ${countMap["★2"]}件
  - ★3: ${countMap["★3"]}件
  - ★4: ${countMap["★4"]}件
  - ★5: ${countMap["★5"]}件
  
  生成するのがキャラクターやモンスターの場合
  【レア度】：...
  【名前】：...
  【タイプ】：キャラクターまたはモンスター
  【状態】：...
  【特技】：...
  【キャプション】：...
  【カード背景】：...
  【外見】：...
  
  生成するのがアイテムの場合
  【レア度】：...
  【名前】：...
  【タイプ】：アイテム
  【特技】：...
  【キャプション】：...
  【カード背景】：...
  【外見】：...

  各項目の説明は以下の通りです。
【名前】は、対象の名称です。【レア度】が高い場合凝った名前を付けてください。
【タイプ】は、キャラクターかモンスターかアイテムです。
【状態】は、対象の心身の状態を書いてください。複数の状態が合わさっていても構いません（例：毒/麻痺/睡眠/出血/負傷/石化/病気/混乱/恐怖/魅了/狂乱/沈黙/精神汚染/絶望/疲労/ストレス/トラウマ/憑依/呪い）
【特技】は、対象の得意な事を表現してください。体言止めで書いてください。【レア度】が高い場合より強い特技を表現してください。

生成するのがキャラクターやモンスターの場合【キャプション】は、セリフと説明です。レア度に応じて長文にしてください。
生成するのがアイテムの場合【キャプション】は、説明です。レア度に応じて長文にしてください。
【カード背景】は、キャラクター、装備品、モンスターをカードにした場合にふさわしいCSSのbackground-image:の値を書いてください。カードのフォントは#000となります。
linear-gradientを巧みに用いて背景を設定してください。left top, right bottom以外にも色々と試してみてください。
【外見】は、画像生成用のスクリプトです。英語でOpenAI社の規定に沿うように書いてください。NGワードはゴブリンです。
`;
  let userContent = `${addPrompt}合計${cardCount}件、順番は問わないので上記レア度数で生成してください。`;

  if (onlyTitle != "") {
    systemContent = `
  あなたはTRPG用のキャラクター、装備品、モンスター作成のエキスパートです。
  6段階のレア度「★0～★5」のどれかを${onlyTitle}の名称から判断して設定してください。
  
  生成するのがキャラクターやモンスターの場合
  【レア度】：...
  【名前】：${onlyTitle}
  【タイプ】：${onlyType}
  【状態】：...
  【特技】：...
  【キャプション】：...
  【カード背景】：...
  【外見】：...
  
  生成するのがアイテムの場合
  【レア度】：...
  【名前】：${onlyType}
  【タイプ】：${onlyType}
  【特技】：...
  【キャプション】：...
  【カード背景】：...
  【外見】：...

  各項目の説明は以下の通りです。
【名前】は、対象の名称です。【レア度】が高い場合凝った名前を付けてください。
【タイプ】は、キャラクターかモンスターかアイテムです。
【状態】は、対象の心身の状態を書いてください。複数の状態が合わさっていても構いません（例：毒/麻痺/睡眠/出血/負傷/石化/病気/混乱/恐怖/魅了/狂乱/沈黙/精神汚染/絶望/疲労/ストレス/トラウマ/憑依/呪い）
【特技】は、対象の得意な事を表現してください。体言止めで書いてください。【レア度】が高い場合より強い特技を表現してください。

生成するのがキャラクターやモンスターの場合【キャプション】は、セリフと説明です。レア度に応じて長文にしてください。
生成するのがアイテムの場合【キャプション】は、説明です。レア度に応じて長文にしてください。
【カード背景】は、キャラクター、装備品、モンスターをカードにした場合にふさわしいCSSのbackground-image:の値を書いてください。カードのフォントは#000となります。
linear-gradientを巧みに用いて背景を設定してください。left top, right bottom以外にも色々と試してみてください。
【外見】は、画像生成用のスクリプトです。英語でOpenAI社の規定に沿うように書いてください。NGワードはゴブリンです。
`;
    userContent = `${addPrompt}上記レア度数で生成してください。`;
  }

  const messages = [
    { role: "system", content: systemContent },
    { role: "user", content: userContent },
  ];

  try {
    console.log("runGacha: Fetch start...");
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`,
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages,
        temperature: 0.7,
      }),
      signal,
    });
    if (signal.aborted) {
      console.log("runGacha: aborted.");
      return;
    }

    const data = await response.json();
    if (data.error) {
      throw new Error(data.error.message);
    }

    const text = data?.choices?.[0]?.message?.content;
    if (typeof text !== "string") {
      throw new Error("エレメント生成APIレスポンスが不正です。");
    }

    const newCards = parseCharacterData(text);
    // 生成されたカードを GachaBox に設定
    newCards.forEach(card => {
      card.group = "GachaBox";
    });
    // 既存 characterData に追加
    window.characterData.push(...newCards);

    // IndexedDB に保存
    await saveCharacterDataToIndexedDB(window.characterData);

    console.log(`runGacha: ${newCards.length}件のカードを生成完了`);
  } catch (err) {
    if (err.name === "AbortError") {
      console.log("runGachaキャンセル");
    } else {
      console.error("runGacha失敗:", err);
      alert("エレメント生成に失敗しました:\n" + err.message);
    }
  } finally {
    console.log("=== runGacha END ===");
  }
}


// --------------------------------------------------------
// 2. parseCharacterData( text )
//    - GPTレスポンスを解析してカード配列を生成
// --------------------------------------------------------
function parseCharacterData(text) {
  const lines = text.split("\n");
  const characters = [];
  let currentChar = {
    id: "",
    type: "",
    name: "",
    state: "",
    special: "",
    caption: "",
    rarity: "★0",
    backgroundcss: "",
    imageprompt: "",
    group: "GachaBox",
  };

  function pushCurrentChar() {
    currentChar.id = "card_" + Date.now() + "_" + Math.random().toString(36).substring(2);
    characters.push({ ...currentChar });
    currentChar = {
      id: "",
      type: "",
      name: "",
      state: "",
      special: "",
      caption: "",
      rarity: "★0",
      backgroundcss: "",
      imageprompt: "",
      group: "GachaBox",
    };
  }

  lines.forEach((line) => {
    line = line.trim();
    if (line.startsWith("【名前】")) {
      if (currentChar.name) pushCurrentChar();
      currentChar.name = line.replace("【名前】", "").replace("：", "").trim();
    } else if (line.startsWith("【タイプ】")) {
      currentChar.type = line.replace("【タイプ】", "").replace("：", "").trim();
    } else if (line.startsWith("【状態】")) {
      currentChar.state = line.replace("【状態】", "").replace("：", "").trim();
    } else if (line.startsWith("【特技】")) {
      currentChar.special = line.replace("【特技】", "").replace("：", "").trim();
    } else if (line.startsWith("【キャプション】")) {
      currentChar.caption = line.replace("【キャプション】", "").replace("：", "").trim();
    } else if (line.startsWith("【レア度】")) {
      currentChar.rarity = line.replace("【レア度】", "").replace("：", "").trim();
    } else if (line.startsWith("【カード背景】")) {
      currentChar.backgroundcss = line.replace("【カード背景】", "").replace("：", "").trim();
    } else if (line.startsWith("【外見】")) {
      currentChar.imageprompt = line.replace("【外見】", "").replace("：", "").trim();
    }
  });
  if (currentChar.name) {
    pushCurrentChar();
  }
  return characters;
}


// --------------------------------------------------------
// 3. pickRaritiesForNCards( n ), makeRarityCountMap( rarities )
// --------------------------------------------------------
function pickRaritiesForNCards(n) {
  const rarityDist = [
    { star: "★0", probability: 0.50 },
    { star: "★1", probability: 0.20 },
    { star: "★2", probability: 0.15 },
    { star: "★3", probability: 0.10 },
    { star: "★4", probability: 0.045 },
    { star: "★5", probability: 0.005 },
  ];
  const results = [];
  for (let i = 0; i < n; i++) {
    const rand = Math.random();
    let cum = 0;
    for (const r of rarityDist) {
      cum += r.probability;
      if (rand <= cum) {
        results.push(r.star);
        break;
      }
    }
  }
  return results;
}

function makeRarityCountMap(rarities) {
  const counts = { "★0": 0, "★1": 0, "★2": 0, "★3": 0, "★4": 0, "★5": 0 };
  rarities.forEach((r) => {
    counts[r] = (counts[r] || 0) + 1;
  });
  return counts;
}

// ----------------------------------------------
// ↑ これらをまとめて gachaCore.js として管理
// ----------------------------------------------
--- 
image.js 
/********************************
 * image.js - 画像生成関連
 ********************************/

/**
 * DALL·E API からBase64形式で直接画像を受け取り、CORSを回避する方法。
 * OpenAIの画像生成では以下のパラメータを指定することで、直接base64を返してもらうことが可能。
 *   response_format: "b64_json"
 */

/** 自動生成(現シーン) */
async function generateImageFromCurrentScene() {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  const lastSceneEntry = [...window.sceneHistory].reverse().find((e) => e.type === "scene");
  if (!lastSceneEntry) {
    alert("まだシーンがありません。");
    return;
  }
  const promptText = `シーンのイメージ: ${lastSceneEntry.content}`;
  const sceneId = lastSceneEntry.sceneId;

  window.cancelRequested = false;
  showLoadingModal(true);

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const response = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`,
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: promptText,
        n: 1,
        size: "1024x1024",
        response_format: "b64_json"
      }),
      signal,
    });

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }

    const data = await response.json();

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }
    if (data.error) {
      throw new Error(data.error.message);
    }

    // Base64文字列を取り出し、data:image/png;base64, に変換
    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    window.sceneHistory.push({
      type: "image",
      sceneId,
      prompt: promptText,
      dataUrl: dataUrl,
    });

    // IndexedDBに保存
    await saveSceneHistoryToIndexedDB(window.sceneHistory);

    updateSceneHistory();
    showLastScene();
  } catch (error) {
    if (error.name === "AbortError") {
      console.warn("画像生成キャンセル");
    } else {
      console.error("画像生成失敗:", error);
      alert("画像生成に失敗:\n" + error.message);
    }
  } finally {
    showLoadingModal(false);
  }
}

/** カスタム画像生成モーダルを開く */
function openImagePromptModal(prompt = "", index = null) {
  window.editingImageEntry = null;
  if (index !== null) {
    // 再生成の場合
    window.editingImageEntry = { index };
    const entry = window.sceneHistory[index];
    if (entry && entry.type === "image") {
      prompt = entry.prompt;
    }
  } else {
    // 新規
    const lastSceneEntry = [...window.sceneHistory].reverse().find((e) => e.type === "scene");
    if (lastSceneEntry) {
      prompt = lastSceneEntry.content;
    } else {
      prompt = window.scenario || "Fantasy scene";
    }
  }
  document.getElementById("image-custom-prompt").value = prompt;
  document.getElementById("image-prompt-modal").style.display = "flex";
}

/** カスタム画像生成モーダルを閉じる */
function closeImagePromptModal() {
  document.getElementById("image-prompt-modal").style.display = "none";
  window.editingImageEntry = null;
}

/** カスタム画像生成ボタン押下 */
async function onCustomImageGenerate() {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  const promptText = document.getElementById("image-custom-prompt").value.trim() || "Fantasy scene";

  window.cancelRequested = false;
  showLoadingModal(true);
  closeImagePromptModal();

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const response = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`,
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: promptText,
        n: 1,
        size: "1024x1024",
        response_format: "b64_json"
      }),
      signal,
    });

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }

    const data = await response.json();

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }
    if (data.error) {
      throw new Error(data.error.message);
    }

    // Base64文字列を取り出し、data:image/png;base64, に変換
    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    if (window.editingImageEntry) {
      // 既存画像を再生成
      const idx = window.editingImageEntry.index;
      const entry = window.sceneHistory[idx];
      if (entry && entry.type === "image") {
        entry.dataUrl = dataUrl;
        entry.prompt = promptText;
      }
    } else {
      // 新規
      const lastSceneEntry = [...window.sceneHistory].reverse().find((e) => e.type === "scene");
      if (!lastSceneEntry) {
        alert("シーンがありません。");
        showLoadingModal(false);
        return;
      }
      window.sceneHistory.push({
        type: "image",
        sceneId: lastSceneEntry.sceneId,
        prompt: promptText,
        dataUrl: dataUrl,
      });
    }

    // IndexedDBに保存
    await saveSceneHistoryToIndexedDB(window.sceneHistory);

    updateSceneHistory();
    showLastScene();
  } catch (error) {
    if (error.name === "AbortError") {
      console.warn("カスタム画像生成キャンセル");
    } else {
      console.error("カスタム画像生成失敗:", error);
      alert("カスタム画像生成失敗:\n" + error.message);
    }
  } finally {
    showLoadingModal(false);
  }
}
--- 
indexedDB.js 
/********************************
 * indexedDB.js
 * IndexedDB関連の初期化・保存・読み込み等を担当
 ********************************/

let db = null;

/**
 * DB初期化
 * バージョン4:
 *  - scenarios ストア (keyPath: 'scenarioId', autoIncrement)
 *  - sceneEntries ストア (keyPath: 'entryId', autoIncrement)
 *  - characterData ストア (keyPath: 'id')
 *  - wizardState ストア (keyPath: 'id')
 */
function initIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("trpgDB", 4);
    request.onupgradeneeded = (event) => {
      db = event.target.result;

      // 既存チェック
      if (!db.objectStoreNames.contains("characterData")) {
        db.createObjectStore("characterData", { keyPath: "id" });
      }

      if (!db.objectStoreNames.contains("scenarios")) {
        const scenarioStore = db.createObjectStore("scenarios", {
          keyPath: "scenarioId",
          autoIncrement: true
        });
        scenarioStore.createIndex("updatedAt", "updatedAt", { unique: false });
      }

      if (!db.objectStoreNames.contains("sceneEntries")) {
        const sceneStore = db.createObjectStore("sceneEntries", {
          keyPath: "entryId",
          autoIncrement: true
        });
        sceneStore.createIndex("scenarioId", "scenarioId", { unique: false });
      }

      if (!db.objectStoreNames.contains("wizardState")) {
        db.createObjectStore("wizardState", { keyPath: "id" });
      }
    };
    request.onsuccess = (event) => {
      db = event.target.result;
      resolve();
    };
    request.onerror = (event) => {
      console.error("IndexedDBの初期化に失敗:", event.target.error);
      reject(event.target.error);
    };
  });
}

/**
 * characterData を保存
 */
function saveCharacterDataToIndexedDB(characterData) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve();
      return;
    }
    const tx = db.transaction("characterData", "readwrite");
    const store = tx.objectStore("characterData");
    const record = { id: "characterData", data: characterData };
    const putReq = store.put(record);
    putReq.onsuccess = () => {
      resolve();
    };
    putReq.onerror = (err) => {
      reject(err);
    };
  });
}

/**
 * characterData をロード
 */
function loadCharacterDataFromIndexedDB() {
  return new Promise((resolve) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve([]);
      return;
    }
    const tx = db.transaction("characterData", "readonly");
    const store = tx.objectStore("characterData");
    const getReq = store.get("characterData");
    getReq.onsuccess = (event) => {
      if (event.target.result && event.target.result.data) {
        resolve(event.target.result.data);
      } else {
        resolve([]);
      }
    };
    getReq.onerror = () => {
      resolve([]);
    };
  });
}

/**
 * wizardData を保存
 */
function saveWizardDataToIndexedDB(wizardData) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("wizardState", "readwrite");
    const store = tx.objectStore("wizardState");
    const record = { id: "wizardData", data: wizardData };
    const req = store.put(record);
    req.onsuccess = () => resolve();
    req.onerror = (err) => reject(err);
  });
}

/**
 * wizardData をロード
 */
function loadWizardDataFromIndexedDB() {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("wizardState", "readonly");
    const store = tx.objectStore("wizardState");
    const getReq = store.get("wizardData");
    getReq.onsuccess = (evt) => {
      if (evt.target.result) {
        resolve(evt.target.result.data);
      } else {
        resolve(null);
      }
    };
    getReq.onerror = (err) => {
      reject(err);
    };
  });
}

/* -------------------------------------------
    新しいシナリオの追加・読み込み用API
   -------------------------------------------*/
function createNewScenario(wizardData, title = "新シナリオ") {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("scenarios", "readwrite");
    const store = tx.objectStore("scenarios");

    const now = new Date();
    const record = {
      title: title,
      wizardData: wizardData,
      createdAt: now.toISOString(),
      updatedAt: now.toISOString()
    };

    const addReq = store.add(record);
    addReq.onsuccess = (evt) => {
      const newId = evt.target.result;
      resolve(newId);
    };
    addReq.onerror = (err) => {
      reject(err);
    };
  });
}

function getScenarioById(scenarioId) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("scenarios", "readonly");
    const store = tx.objectStore("scenarios");
    const getReq = store.get(scenarioId);
    getReq.onsuccess = (evt) => {
      resolve(evt.target.result || null);
    };
    getReq.onerror = (err) => {
      reject(err);
    };
  });
}

function listAllScenarios() {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("scenarios", "readonly");
    const store = tx.objectStore("scenarios");
    const req = store.getAll();
    req.onsuccess = (evt) => {
      const result = evt.target.result || [];
      result.sort((a, b) => (b.updatedAt || "").localeCompare(a.updatedAt || ""));
      resolve(result);
    };
    req.onerror = (err) => {
      reject(err);
    };
  });
}

function updateScenario(scenario) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    scenario.updatedAt = new Date().toISOString();
    const tx = db.transaction("scenarios", "readwrite");
    const store = tx.objectStore("scenarios");
    const putReq = store.put(scenario);
    putReq.onsuccess = () => {
      resolve();
    };
    putReq.onerror = (err) => {
      reject(err);
    };
  });
}

/* -------------------------------------------
    シーン履歴 (sceneEntries) の操作
   -------------------------------------------*/
function addSceneEntry(entry) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("sceneEntries", "readwrite");
    const store = tx.objectStore("sceneEntries");
    const addReq = store.add(entry);
    addReq.onsuccess = (evt) => {
      resolve(evt.target.result);
    };
    addReq.onerror = (err) => {
      reject(err);
    };
  });
}

function getSceneEntriesByScenarioId(scenarioId) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("sceneEntries", "readonly");
    const store = tx.objectStore("sceneEntries");
    const index = store.index("scenarioId");

    const range = IDBKeyRange.only(scenarioId);
    const results = [];
    index.openCursor(range).onsuccess = (evt) => {
      const cursor = evt.target.result;
      if (cursor) {
        results.push(cursor.value);
        cursor.continue();
      } else {
        results.sort((a, b) => (a.entryId - b.entryId));
        resolve(results);
      }
    };
    index.openCursor(range).onerror = (err) => {
      reject(err);
    };
  });
}

function updateSceneEntry(entry) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("sceneEntries", "readwrite");
    const store = tx.objectStore("sceneEntries");
    const putReq = store.put(entry);
    putReq.onsuccess = () => {
      resolve();
    };
    putReq.onerror = (err) => {
      reject(err);
    };
  });
}

function deleteSceneEntry(entryId) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("sceneEntries", "readwrite");
    const store = tx.objectStore("sceneEntries");
    const delReq = store.delete(entryId);
    delReq.onsuccess = () => {
      resolve();
    };
    delReq.onerror = (err) => {
      reject(err);
    };
  });
}

/* ★シナリオ削除用 */
function deleteScenarioById(scenarioId) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    // scenarios, sceneEntries両方をreadwrite
    const tx = db.transaction(["scenarios", "sceneEntries"], "readwrite");
    const scenarioStore = tx.objectStore("scenarios");
    const sceneEntriesStore = tx.objectStore("sceneEntries");

    // 1) シナリオ本体を削除
    const deleteReq = scenarioStore.delete(scenarioId);
    deleteReq.onsuccess = () => {
      // 2) さらにsceneEntriesで scenarioId が一致するものを全削除
      const idx = sceneEntriesStore.index("scenarioId");
      const range = IDBKeyRange.only(scenarioId);

      idx.openCursor(range).onsuccess = (evt) => {
        const cursor = evt.target.result;
        if (cursor) {
          sceneEntriesStore.delete(cursor.primaryKey);
          cursor.continue();
        }
      };

      tx.oncomplete = () => {
        resolve();
      };
      tx.onerror = (err) => {
        reject(err);
      };
    };
    deleteReq.onerror = (err) => {
      reject(err);
    };
  });
}

/* ★ユニークID生成ヘルパ */
function generateUniqueId() {
  return Date.now() + "_" + Math.random().toString(36).slice(2, 9);
}

/* ★シナリオコピー用（画像含む） */
async function copyScenarioById(originalScenarioId) {
  if (!db) {
    throw new Error("DB未初期化");
  }
  try {
    // 1) 元シナリオ取得
    const original = await getScenarioById(originalScenarioId);
    if (!original) {
      throw new Error("コピー元シナリオが存在しません");
    }

    // 2) 新シナリオを作成（タイトルに「(コピー)」を付ける）
    const newTitle = original.title + " (コピー)";
    const newScenarioId = await createNewScenario(original.wizardData, newTitle);

    // 3) 元シーンエントリをすべて取得
    const originalEntries = await getSceneEntriesByScenarioId(originalScenarioId);

    // 3.5) シーンIDのマッピングを作る (元シーンID → 新シーンID)
    const sceneIdMap = {};
    // まず sceneEntries のうち type==='scene' のものに対して、新しい sceneId を割り当てる
    originalEntries.forEach(e => {
      if (e.type === "scene") {
        sceneIdMap[e.sceneId] = generateUniqueId();
      }
    });

    // 4) すべて新シナリオIDに合わせて複製
    const tx = db.transaction("sceneEntries", "readwrite");
    const sceneStore = tx.objectStore("sceneEntries");

    for (const e of originalEntries) {
      // シーンまたは画像に紐づくsceneIdがあれば置き換える
      let newSceneId = e.sceneId;
      if (sceneIdMap[e.sceneId]) {
        newSceneId = sceneIdMap[e.sceneId];
      }

      const copyEntry = {
        scenarioId: newScenarioId,
        type: e.type,
        sceneId: newSceneId,
        content: e.content,
        dataUrl: e.dataUrl || null,
        prompt: e.prompt || null
      };
      sceneStore.add(copyEntry);
    }

    await new Promise((resolve, reject) => {
      tx.oncomplete = () => {
        resolve();
      };
      tx.onerror = (err) => {
        reject(err);
      };
    });

    // 5) 最後に scenarios.updatedAt を更新
    const newScenario = await getScenarioById(newScenarioId);
    if (newScenario) {
      newScenario.updatedAt = new Date().toISOString();
      await updateScenario(newScenario);
    }

    return newScenarioId;
  } catch (err) {
    console.error("copyScenarioById失敗:", err);
    throw err;
  }
}

/* -------------------------------------------
  エクスポート
-------------------------------------------*/
window.initIndexedDB = initIndexedDB;

window.saveCharacterDataToIndexedDB = saveCharacterDataToIndexedDB;
window.loadCharacterDataFromIndexedDB = loadCharacterDataFromIndexedDB;

window.saveWizardDataToIndexedDB = saveWizardDataToIndexedDB;
window.loadWizardDataFromIndexedDB = loadWizardDataFromIndexedDB;

window.createNewScenario = createNewScenario;
window.getScenarioById = getScenarioById;
window.listAllScenarios = listAllScenarios;
window.updateScenario = updateScenario;

window.addSceneEntry = addSceneEntry;
window.getSceneEntriesByScenarioId = getSceneEntriesByScenarioId;
window.updateSceneEntry = updateSceneEntry;
window.deleteSceneEntry = deleteSceneEntry;

window.deleteScenarioById = deleteScenarioById;
window.copyScenarioById = copyScenarioById;  // 修正後エクスポート
--- 
main.js 
/********************************
 * main.js
 * - ページ全体の初期化・イベント登録
 * - 複数シナリオ対応
 ********************************/

window.onload = async () => {
  // 1) IndexedDB初期化
  await initIndexedDB();

  // 2) APIキー読み込み
  const savedApiKey = localStorage.getItem('apiKey');
  if (savedApiKey) {
    window.apiKey = savedApiKey;
  }

  // 3) URLパラメータで scenarioId を読み取る
  const urlParams = new URLSearchParams(window.location.search);
  const scenarioIdStr = urlParams.get("scenarioId");
  const scenarioId = scenarioIdStr ? parseInt(scenarioIdStr, 10) : null;

  window.currentScenarioId = scenarioId || null;

  // 4) シナリオIDがあれば、DBから読み込んで画面を構築
  if (window.currentScenarioId) {
    // 旧の「入力セクション」は非表示、ゲーム画面のみ表示
    const inputSec = document.querySelector('.input-section');
    if (inputSec) inputSec.style.display = 'none';

    const gameSec = document.querySelector('.game-section');
    if (gameSec) gameSec.style.display = 'block';

    // scene.js 側の「loadScenarioData」でシナリオ＆履歴を取得して表示
    await loadScenarioData(window.currentScenarioId);
    updateSceneHistory();
    showLastScene();
  }

  // ---------- ネタバレ（目的達成型）関連 ----------
  const spoilerModal = document.getElementById("spoiler-modal");
  const spoilerButton = document.getElementById("spoiler-button");
  const closeSpoilerModalBtn = document.getElementById("close-spoiler-modal");
  if (spoilerButton) {
    spoilerButton.addEventListener("click", () => {
      spoilerModal.style.display = "flex";
    });
  }
  if (closeSpoilerModalBtn) {
    closeSpoilerModalBtn.addEventListener("click", () => {
      spoilerModal.style.display = "none";
    });
  }

  // ---------- 探索型「カードを取得する」ボタン ----------
  const getCardButton = document.getElementById("get-card-button");
  if (getCardButton) {
    // ※ 実際の処理は scenarioPage.js で定義
  }

  // ---------- シーン遷移ボタン ----------
  const nextSceneBtn = document.getElementById('next-scene');
  if (nextSceneBtn) {
    nextSceneBtn.addEventListener('click', () => {
      getNextScene();
    });
  }

  // 画像生成 (自動)
  const autoGenBtn = document.getElementById('image-auto-generate-button');
  if (autoGenBtn) {
    autoGenBtn.addEventListener('click', () => {
      generateImageFromCurrentScene();
    });
  }

  // 画像生成 (カスタム)
  const promptModalBtn = document.getElementById('image-prompt-modal-button');
  if (promptModalBtn) {
    promptModalBtn.addEventListener('click', () => {
      openImagePromptModal();
    });
  }

  // カスタム画像生成 決定
  const customGenBtn = document.getElementById('image-custom-generate-button');
  if (customGenBtn) {
    customGenBtn.addEventListener('click', () => {
      onCustomImageGenerate();
    });
  }

  // カスタム画像生成 キャンセル
  const customCancelBtn = document.getElementById('image-custom-cancel-button');
  if (customCancelBtn) {
    customCancelBtn.addEventListener('click', () => {
      closeImagePromptModal();
    });
  }

  // リクエストキャンセル
  const cancelRequestBtn = document.getElementById('cancel-request-button');
  if (cancelRequestBtn) {
    cancelRequestBtn.addEventListener('click', onCancelFetch);
  }

  // メニューに戻る
  const backMenuBtn = document.getElementById('back-to-menu');
  if (backMenuBtn) {
    backMenuBtn.addEventListener('click', () => {
      window.location.href = "index.html";
    });
  }
};
--- 
menu.js 
// menu.js

let scenarioIdToDelete = null;
let warehouseSelectionMode = false; // ★追加: 倉庫側の選択モードフラグ

// -----------------------------------------
// トースト表示用のユーティリティ関数
// -----------------------------------------
function showToast(message) {
  const oldToast = document.getElementById("toast-message");
  if (oldToast) {
    oldToast.remove();
  }

  const toast = document.createElement("div");
  toast.id = "toast-message";
  toast.textContent = message;

  // スタイルを付与（シンプルな例）
  toast.style.position = "fixed";
  toast.style.bottom = "20px";
  toast.style.left = "50%";
  toast.style.transform = "translateX(-50%)";
  toast.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
  toast.style.color = "#fff";
  toast.style.padding = "10px 20px";
  toast.style.borderRadius = "4px";
  toast.style.fontSize = "14px";
  toast.style.zIndex = "9999";
  toast.style.opacity = "0";
  toast.style.transition = "opacity 0.3s ease";

  document.body.appendChild(toast);

  requestAnimationFrame(() => {
    toast.style.opacity = "1";
  });

  // 3秒後にフェードアウトして消す
  setTimeout(() => {
    toast.style.opacity = "0";
    toast.addEventListener("transitionend", () => {
      toast.remove();
    });
  }, 3000);
}

// -----------------------------------------
// 初期化：シナリオ一覧の取得 & characterDataのロード
// -----------------------------------------
(async function initMenuPage() {
  // 1) APIキーを入力欄に表示
  const savedApiKey = localStorage.getItem("apiKey");
  if (savedApiKey) {
    document.getElementById("api-key-input").value = savedApiKey;
  }

  // 2) シナリオ一覧を取得して表示
  try {
    const scenarioList = await listAllScenarios();  // indexedDB.js の関数
    const container = document.getElementById("scenario-list-container");
    container.innerHTML = "";

    if (scenarioList.length === 0) {
      container.textContent = "進行中のシナリオはありません。";
    } else {
      scenarioList.forEach(scenario => {
        const div = document.createElement("div");
        div.style.margin = "10px 0";

        // シナリオ情報
        const infoText = document.createElement("span");
        infoText.textContent = `ID:${scenario.scenarioId} / ${scenario.title} (更新:${scenario.updatedAt}) `;
        div.appendChild(infoText);

        // 「続きへ」ボタン
        const btnContinue = document.createElement("button");
        btnContinue.textContent = "続きへ";
        btnContinue.style.marginRight = "6px";
        btnContinue.addEventListener("click", () => {
          window.location.href = `scenario.html?scenarioId=${scenario.scenarioId}`;
        });
        div.appendChild(btnContinue);

        // ★ 追加: 「コピーする」ボタン
        const btnCopy = document.createElement("button");
        btnCopy.textContent = "コピーする";
        btnCopy.style.marginRight = "6px";
        btnCopy.addEventListener("click", async () => {
          try {
            const newScenarioId = await copyScenarioById(scenario.scenarioId);
            showToast(`シナリオ(ID:${scenario.scenarioId})をコピーしました。\n新ID: ${newScenarioId}`);
            // リスト更新のためリロードするか、あるいは手動で再取得する
            location.reload();
          } catch (err) {
            console.error(err);
            showToast("シナリオのコピーに失敗:\n" + err.message);
          }
        });
        div.appendChild(btnCopy);

        // 「削除」ボタン
        const btnDelete = document.createElement("button");
        btnDelete.textContent = "削除";
        btnDelete.style.backgroundColor = "#f44336";
        btnDelete.addEventListener("click", () => {
          scenarioIdToDelete = scenario.scenarioId;
          showDeleteScenarioModal(true);
        });
        div.appendChild(btnDelete);

        container.appendChild(div);
      });
    }
  } catch (err) {
    console.error("シナリオ一覧の取得に失敗:", err);
    const container = document.getElementById("scenario-list-container");
    container.textContent = "シナリオ一覧の取得に失敗しました。再読み込みしてください。";
  }

  // 3) characterDataをロード
  try {
    const stored = await loadCharacterDataFromIndexedDB();
    window.characterData = stored || [];
  } catch (err) {
    console.error("characterDataのロードに失敗:", err);
    window.characterData = [];
  }

  // 4) 倉庫ボタン・倉庫モーダル関連のイベント設定
  const showWarehouseBtn = document.getElementById("show-warehouse-btn");
  if (showWarehouseBtn) {
    showWarehouseBtn.addEventListener("click", showWarehouseModal);
  }

  const toggleModeBtn = document.getElementById("toggle-warehouse-selection-mode-btn");
  if (toggleModeBtn) {
    toggleModeBtn.addEventListener("click", toggleWarehouseSelectionMode);
  }

  const closeWarehouseBtn = document.getElementById("close-warehouse-btn");
  if (closeWarehouseBtn) {
    closeWarehouseBtn.addEventListener("click", closeWarehouseModal);
  }

  const deleteWarehouseBtn = document.getElementById("delete-selected-warehouse-btn");
  if (deleteWarehouseBtn) {
    deleteWarehouseBtn.addEventListener("click", deleteSelectedWarehouse);
  }
})();

// -----------------------------------------
// APIキー関連
// -----------------------------------------
document.getElementById("set-api-key-button").addEventListener("click", function () {
  const apiKey = document.getElementById("api-key-input").value.trim();
  if (apiKey) {
    localStorage.setItem("apiKey", apiKey);
    showToast("APIキーが設定されました。");
  } else {
    showToast("APIキーを入力してください。");
  }
});

document.getElementById("clear-api-key-button").addEventListener("click", function () {
  const confirmClear = confirm("APIキーをクリアすると操作ができなくなります。よろしいですか？");
  if (confirmClear) {
    localStorage.removeItem("apiKey");
    showToast("APIキーがクリアされました。");
  }
});

// -----------------------------------------
// 全エレメントをクリア
// -----------------------------------------
document.getElementById("clear-character-btn").addEventListener("click", async () => {
  const confirmClear = confirm("エレメント情報をクリアします。よろしいですか？");
  if (confirmClear) {
    window.characterData = [];
    await saveCharacterDataToIndexedDB(window.characterData);
    showToast("エレメント情報をクリアしました。");
  }
});

// -----------------------------------------
// シナリオ削除用モーダルの制御
// -----------------------------------------
function showDeleteScenarioModal(show) {
  const modal = document.getElementById("delete-scenario-modal");
  if (!modal) return;
  modal.style.display = show ? "flex" : "none";
}

document.getElementById("delete-scenario-ok").addEventListener("click", async () => {
  if (scenarioIdToDelete == null) {
    showDeleteScenarioModal(false);
    return;
  }
  try {
    await deleteScenarioById(scenarioIdToDelete);  // indexedDB.js の関数
    showToast(`シナリオ(ID:${scenarioIdToDelete})を削除しました。`);
  } catch (err) {
    console.error(err);
    showToast("シナリオ削除に失敗:\n" + err.message);
  }
  scenarioIdToDelete = null;
  showDeleteScenarioModal(false);

  // 一覧を再描画するためリロード
  location.reload();
});

document.getElementById("delete-scenario-cancel").addEventListener("click", () => {
  scenarioIdToDelete = null;
  showDeleteScenarioModal(false);
});

// -----------------------------------------
// デモ用ボタン
// -----------------------------------------
document.getElementById("sample-btn").addEventListener("click", () => {
  showToast("ほげ");
});

// -----------------------------------------
// ▼ 倉庫表示関連 (新規機能)
// -----------------------------------------

/** 倉庫モーダルを表示 */
function showWarehouseModal() {
  const modal = document.getElementById("warehouse-modal");
  modal.style.display = "flex";
  renderWarehouseCards();
}

/** 倉庫モーダルを閉じる */
function closeWarehouseModal() {
  const modal = document.getElementById("warehouse-modal");
  modal.style.display = "none";

  // 選択モードリセット
  warehouseSelectionMode = false;
  document.getElementById("toggle-warehouse-selection-mode-btn").textContent = "選択モード";
  document.getElementById("delete-selected-warehouse-btn").style.display = "none";

  // 選択状態を解除
  const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
  selectedCards.forEach(card => card.classList.remove("selected"));
}

/** 倉庫内カードを再描画 */
function renderWarehouseCards() {
  const container = document.getElementById("warehouse-card-container");
  container.innerHTML = "";

  // group==="Warehouse" のカードを抽出
  const warehouseCards = window.characterData.filter(c => c.group === "Warehouse");
  if (warehouseCards.length === 0) {
    container.textContent = "倉庫にカードがありません。";
    return;
  }

  // カード要素生成
  warehouseCards.forEach(card => {
    const cardEl = createWarehouseCardElement(card);
    container.appendChild(cardEl);
  });
}

/** 倉庫カードDOM生成 */
function createWarehouseCardElement(card) {
  const cardEl = document.createElement("div");
  cardEl.className = "card";
  cardEl.setAttribute("data-id", card.id);

  // カードクリック時
  cardEl.addEventListener("click", (e) => {
    if (warehouseSelectionMode) {
      e.stopPropagation();
      cardEl.classList.toggle("selected");
      updateDeleteSelectedWarehouseButton();
    } else {
      // 通常は反転表示
      cardEl.classList.toggle("flipped");
    }
  });

  // カード内部構造
  const cardInner = document.createElement("div");
  cardInner.className = "card-inner";

  const cardFront = document.createElement("div");
  cardFront.className = "card-front";

  // 背景CSS
  const bgStyle = (card.backgroundcss || "")
    .replace("background-image:", "")
    .replace("background", "")
    .trim();
  cardFront.style = "background-image:" + bgStyle;

  // レアリティに対応する枠
  const rarityValue = (typeof card.rarity === "string") ? card.rarity.replace("★", "").trim() : "0";
  cardFront.innerHTML = `<div class='bezel rarity${rarityValue}'></div>`;

  // カードタイプ表示
  const typeEl = document.createElement("div");
  typeEl.className = "card-type";
  typeEl.textContent = card.type || "不明";
  cardFront.appendChild(typeEl);

  // 画像部
  const imageContainer = document.createElement("div");
  imageContainer.className = "card-image";
  if (card.imageData) {
    const imageEl = document.createElement("img");
    imageEl.src = card.imageData;
    imageEl.alt = card.name;
    imageContainer.appendChild(imageEl);
  }
  cardFront.appendChild(imageContainer);

  // 下部情報
  const infoContainer = document.createElement("div");
  infoContainer.className = "card-info";

  // 名前
  const nameEl = document.createElement("p");
  nameEl.innerHTML = "<h3>" + DOMPurify.sanitize(card.name) + "</h3>";
  infoContainer.appendChild(nameEl);

  // 状態
  if (card.state) {
    const stateEl = document.createElement("p");
    stateEl.innerHTML = "<strong>状態：</strong>" + DOMPurify.sanitize(card.state);
    infoContainer.appendChild(stateEl);
  }

  // 特技
  const specialEl = document.createElement("p");
  specialEl.innerHTML = "<strong>特技：</strong>" + DOMPurify.sanitize(card.special);
  infoContainer.appendChild(specialEl);

  // キャプション
  const captionEl = document.createElement("p");
  captionEl.innerHTML = "<span>" + DOMPurify.sanitize(card.caption) + "</span>";
  infoContainer.appendChild(captionEl);

  cardFront.appendChild(infoContainer);

  const cardBack = document.createElement("div");
  cardBack.className = "card-back";
  cardBack.innerHTML = `<strong>${DOMPurify.sanitize(card.type)}</strong>`;

  cardInner.appendChild(cardFront);
  cardInner.appendChild(cardBack);
  cardEl.appendChild(cardInner);

  return cardEl;
}

/** 倉庫の選択モード切り替え */
function toggleWarehouseSelectionMode() {
  warehouseSelectionMode = !warehouseSelectionMode;
  const btn = document.getElementById("toggle-warehouse-selection-mode-btn");
  if (warehouseSelectionMode) {
    btn.textContent = "選択モード解除";
  } else {
    btn.textContent = "選択モード";
    // モード解除時はすべて選択解除
    const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
    selectedCards.forEach(card => card.classList.remove("selected"));
  }
  updateDeleteSelectedWarehouseButton();
}

/** 選択状態に応じて「選択したカードを削除」ボタンの表示を切り替え */
function updateDeleteSelectedWarehouseButton() {
  const deleteBtn = document.getElementById("delete-selected-warehouse-btn");
  if (!warehouseSelectionMode) {
    deleteBtn.style.display = "none";
    return;
  }
  const selected = document.querySelectorAll("#warehouse-card-container .card.selected");
  deleteBtn.style.display = (selected.length > 0) ? "inline-block" : "none";
}

/** 選択した倉庫内カードを削除 */
async function deleteSelectedWarehouse() {
  const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
  if (selectedCards.length === 0) {
    alert("カードが選択されていません。");
    return;
  }

  // 選択カードをcharacterDataから削除
  selectedCards.forEach(cardEl => {
    const cardId = cardEl.getAttribute("data-id");
    const idx = window.characterData.findIndex(c => c.id === cardId);
    if (idx !== -1) {
      // ここでは「倉庫から取り除く」ではなく「完全に削除」する挙動
      window.characterData.splice(idx, 1);
    }
  });

  await saveCharacterDataToIndexedDB(window.characterData);

  // 再描画
  renderWarehouseCards();
  updateDeleteSelectedWarehouseButton();
}
--- 
partyCreate.js 
// partyCreate.js

// グローバル変数
window.partySelectionMode = false;    // パーティ側の選択モードフラグ
window.warehouseSelectionMode = false; // 倉庫側の選択モードフラグ

window.addEventListener("load", async function(){
    await initIndexedDB();
    const stored = await loadCharacterDataFromIndexedDB();
    if(stored) {
      window.characterData = stored;
    } else {
      window.characterData = [];
    }

    // パーティ表示を初回レンダリング
    renderAllParty();

    // 倉庫モーダル管理
    document.getElementById("show-warehouse-btn").addEventListener("click", () => {
      showWarehouseModal();
    });

    // 倉庫モーダルを閉じる
    document.getElementById("close-warehouse-btn").addEventListener("click", () => {
      document.getElementById("warehouse-modal").style.display = "none";
      // 倉庫側の選択をリセット
      warehouseSelectionMode = false;
      document.getElementById("toggle-warehouse-selection-mode-btn").textContent = "選択モード";
      document.getElementById("add-to-party-btn").style.display = "none";
      // 全カードの selected を外す
      const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
      selectedCards.forEach(el => el.classList.remove("selected"));
    });

    // 「選択モード（パーティ側）」ボタン
    document.getElementById("toggle-party-selection-mode-btn").addEventListener("click", () => {
      window.partySelectionMode = !window.partySelectionMode;
      const btn = document.getElementById("toggle-party-selection-mode-btn");
      if(partySelectionMode) {
        btn.textContent = "選択モード解除";
      } else {
        btn.textContent = "選択モード";
        // 解除時、選択を全リセット
        const selectedCards = document.querySelectorAll(
          "#avatar-card-container .card.selected, " +
          "#partner-card-container .card.selected, " +
          "#party-card-container .card.selected"
        );
        selectedCards.forEach(el => el.classList.remove("selected"));
      }
      updatePartyMoveButtonVisibility();
    });

    // 「パーティ選択カードを倉庫に戻す」ボタン
    document.getElementById("move-selected-to-warehouse-btn").addEventListener("click", async () => {
      const selectedCards = document.querySelectorAll(
        "#avatar-card-container .card.selected, " +
        "#partner-card-container .card.selected, " +
        "#party-card-container .card.selected"
      );
      if(selectedCards.length === 0) {
        alert("カードが選択されていません。");
        return;
      }
      selectedCards.forEach(el => {
        const cardId = el.getAttribute("data-id");
        const idx = window.characterData.findIndex(c => c.id === cardId);
        if(idx !== -1) {
          // グループを倉庫に戻す
          window.characterData[idx].group = "Warehouse";
          // roleをリセット
          window.characterData[idx].role = "none";
        }
      });
      await saveCharacterDataToIndexedDB(window.characterData);
      // 選択解除 & 再描画
      selectedCards.forEach(el => el.classList.remove("selected"));
      renderAllParty();
      updatePartyMoveButtonVisibility();
    });

    // 「選択モード（倉庫側）」ボタン
    document.getElementById("toggle-warehouse-selection-mode-btn").addEventListener("click", () => {
      window.warehouseSelectionMode = !window.warehouseSelectionMode;
      const btn = document.getElementById("toggle-warehouse-selection-mode-btn");
      if(warehouseSelectionMode) {
        btn.textContent = "選択モード解除";
      } else {
        btn.textContent = "選択モード";
        // 解除時、選択を全リセット
        const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
        selectedCards.forEach(el => el.classList.remove("selected"));
      }
      updateWarehouseAddButtonVisibility();
    });

    // 「倉庫選択カードをパーティへ」ボタン
    document.getElementById("add-to-party-btn").addEventListener("click", async () => {
      const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
      if(selectedCards.length === 0) {
        alert("カードが選択されていません。");
        return;
      }
      selectedCards.forEach(el => {
        const cardId = el.getAttribute("data-id");
        const realIndex = window.characterData.findIndex(c => c.id === cardId);
        if(realIndex !== -1){
          window.characterData[realIndex].group = "Party";
          // roleは一旦 "none" にしておく（ユーザーが後からアバター/パートナーに設定可能）
          window.characterData[realIndex].role = "none";
        }
      });

      await saveCharacterDataToIndexedDB(window.characterData);
      // 選択解除
      selectedCards.forEach(el => el.classList.remove("selected"));
      // 倉庫再描画 & パーティ再描画
      showWarehouseModal();
      renderAllParty();
      updateWarehouseAddButtonVisibility();
    });

    // 戻るボタン
    document.getElementById("back-to-menu").addEventListener("click", () => {
      window.location.href = "index.html";
    });
});


/** 
 * パーティ全体を再レンダリングする。
 *  - role==="avatar" → #avatar-card-container
 *  - role==="partner" → #partner-card-container
 *  - その他（none） → #party-card-container
 */
function renderAllParty(){
  // 対象は group==="Party"
  const partyCards = window.characterData.filter(c => c.group === "Party");

  // 各コンテナをクリア
  const avatarContainer = document.getElementById("avatar-card-container");
  const partnerContainer = document.getElementById("partner-card-container");
  const partyContainer = document.getElementById("party-card-container");

  avatarContainer.innerHTML = "";
  partnerContainer.innerHTML = "";
  partyContainer.innerHTML = "";

  // 三分類して表示
  const avatarCards = partyCards.filter(c => c.role === "avatar");
  const partnerCards = partyCards.filter(c => c.role === "partner");
  const noneCards   = partyCards.filter(c => !c.role || c.role === "none");

  // それぞれの描画
  avatarCards.forEach(card => {
    const el = createPartyCardElement(card);
    avatarContainer.appendChild(el);
  });
  partnerCards.forEach(card => {
    const el = createPartyCardElement(card);
    partnerContainer.appendChild(el);
  });
  noneCards.forEach(card => {
    const el = createPartyCardElement(card);
    partyContainer.appendChild(el);
  });
}

/** パーティカードDOM生成（クリック時のアバター/パートナー切り替え用ボタンを付与） */
function createPartyCardElement(card){
  const cardEl = document.createElement("div");
  cardEl.className = "card";
  cardEl.setAttribute("data-id", card.id);

  // クリック時の選択モード対応
  cardEl.addEventListener("click", (e) => {
    if(window.partySelectionMode) {
      e.stopPropagation();
      cardEl.classList.toggle("selected");
      updatePartyMoveButtonVisibility();
    } else {
      // 通常時はカードを反転
      cardEl.classList.toggle("flipped");
    }
  });

  // 内部構造
  const cardInner = document.createElement("div");
  cardInner.className = "card-inner";

  const cardFront = document.createElement("div");
  cardFront.className = "card-front";

  const bgStyle = (card.backgroundcss || "")
      .replace("background-image:", "")
      .replace("background", "")
      .trim();
  cardFront.style = "background-image:" + bgStyle;

  // レアリティ枠
  const rarityValue = (typeof card.rarity === "string") ? card.rarity.replace("★", "").trim() : "0";
  cardFront.innerHTML = `<div class='bezel rarity${rarityValue}'></div>`;

  // カードタイプ表示
  const typeEl = document.createElement("div");
  typeEl.className = "card-type";
  typeEl.textContent = card.type || "不明";
  cardFront.appendChild(typeEl);

  // 画像
  const imageContainer = document.createElement("div");
  imageContainer.className = "card-image";
  if(card.imageData){
    const imageEl = document.createElement("img");
    imageEl.src = card.imageData;
    imageEl.alt = card.name;
    imageContainer.appendChild(imageEl);
  }
  cardFront.appendChild(imageContainer);

  // 下部テキスト情報
  const infoContainer = document.createElement("div");
  infoContainer.className = "card-info";

  const nameEl = document.createElement("p");
  nameEl.innerHTML = "<h3>" + DOMPurify.sanitize(card.name) + "</h3>";
  infoContainer.appendChild(nameEl);

  if (card.state) {
    const stateEl = document.createElement("p");
    stateEl.innerHTML = "<strong>状態：</strong>" + DOMPurify.sanitize(card.state);
    infoContainer.appendChild(stateEl);
  }
  const specialEl = document.createElement("p");
  specialEl.innerHTML = "<strong>特技：</strong>" + DOMPurify.sanitize(card.special);
  infoContainer.appendChild(specialEl);

  const captionEl = document.createElement("p");
  captionEl.innerHTML = "<span>" + DOMPurify.sanitize(card.caption) + "</span>";
  infoContainer.appendChild(captionEl);

  // ▼ role切り替えボタン (アバター/パートナー)
  const roleContainer = document.createElement("div");
  roleContainer.style.marginTop = "8px";

  // アバターに設定
  const avatarBtn = document.createElement("button");
  avatarBtn.textContent = (card.role === "avatar") ? "アバター解除" : "アバターに設定";
  avatarBtn.style.marginRight = "5px";
  avatarBtn.addEventListener("click", async (e) => {
    e.stopPropagation();
    await toggleAvatar(card);
  });
  roleContainer.appendChild(avatarBtn);

  // パートナーに設定
  const partnerBtn = document.createElement("button");
  partnerBtn.textContent = (card.role === "partner") ? "パートナー解除" : "パートナーに設定";
  partnerBtn.addEventListener("click", async (e) => {
    e.stopPropagation();
    await togglePartner(card);
  });
  roleContainer.appendChild(partnerBtn);

  infoContainer.appendChild(roleContainer);
  cardFront.appendChild(infoContainer);

  // カード裏面
  const cardBack = document.createElement("div");
  cardBack.className = "card-back";
  cardBack.innerHTML = `<strong>${DOMPurify.sanitize(card.type)}</strong>`;

  cardInner.appendChild(cardFront);
  cardInner.appendChild(cardBack);
  cardEl.appendChild(cardInner);

  return cardEl;
}


/** アバター切り替え処理 (1枚のみ許容) */
async function toggleAvatar(card) {
  // もし既にアバターなら → 解除（none）にする
  if(card.role === "avatar") {
    card.role = "none";
  } else {
    // それ以外なら自分をアバターにして、他のアバターは解除する
    // group="Party" の中で role="avatar" のものをすべて none に
    window.characterData.forEach(c => {
      if(c.group === "Party" && c.role === "avatar") {
        c.role = "none";
      }
    });
    card.role = "avatar";
  }
  await saveCharacterDataToIndexedDB(window.characterData);
  renderAllParty();
}

/** パートナー切り替え処理 (複数可) */
async function togglePartner(card) {
  // もし既にパートナーなら → 解除（none）にする
  if(card.role === "partner") {
    card.role = "none";
  } else {
    // それ以外なら partner に設定
    card.role = "partner";
    // アバターとは排他しないので、他の設定はそのまま
    if(card.role === "avatar") {
      card.role = "none"; // …ということはないので特に処理不要
    }
  }
  await saveCharacterDataToIndexedDB(window.characterData);
  renderAllParty();
}


/** 倉庫モーダルを表示 */
function showWarehouseModal(){
  const modal = document.getElementById("warehouse-modal");
  modal.style.display = "flex";

  const warehouseContainer = document.getElementById("warehouse-card-container");
  warehouseContainer.innerHTML = "";

  // group==="Warehouse" のみ
  const warehouseCards = window.characterData.filter(c => c.group === "Warehouse");
  if(warehouseCards.length === 0) {
    warehouseContainer.textContent = "倉庫にカードがありません。";
    return;
  }

  warehouseCards.forEach((card) => {
    const cardEl = createWarehouseCardElement(card);
    warehouseContainer.appendChild(cardEl);
  });
  updateWarehouseAddButtonVisibility();
}

/** 倉庫カード生成 */
function createWarehouseCardElement(card){
  const cardEl = document.createElement("div");
  cardEl.className = "card";
  cardEl.setAttribute("data-id", card.id);

  // クリック時
  cardEl.addEventListener("click", (e) => {
    if(window.warehouseSelectionMode) {
      e.stopPropagation();
      cardEl.classList.toggle("selected");
      updateWarehouseAddButtonVisibility();
    } else {
      cardEl.classList.toggle("flipped");
    }
  });

  const cardInner = document.createElement("div");
  cardInner.className = "card-inner";
  const cardFront = document.createElement("div");
  cardFront.className = "card-front";

  const bgStyle = (card.backgroundcss || "")
      .replace("background-image:", "")
      .replace("background", "")
      .trim();
  cardFront.style = "background-image:" + bgStyle;

  const rarityValue = (typeof card.rarity === "string") ? card.rarity.replace("★", "").trim() : "0";
  cardFront.innerHTML = `<div class='bezel rarity${rarityValue}'></div>`;

  const typeEl = document.createElement("div");
  typeEl.className = "card-type";
  typeEl.textContent = card.type || "不明";
  cardFront.appendChild(typeEl);

  const imageContainer = document.createElement("div");
  imageContainer.className = "card-image";
  if(card.imageData){
    const imageEl = document.createElement("img");
    imageEl.src = card.imageData;
    imageEl.alt = card.name;
    imageContainer.appendChild(imageEl);
  }
  cardFront.appendChild(imageContainer);

  const infoContainer = document.createElement("div");
  infoContainer.className = "card-info";

  const nameEl = document.createElement("p");
  nameEl.innerHTML = "<h3>" + DOMPurify.sanitize(card.name) + "</h3>";
  infoContainer.appendChild(nameEl);

  if (card.state) {
    const stateEl = document.createElement("p");
    stateEl.innerHTML = "<strong>状態：</strong>" + DOMPurify.sanitize(card.state);
    infoContainer.appendChild(stateEl);
  }
  const specialEl = document.createElement("p");
  specialEl.innerHTML = "<strong>特技：</strong>" + DOMPurify.sanitize(card.special);
  infoContainer.appendChild(specialEl);

  const captionEl = document.createElement("p");
  captionEl.innerHTML = "<span>" + DOMPurify.sanitize(card.caption) + "</span>";
  infoContainer.appendChild(captionEl);

  cardFront.appendChild(infoContainer);

  const cardBack = document.createElement("div");
  cardBack.className = "card-back";
  cardBack.innerHTML = `<strong>${DOMPurify.sanitize(card.type)}</strong>`;

  cardInner.appendChild(cardFront);
  cardInner.appendChild(cardBack);
  cardEl.appendChild(cardInner);

  return cardEl;
}

/** パーティへ入れるボタンの表示・非表示制御（倉庫側） */
function updateWarehouseAddButtonVisibility(){
  const addBtn = document.getElementById("add-to-party-btn");
  if(!warehouseSelectionMode) {
    // 選択モードOFF時は非表示
    addBtn.style.display = "none";
    return;
  }
  // 選択モードON
  const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
  if(selectedCards.length > 0){
    addBtn.style.display = "inline-block";
  } else {
    addBtn.style.display = "none";
  }
}

/** 倉庫に戻すボタンの表示・非表示制御（パーティ側） */
function updatePartyMoveButtonVisibility(){
  const moveBtn = document.getElementById("move-selected-to-warehouse-btn");
  if(!partySelectionMode){
    moveBtn.style.display = "none";
    return;
  }
  const selectedCards = document.querySelectorAll(
    "#avatar-card-container .card.selected, " +
    "#partner-card-container .card.selected, " +
    "#party-card-container .card.selected"
  );
  if(selectedCards.length > 0) {
    moveBtn.style.display = "inline-block";
  } else {
    moveBtn.style.display = "none";
  }
}
--- 
scenarioPage.js 
/********************************
 * scenarioPage.js
 * - 「セクション」情報や「導入シーン」を可視化
 * - 「全セクションを閲覧する」ボタンでZIP解凍して表示
 * - 冒頭シーン(最初にDBへ登録されたscene)も履歴に出る
 ********************************/

window.addEventListener("load", async () => {
  // IndexedDB初期化 & characterDataロード
  await initIndexedDB();
  const storedChars = await loadCharacterDataFromIndexedDB();
  if (storedChars) {
    window.characterData = storedChars;
  } else {
    window.characterData = [];
  }

  // ネタバレ関連
  const spoilerModal = document.getElementById("spoiler-modal");
  const spoilerButton = document.getElementById("spoiler-button");
  const closeSpoilerModalBtn = document.getElementById("close-spoiler-modal");
  if (spoilerButton) {
    spoilerButton.addEventListener("click", () => {
      spoilerModal.style.display = "flex";
    });
  }
  if (closeSpoilerModalBtn) {
    closeSpoilerModalBtn.addEventListener("click", () => {
      spoilerModal.style.display = "none";
    });
  }

  // 「カードを取得する」ボタン
  const getCardButton = document.getElementById("get-card-button");
  if (getCardButton) {
    getCardButton.addEventListener("click", async () => {
      const sceneSummary = await getLastSceneSummary();
      let onlyTitle="";
      let onlyType="";
      let addPrompt="";

      const lines = sceneSummary.split("\n");
      lines.forEach(line=>{
        const t=line.trim();
        if(t.startsWith("【名前】")){
          onlyTitle=t.replace("【名前】","").replace("：","").trim();
        } else if(t.startsWith("【タイプ】")){
          onlyType=t.replace("【タイプ】","").replace("：","").trim();
        } else if(t.startsWith("【外見】")){
          addPrompt=t.replace("【外見】","").replace("：","").trim();
        }
      });

      const previewModal = document.getElementById("card-preview-modal");
      const previewContainer = document.getElementById("preview-card-container");
      if(!previewModal||!previewContainer)return;

      previewContainer.innerHTML="";
      const p=document.createElement("p");
      p.textContent=
        `【名前】：${onlyTitle}\n【タイプ】：${onlyType}\n【外見】：${addPrompt}\nこの内容で作成しますか？`;
      p.style.whiteSpace="pre-wrap";
      previewContainer.appendChild(p);

      previewModal.style.display="flex";

      const addBtn = document.getElementById("add-to-gachabox-button");
      if(addBtn){
        addBtn.onclick=async()=>{
          previewModal.style.display="none";
          const gachaModal=document.getElementById("gacha-modal");
          if(gachaModal) gachaModal.style.display="flex";

          try{
            await runGacha(1,addPrompt,onlyTitle,onlyType);
            alert("ガチャ箱に追加しました。");
          }catch(e){
            console.error(e);
            alert("カード生成失敗:"+e.message);
          }finally{
            if(gachaModal) gachaModal.style.display="none";
          }
        };
      }
      const cancelBtn = document.getElementById("cancel-card-preview-button");
      if(cancelBtn){
        cancelBtn.onclick=()=>{
          previewModal.style.display="none";
        };
      }
    });
  }

  // 回答候補を生成
  const generateActionCandidatesBtn = document.getElementById("generate-action-candidates-button");
  if(generateActionCandidatesBtn){
    generateActionCandidatesBtn.addEventListener("click", onGenerateActionCandidates);
  }

  // パーティモーダル
  const showPartyBtn = document.getElementById("show-party-button");
  if(showPartyBtn){
    showPartyBtn.addEventListener("click", showPartyModal);
  }
  const closePartyModalBtn = document.getElementById("close-party-modal");
  if(closePartyModalBtn){
    closePartyModalBtn.addEventListener("click",()=>{
      const modal = document.getElementById("party-modal");
      if(modal) modal.style.display="none";
    });
  }

  // 全セクション閲覧
  const viewAllSectionsBtn = document.getElementById("view-all-sections-button");
  if(viewAllSectionsBtn){
    viewAllSectionsBtn.addEventListener("click", showAllSectionsModal);
  }
  const closeAllSecBtn = document.getElementById("close-all-sections-modal");
  if(closeAllSecBtn){
    closeAllSecBtn.addEventListener("click",()=>{
      document.getElementById("all-sections-modal").style.display="none";
    });
  }
});

/** 回答候補 */
async function onGenerateActionCandidates(){
  if(!window.apiKey){
    alert("APIキー未設定");
    return;
  }
  const lastSceneEntry = [...window.sceneHistory].reverse().find(e=> e.type==="scene");
  const lastSceneText = lastSceneEntry? lastSceneEntry.content : "(シーン無し)";

  window.cancelRequested=false;
  showLoadingModal(true);

  try{
    window.currentRequestController=new AbortController();
    const signal=window.currentRequestController.signal;

    const prompt=`
      あなたはTRPGのGMです。
      下記シーンを踏まえ、プレイヤーが可能な行動案を5つ提案してください。
      ---
      ${lastSceneText}
    `;
    const resp=await fetch("https://api.openai.com/v1/chat/completions",{
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization":`Bearer ${window.apiKey}`
      },
      body:JSON.stringify({
        model:"gpt-4",
        messages:[
          { role:"system", content:"あなたは優秀なTRPGアシスタント" },
          { role:"user", content:prompt }
        ],
        temperature:0.7
      }),
      signal
    });
    const data=await resp.json();
    if(data.error) throw new Error(data.error.message);

    const content = data.choices[0].message.content||"";
    const lines = content.split("\n").map(l=>l.trim()).filter(l=>l);

    const container = document.getElementById("action-candidates-container");
    if(!container)return;
    container.innerHTML="";

    lines.forEach(line=>{
      const btn=document.createElement("button");
      btn.textContent=line.replace(/^\d+\.\s*/,"");
      btn.style.display="block";
      btn.style.margin="5px 0";
      btn.addEventListener("click",()=>{
        const playerInput=document.getElementById("player-input");
        if(playerInput){
          playerInput.value=btn.textContent;
        }
      });
      container.appendChild(btn);
    });
  }catch(e){
    if(e.name==="AbortError"){
      console.log("候補生成キャンセル");
    } else {
      console.error(e);
      alert("候補生成失敗:"+e.message);
    }
  }finally{
    showLoadingModal(false);
  }
}

/** 全セクション表示モーダル */
function showAllSectionsModal(){
  const modal=document.getElementById("all-sections-modal");
  if(!modal)return;

  // scenario.jsの loadScenarioData() で window.currentScenario.wizardData が格納済み
  const wd = (window.currentScenario && window.currentScenario.wizardData)||{};
  const sections = wd.sections||[];

  const container=document.getElementById("all-sections-content");
  container.textContent="";

  if(!sections.length){
    container.textContent="セクション情報がありません。";
  } else {
    let text="";
    for(const sec of sections){
      text += `【セクション${sec.number}】`+(sec.cleared?"(クリア済み)":"(未クリア)")+"\n";
      text += "条件: "+(decompressCondition(sec.conditionZipped))+"\n\n";
    }
    container.textContent=text;
  }

  modal.style.display="flex";
}

/** ZIP解凍 */
function decompressCondition(zippedBase64){
  if(!zippedBase64)return"(不明)";
  try{
    const bin=atob(zippedBase64);
    const uint8=new Uint8Array([...bin].map(c=>c.charCodeAt(0)));
    const inf=pako.inflate(uint8);
    return new TextDecoder().decode(inf);
  }catch(e){
    console.error("decompress失敗:",e);
    return"(解凍エラー)";
  }
}

/** パーティ確認モーダル */
function showPartyModal(){
  const modal=document.getElementById("party-modal");
  if(!modal)return;
  modal.style.display="flex";

  renderPartyCardsInModal();
}
function renderPartyCardsInModal(){
  const container=document.getElementById("party-modal-card-container");
  if(!container)return;
  container.innerHTML="";

  const partyCards=window.characterData.filter(c=>c.group==="Party");
  if(!partyCards.length){
    container.textContent="パーティにカードがありません。";
    return;
  }
  partyCards.forEach(card=>{
    const cardEl=createPartyCardElement(card);
    container.appendChild(cardEl);
  });
}
function createPartyCardElement(c){
  const cardEl=document.createElement("div");
  cardEl.className="card";
  cardEl.setAttribute("data-id",c.id);
  cardEl.addEventListener("click",()=>{
    cardEl.classList.toggle("flipped");
  });

  const cardInner=document.createElement("div");
  cardInner.className="card-inner";

  const cf=document.createElement("div");
  cf.className="card-front";

  const bg=(c.backgroundcss||"").replace("background-image:","").replace("background","").trim();
  cf.style="background-image:"+bg;

  const rv=(typeof c.rarity==="string")? c.rarity.replace("★","").trim() : "0";
  cf.innerHTML=`<div class='bezel rarity${rv}'></div>`;

  let roleLabel="";
  if(c.role==="avatar") roleLabel="(アバター)";
  else if(c.role==="partner") roleLabel="(パートナー)";

  const tEl=document.createElement("div");
  tEl.className="card-type";
  tEl.textContent=(c.type||"不明")+roleLabel;
  cf.appendChild(tEl);

  const imgCont=document.createElement("div");
  imgCont.className="card-image";
  if(c.imageData){
    const im=document.createElement("img");
    im.src=c.imageData;
    im.alt=c.name;
    imgCont.appendChild(im);
  }
  cf.appendChild(imgCont);

  const info=document.createElement("div");
  info.className="card-info";

  const nm=document.createElement("p");
  nm.innerHTML="<h3>"+DOMPurify.sanitize(c.name)+"</h3>";
  info.appendChild(nm);

  if(c.state){
    const st=document.createElement("p");
    st.innerHTML="<strong>状態：</strong>"+DOMPurify.sanitize(c.state);
    info.appendChild(st);
  }

  const sp=document.createElement("p");
  sp.innerHTML="<strong>特技：</strong>"+DOMPurify.sanitize(c.special);
  info.appendChild(sp);

  const cap=document.createElement("p");
  cap.innerHTML="<span>"+DOMPurify.sanitize(c.caption)+"</span>";
  info.appendChild(cap);

  cf.appendChild(info);

  const cb=document.createElement("div");
  cb.className="card-back";
  cb.innerHTML=`<strong>${DOMPurify.sanitize(c.type)}</strong>`;

  cardInner.appendChild(cf);
  cardInner.appendChild(cb);
  cardEl.appendChild(cardInner);
  return cardEl;
}

/** シーン要約からカード用【名前】【タイプ】【外見】を得る */
async function getLastSceneSummary(){
  const lastSceneEntry=[...window.sceneHistory].reverse().find(e=>e.type==="scene");
  if(!lastSceneEntry) return "シーンがありません。";

  const text=lastSceneEntry.content;
  const systemPrompt=`
あなたは優秀なカード作成用プロンプト生成者。
以下フォーマットで【名前】【タイプ】【外見】を作ってください。`;
  const userPrompt=`
シーン文:
${text}
ここからエレメントにできそうな対象1つを抽出し、【名前】【タイプ】【外見】を生成してください。
`;

  try{
    const resp=await fetch("https://api.openai.com/v1/chat/completions",{
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization":`Bearer ${window.apiKey}`
      },
      body:JSON.stringify({
        model:"gpt-4",
        messages:[
          { role:"system", content: systemPrompt },
          { role:"user", content: userPrompt }
        ]
      })
    });
    const data=await resp.json();
    if(data.error) throw new Error(data.error.message);

    return data.choices[0].message.content||"";
  }catch(e){
    console.error("要約失敗:",e);
    return"(要約失敗)";
  }
}

/** ローディング表示 */
function showLoadingModal(show){
  const m=document.getElementById("loading-modal");
  if(!m)return;
  m.style.display=show?"flex":"none";
}
function onCancelFetch(){
  if(window.currentRequestController){
    window.currentRequestController.abort();
  }
  showLoadingModal(false);
}
--- 
scenarioWizard.js 
/********************************
 * scenarioWizard.js
 * 新しいシナリオ作成ウィザード
 *  - シナリオ概要
 *  - 導入シーン(冒頭部分)
 *  - セクション生成(2〜5個ランダム)
 *    * 達成条件は「動詞を使った形式(～を入手する/～に行く 等)」で生成するようプロンプトを修正
 ********************************/

let wizardData = {
  genre: "",
  scenarioType: "",
  clearCondition: "",
  scenarioSummary: "",
  introScene: "",   // ★冒頭シーン
  party: [],
  sections: []      // セクション配列
};

window.addEventListener("load", async function () {
  // IndexedDB初期化
  await initIndexedDB();

  // 既存wizardDataあればロード
  const storedWizard = await loadWizardDataFromIndexedDB();
  if (storedWizard) {
    wizardData = storedWizard;
  }

  // 画面更新
  updateSelectedGenreDisplay();
  updateSummaryUI();

  // イベント設定
  document.getElementById("generate-genre-button").addEventListener("click", onGenerateGenre);
  document.getElementById("clear-genre-button").addEventListener("click", onClearGenre);
  document.getElementById("confirm-genre-button").addEventListener("click", onConfirmGenre);

  document.getElementById("type-objective-btn").addEventListener("click", () => onSelectScenarioType("objective"));
  document.getElementById("type-exploration-btn").addEventListener("click", () => onSelectScenarioType("exploration"));

  document.getElementById("back-to-step1-button").addEventListener("click", onBackToStep1);
  document.getElementById("back-to-step2-button").addEventListener("click", onBackToStep2FromStep3);

  document.getElementById("start-scenario-button").addEventListener("click", onStartScenario);
  document.getElementById("cancel-request-button").addEventListener("click", onCancelFetch);

  document.getElementById("confirm-scenario-ok").addEventListener("click", onConfirmScenarioModalOK);
  document.getElementById("confirm-scenario-cancel").addEventListener("click", onConfirmScenarioModalCancel);
});

/* ---------------------------
   ステップ1：ジャンル選択
--------------------------- */
async function onGenerateGenre() {
  const genreListDiv = document.getElementById("genre-list");
  const apiKey = localStorage.getItem("apiKey") || "";
  if (!apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }

  showLoadingModal(true);
  window.currentRequestController = new AbortController();
  const signal = window.currentRequestController.signal;

  genreListDiv.innerHTML = "";

  try {
    const messages = [
      { role: "system", content: "あなたはTRPGのプロ。ジャンルを5つ提案してください。" },
      {
        role: "user",
        content: "SF, 中世ファンタジー, 現代などTRPGに使えるジャンル候補を5つ、箇条書きで。"
      }
    ];
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization":`Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages,
        temperature: 0.7
      }),
      signal
    });

    const data = await response.json();
    if (data.error) throw new Error(data.error.message);

    const content = data.choices[0].message.content;
    const lines = content.split("\n").map(l=>l.trim()).filter(l=>l);

    lines.forEach(line => {
      const btn = document.createElement("button");
      btn.classList.add("candidate-button");
      btn.textContent = line.replace(/^\d+\.\s*/, "");
      btn.style.display = "block";
      btn.style.margin = "5px 0";

      btn.addEventListener("click", async () => {
        wizardData.genre = btn.textContent;
        await saveWizardDataToIndexedDB(wizardData);
        highlightSelectedButton(genreListDiv, btn);

        document.getElementById("wizard-step1").style.display = "none";
        document.getElementById("wizard-step2").style.display = "block";
        updateSelectedGenreDisplay();
      });
      genreListDiv.appendChild(btn);
    });
  } catch(err) {
    console.error(err);
    alert("ジャンル生成に失敗: " + err.message);
  } finally {
    showLoadingModal(false);
  }
}

async function onClearGenre(){
  const genreListDiv = document.getElementById("genre-list");
  genreListDiv.innerHTML = "";
  wizardData.genre = "";
  await saveWizardDataToIndexedDB(wizardData);
  document.getElementById("free-genre-input").value = "";
}

async function onConfirmGenre(){
  const freeInput = document.getElementById("free-genre-input");
  const val = (freeInput.value || "").trim();
  if(!val){
    alert("ジャンルを入力してください。");
    return;
  }
  wizardData.genre = val;
  await saveWizardDataToIndexedDB(wizardData);

  document.getElementById("wizard-step1").style.display = "none";
  document.getElementById("wizard-step2").style.display = "block";
  updateSelectedGenreDisplay();
}

/* ---------------------------
   ステップ2：シナリオタイプ
--------------------------- */
async function onSelectScenarioType(type){
  wizardData.scenarioType = type;
  await saveWizardDataToIndexedDB(wizardData);

  const textEl = document.getElementById("confirm-genre-type-text");
  textEl.textContent = `ジャンル:${wizardData.genre}\nシナリオタイプ:${type}`;

  const modal = document.getElementById("confirm-scenario-modal");
  modal.style.display = "flex";
}

function onConfirmScenarioModalCancel(){
  const modal = document.getElementById("confirm-scenario-modal");
  modal.style.display = "none";
}

async function onConfirmScenarioModalOK(){
  const modal = document.getElementById("confirm-scenario-modal");
  modal.style.display = "none";

  // シナリオ要約生成前にパーティ情報を取り込む
  await storePartyInWizardData();

  // シナリオ概要
  if(wizardData.scenarioType==="objective"){
    await generateScenarioSummaryAndClearCondition();
  } else {
    await generateScenarioSummary();
  }

  // セクション(達成条件)生成
  await generateSections();

  // 導入文
  await generateIntroScene();

  // ステップ2→ステップ3
  document.getElementById("wizard-step2").style.display = "none";
  document.getElementById("wizard-step3").style.display = "block";
}

function onBackToStep1(){
  document.getElementById("wizard-step2").style.display = "none";
  document.getElementById("wizard-step1").style.display = "block";
}

/* ---------------------------
   ステップ3：最終確認(シナリオ要約表示)
--------------------------- */
function onBackToStep2FromStep3(){
  document.getElementById("wizard-step3").style.display = "none";
  document.getElementById("wizard-step2").style.display = "block";
}

async function onStartScenario(){
  try {
    let title = wizardData.genre || "新シナリオ";
    const scenarioId = await createNewScenario(wizardData, title);

    // ★もし冒頭文があれば最初のsceneとして登録
    if(wizardData.introScene && wizardData.introScene.trim()){
      const firstScene = {
        scenarioId,
        type:"scene",
        sceneId: "intro_"+Date.now(),
        content: wizardData.introScene
      };
      await addSceneEntry(firstScene);
    }

    window.location.href = `scenario.html?scenarioId=${scenarioId}`;
  } catch(err) {
    console.error("シナリオ作成失敗:", err);
    alert("シナリオ開始失敗: " + err.message);
  }
}

/* ---------------------------
   GPT呼び出しで概要やセクション達成条件、導入文を生成
--------------------------- */
async function generateScenarioSummaryAndClearCondition(){
  showLoadingModal(true);
  window.currentRequestController = new AbortController();
  const signal = window.currentRequestController.signal;

  try {
    const apiKey = localStorage.getItem("apiKey")||"";
    if(!apiKey) throw new Error("APIキーが未設定");

    wizardData.scenarioSummary = "";
    wizardData.clearCondition = "";

    const prompt = `
      あなたはTRPG用のシナリオ作成に長けたアシスタントです。
      ジャンル:${wizardData.genre}, タイプ:目的達成型。
      1) シナリオ概要(短め)
      2) 【クリア条件】(非公開,プレイヤー非表示)。必ず明示してください。
    `;
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization":`Bearer ${apiKey}`
      },
      body:JSON.stringify({
        model:"gpt-4",
        messages:[
          { role:"system", content:"あなたは優秀なTRPGシナリオメーカーです。" },
          { role:"user", content: prompt }
        ],
        temperature:0.7
      }),
      signal
    });
    const data = await resp.json();
    if(data.error) throw new Error(data.error.message);

    const text = data.choices[0].message.content||"";
    let sum = text;
    let cc = "";
    if(text.includes("【クリア条件】")){
      const arr = text.split("【クリア条件】");
      sum = arr[0].trim();
      cc = arr[1]? arr[1].trim() : "";
    }
    wizardData.scenarioSummary = sum;
    wizardData.clearCondition = cc;

    await saveWizardDataToIndexedDB(wizardData);
    updateSummaryUI();
  } catch(err){
    console.error(err);
    alert("目的達成型シナリオ生成失敗: "+err.message);
  } finally {
    showLoadingModal(false);
  }
}

async function generateScenarioSummary(){
  showLoadingModal(true);
  window.currentRequestController = new AbortController();
  const signal = window.currentRequestController.signal;

  try {
    const apiKey = localStorage.getItem("apiKey")||"";
    if(!apiKey) throw new Error("APIキーが未設定");

    wizardData.scenarioSummary = "";

    const prompt = `
      あなたはTRPGシナリオ作成のプロ。ジャンル:${wizardData.genre}, タイプ:探索型。
      エレメント取得可能。短めの概要を作ってください。
    `;
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization":`Bearer ${apiKey}`
      },
      body:JSON.stringify({
        model:"gpt-4",
        messages:[
          { role:"system", content:"あなたは優秀なTRPGシナリオメーカーです。" },
          { role:"user", content: prompt }
        ],
        temperature:0.7
      }),
      signal
    });
    const data = await resp.json();
    if(data.error) throw new Error(data.error.message);

    wizardData.scenarioSummary = data.choices[0].message.content||"(概要なし)";
    await saveWizardDataToIndexedDB(wizardData);
    updateSummaryUI();
  } catch(err){
    console.error(err);
    alert("探索型シナリオ生成失敗: "+err.message);
  } finally {
    showLoadingModal(false);
  }
}

/**
 * セクション(達成条件)を生成 (2〜5個)
 * ※必ず動詞を用いた条件文にするようにプロンプトを修正
 */
async function generateSections(){
  wizardData.sections = [];
  const count = Math.floor(Math.random()*4)+2; //2..5

  // ★修正: 「動詞で書いてください」と強制
  const systemPrompt = `
あなたはTRPGシナリオを小分けにして目標を作るエキスパートです。
絶対に動詞を用いた条件文で書いてください(例:「XXを発見する」「XXを調べる」「XXと会う」など)。
セクション数:${count}個、それぞれ1行ずつ動詞で始まるようお願いします。`;

  const userPrompt = `
ジャンル:${wizardData.genre}, シナリオタイプ:${wizardData.scenarioType} 用のセクション達成条件:
- 例：「封印を解く」「古文書を読む」「ボスを倒す」etc
必ず動詞～で書いてください。${count}個分、箇条書きで。
それぞれの達成条件は独立させてください。連続性を持たせないでください。
「相手から反応を引き出す」のような曖昧な達成条件は望ましくありません。
`;

  try {
    const apiKey = localStorage.getItem("apiKey")||"";
    if(!apiKey) throw new Error("APIキーが未設定");

    const r = await fetch("https://api.openai.com/v1/chat/completions", {
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization":`Bearer ${apiKey}`
      },
      body:JSON.stringify({
        model:"gpt-4",
        messages:[
          { role:"system", content: systemPrompt },
          { role:"user", content: userPrompt }
        ],
        temperature:0.7
      })
    });

    const d = await r.json();
    if(d.error) throw new Error(d.error.message);

    const text = d.choices[0].message.content||"";
    const lines = text.split("\n").map(v=>v.trim()).filter(v=>v);
    for(let i=0;i<count;i++){
      const raw = lines[i]||(`セクション${i+1}のダミー条件(動詞)`);
      wizardData.sections.push({
        number:(i+1),
        conditionZipped: zipString(raw),
        cleared:false
      });
    }
  } catch(err){
    console.error("セクション生成失敗:",err);
    // ダミー
    for(let i=0;i<count;i++){
      wizardData.sections.push({
        number:(i+1),
        conditionZipped: zipString(`セクション${i+1}のダミー(動詞形)`),
        cleared:false
      });
    }
  }
  await saveWizardDataToIndexedDB(wizardData);
}

/** pakoでZIP圧縮→Base64 */
function zipString(str){
  const utf8 = new TextEncoder().encode(str);
  const def = pako.deflate(utf8);
  return btoa(String.fromCharCode(...def));
}

/** 導入シーン(冒頭)を生成 */
async function generateIntroScene(){
  const apiKey = localStorage.getItem("apiKey")||"";
  if(!apiKey){
    console.warn("APIキー無し → 導入シーン生成スキップ");
    wizardData.introScene = "(導入生成失敗)";
    await saveWizardDataToIndexedDB(wizardData);
    return;
  }

  try{
    const pro = `
      あなたはTRPGのゲームマスターです。
      次のシナリオ概要を踏まえ、プレイヤーが行動したくなる導入シーン(300字程度)を作ってください。
      シナリオ概要:
      ${wizardData.scenarioSummary}
    `;
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization":`Bearer ${apiKey}`
      },
      body:JSON.stringify({
        model:"gpt-4",
        messages:[
          { role:"system", content:"あなたは優秀なTRPGシナリオライターです。" },
          { role:"user", content: pro }
        ],
        temperature:0.7
      })
    });
    const data = await resp.json();
    if(data.error) throw new Error(data.error.message);

    wizardData.introScene = data.choices[0].message.content||"(導入空)";
  } catch(err){
    console.error(err);
    wizardData.introScene="(導入生成失敗)";
  }
  await saveWizardDataToIndexedDB(wizardData);
}

/* ---------------------------
   汎用
--------------------------- */
function updateSelectedGenreDisplay(){
  const el = document.getElementById("selected-genre-display");
  if(!el)return;
  el.textContent = wizardData.genre||"(未選択)";
}

function updateSummaryUI(){
  const el = document.getElementById("scenario-summary");
  if(!el)return;
  el.textContent = wizardData.scenarioSummary||"(シナリオ概要なし)";
}

async function storePartyInWizardData(){
  const charData = await loadCharacterDataFromIndexedDB();
  if(!charData)return;

  const party = charData.filter(c=>c.group==="Party");
  // imageDataなどを落としておく
  const stripped = party.map(c=>({
    id:c.id, name:c.name, type:c.type,
    rarity:c.rarity, state:c.state, special:c.special,
    caption:c.caption, backgroundcss:c.backgroundcss
  }));
  wizardData.party = stripped;
  await saveWizardDataToIndexedDB(wizardData);
}

function highlightSelectedButton(container, targetBtn){
  const all = container.querySelectorAll(".candidate-button");
  all.forEach(b=>b.style.backgroundColor="");
  targetBtn.style.backgroundColor="#8BC34A";
}

function showLoadingModal(show){
  const modal = document.getElementById("loading-modal");
  if(!modal)return;
  modal.style.display = show?"flex":"none";
}

function onCancelFetch(){
  if(window.currentRequestController){
    window.currentRequestController.abort();
  }
  showLoadingModal(false);
}
--- 
scene.js 
/********************************
 * scene.js
 * シナリオ/シーン管理
 *  - シーン生成後、ChatGPTに「未クリアセクションが達成されたか」を問い合わせる機能を追加
 ********************************/

window.apiKey = '';
window.sceneHistory = [];
window.currentScenarioId = null;
window.currentScenario = null;
window.currentRequestController = null;
window.cancelRequested = false;

window.scenarioType = null;
window.clearCondition = null;
window.sections = [];

/** DBからシナリオ情報を読み込み */
async function loadScenarioData(scenarioId){
  try{
    const sc = await getScenarioById(scenarioId);
    if(!sc){
      alert("指定シナリオが存在しません。");
      return;
    }
    window.currentScenario = sc;

    const wd = sc.wizardData || {};
    window.scenarioType = wd.scenarioType;
    window.clearCondition = wd.clearCondition || "";
    window.sections = wd.sections || [];

    const ents = await getSceneEntriesByScenarioId(scenarioId);
    window.sceneHistory = ents.map(e=>({
      entryId:e.entryId,
      type:e.type,
      sceneId:e.sceneId,
      content:e.content,
      dataUrl:e.dataUrl,
      prompt:e.prompt
    }));

    // ネタバレ(目的達成型)
    if(window.scenarioType==="objective"){
      const sb = document.getElementById("spoiler-button");
      if(sb) sb.style.display="inline-block";
      const sp = document.getElementById("clear-condition-text");
      if(sp) sp.textContent = window.clearCondition || "(クリア条件なし)";
    } else if(window.scenarioType==="exploration"){
      const gcb=document.getElementById("get-card-button");
      if(gcb) gcb.style.display="inline-block";
    }
  }catch(err){
    console.error("シナリオ読み込み失敗:",err);
    alert("読み込み失敗:"+err.message);
  }
}

/** 次のシーンを生成し、履歴に追加 → その後セクション達成判定を行う */
async function getNextScene(){
  if(!window.apiKey){
    alert("APIキー未設定");
    return;
  }
  const pinput = (document.getElementById("player-input")?.value || "").trim();
  const hasScene = window.sceneHistory.some(e=> e.type==="scene");
  if(hasScene && !pinput){
    alert("プレイヤー行動を入力してください");
    return;
  }

  window.cancelRequested=false;
  showLoadingModal(true);

  // システムプロンプト
  let systemText="あなたはTRPGのゲームマスターです。HTMLタグOK。";
  const msgs=[{role:"system",content:systemText}];

  // シナリオ概要 + パーティ情報
  if(window.currentScenario){
    const wd = window.currentScenario.wizardData||{};
    const summ = wd.scenarioSummary||"(概要なし)";
    msgs.push({role:"user",content:"シナリオ概要:"+summ});

    const charData = await loadCharacterDataFromIndexedDB();
    const party = charData.filter(e=> e.group==="Party");
    const ptxt = buildPartyInsertionText(party);
    msgs.push({role:"user",content:ptxt});
  }

  // これまでの履歴
  window.sceneHistory.forEach(e=>{
    if(e.type==="scene"){
      msgs.push({role:"assistant", content:e.content});
    } else if(e.type==="action"){
      msgs.push({role:"user", content:"プレイヤーの行動:"+e.content});
    }
  });

  // 今回の行動
  if(pinput){
    msgs.push({role:"user", content:"プレイヤーの行動:"+pinput});
  }

  try{
    window.currentRequestController=new AbortController();
    const signal=window.currentRequestController.signal;

    const resp=await fetch("https://api.openai.com/v1/chat/completions",{
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization":`Bearer ${window.apiKey}`
      },
      body:JSON.stringify({
        model:"gpt-4",
        messages:msgs
      }),
      signal
    });
    if(window.cancelRequested){
      showLoadingModal(false);
      return;
    }
    const data=await resp.json();
    if(window.cancelRequested){
      showLoadingModal(false);
      return;
    }
    if(data.error) throw new Error(data.error.message);

    const nextScene=data.choices[0].message.content||"";

    // (1) 行動を履歴に追加
    if(pinput){
      const act={
        scenarioId:window.currentScenarioId||0,
        type:"action",
        content:pinput,
        sceneId:null
      };
      const actId=await addSceneEntry(act);
      window.sceneHistory.push({entryId:actId,type:"action",content:pinput});
      document.getElementById("player-input").value="";
    }

    // (2) 新シーンを履歴に追加
    const sid="scene_"+Date.now();
    const se={
      scenarioId:window.currentScenarioId||0,
      type:"scene",
      sceneId:sid,
      content:nextScene
    };
    const newSid=await addSceneEntry(se);
    window.sceneHistory.push({entryId:newSid,type:"scene",sceneId:sid,content:nextScene});

    // シナリオ更新
    if(window.currentScenario){
      await updateScenario({
        ...window.currentScenario,
        updatedAt:new Date().toISOString()
      });
    }

    // ここでセクション達成チェック(チャットGPTに問い合わせ)
    // 最新の行動・シーンをまとめて GPT に渡し、「最初の未クリアセクションはクリアしましたか？」と尋ねる
    await checkSectionClearViaChatGPT(pinput, nextScene);

    // 再描画
    updateSceneHistory();
    showLastScene();

  }catch(e){
    if(e.name==="AbortError"){
      console.warn("シーン取得キャンセル");
    } else {
      console.error(e);
      alert("シーン取得失敗:"+e.message);
    }
  }finally{
    showLoadingModal(false);
  }
}

/**
 * ChatGPTに、「最小の未クリアセクションが達成されたか」を尋ねる。
 * YESなら cleared=true にして DB保存 → UI更新
 */
async function checkSectionClearViaChatGPT(latestAction, latestScene) {
  // 1) wizardData から最初の未クリアセクションを探す
  const wd = window.currentScenario?.wizardData;
  if(!wd || !wd.sections) return; // シナリオデータが無い
  const sorted = wd.sections.slice().sort((a,b)=> a.number-b.number);
  const firstUncleared = sorted.find(s=> !s.cleared);
  if(!firstUncleared) {
    // 全クリア済み
    return;
  }

  // 2) 条件テキストを解凍
  const conditionText = decompressCondition(firstUncleared.conditionZipped);

  // 3) GPTに問い合わせる: 
  //    - シナリオ概要, これまでの流れ(簡易), 今回の行動 & シーン, そして "条件Text" を提示し、
  //      「条件を満たしましたか？ YESかNOで答えてください」と質問
  const scenarioSummary = wd.scenarioSummary || "(概要なし)";
  const messages = [
    {
      role:"system",
      content:"あなたはTRPGゲームマスターのサポートAIです。回答はYESまたはNOのみでお願いします。"
    },
    {
      role:"user",
      content:`
シナリオ概要:
${scenarioSummary}

達成条件:
「${conditionText}」

最新の行動とシーン:
(行動) ${latestAction}
(シーン) ${latestScene}

この達成条件は、今の行動やシーン内容から見て、既に満たされましたか？
YESかNOのみで答えてください。判断が難しい時はYESにしてください。
`
    }
  ];

  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages,
        temperature: 0.0,  // 極力高確率でYES/NO回答に固定したい
      })
    });
    const data = await response.json();
    if(data.error) throw new Error(data.error.message);

    const answer = (data.choices[0].message.content||"").trim().toUpperCase();
    console.log("セクション判定GPT回答=", answer);

    if(answer.startsWith("YES")){
      // クリアされたとみなす
      firstUncleared.cleared = true;

      // DB保存
      window.currentScenario.wizardData.sections = wd.sections;
      await updateScenario(window.currentScenario);

      alert(`セクション${firstUncleared.number}をクリアしました。`);
    } else {
      // NO or それ以外 → 未達成
      console.log("未達成と判定されました。");
    }
  } catch(err) {
    console.error("セクション判定API失敗:", err);
    // GPT問い合わせに失敗したら何もしない
  }
}

/** シーン履歴を表示 */
function updateSceneHistory(){
  const his = document.getElementById("scene-history");
  if(!his)return;
  his.innerHTML="";

  // 未クリアセクションの最小番号を探す
  const wd = window.currentScenario?.wizardData;
  let sections = [];
  if(wd && wd.sections){
    sections = wd.sections;
  }
  const sorted=[...sections].sort((a,b)=>a.number-b.number);
  const firstUncleared = sorted.find(s=> !s.cleared);

  if(!firstUncleared && sorted.length>0){
    // 全クリア
    const tile=document.createElement("div");
    tile.className="history-tile";
    tile.textContent="シナリオ達成";
    his.appendChild(tile);
  } else if(sorted.length>0){
    // 例: セクション1～(firstUncleared.number)まで表示
    for(const s of sorted){
      if(s.number < firstUncleared.number){
        const t=document.createElement("div");
        t.className="history-tile";
        t.textContent=`セクション${s.number} (クリア済み)`;
        his.appendChild(t);
      } else if(s.number === firstUncleared.number){
        const t=document.createElement("div");
        t.className="history-tile";
        t.textContent=`セクション${s.number} (未クリア)`;
        his.appendChild(t);
      } else {
        // それより先は非表示
      }
    }
  }

  // 最後のシーンを除く行動/シーン/画像
  const lastScene=[...window.sceneHistory].reverse().find(e=> e.type==="scene");
  const skipIds=[];
  if(lastScene){
    skipIds.push(lastScene.entryId);
    window.sceneHistory.forEach(x=>{
      if(x.type==="image"&& x.sceneId===lastScene.sceneId){
        skipIds.push(x.entryId);
      }
    });
  }
  const showEntries=window.sceneHistory
    .filter(e=>!skipIds.includes(e.entryId))
    .sort((a,b)=>a.entryId-b.entryId);

  for(const e of showEntries){
    if(e.type==="scene"){
      const tile=document.createElement("div");
      tile.className="history-tile";

      const delBtn=document.createElement("button");
      delBtn.textContent="削除";
      delBtn.style.marginBottom="5px";
      delBtn.addEventListener("click",async()=>{
        const removeIds=[e.entryId];
        window.sceneHistory.forEach(x=>{
          if(x.type==="image"&&x.sceneId===e.sceneId){
            removeIds.push(x.entryId);
          }
        });
        for(const rid of removeIds){
          await deleteSceneEntry(rid);
        }
        window.sceneHistory=window.sceneHistory.filter(x=>!removeIds.includes(x.entryId));
        updateSceneHistory();
        showLastScene();
      });
      tile.appendChild(delBtn);

      const st=document.createElement("p");
      st.className="scene-text";
      st.setAttribute("contenteditable", window.apiKey?"true":"false");
      st.innerHTML=DOMPurify.sanitize(e.content);
      st.addEventListener("blur", async()=>{
        if(!window.apiKey)return;
        e.content=st.innerText.trim();
        const up={
          entryId:e.entryId,
          scenarioId:window.currentScenarioId||0,
          type:"scene",
          sceneId:e.sceneId,
          content:e.content
        };
        await updateSceneEntry(up);
      });
      tile.appendChild(st);

      his.appendChild(tile);

    } else if(e.type==="action"){
      const tile=document.createElement("div");
      tile.className="history-tile";

      const delBtn=document.createElement("button");
      delBtn.textContent="削除";
      delBtn.style.backgroundColor="#f44336";
      delBtn.style.marginBottom="5px";
      delBtn.addEventListener("click", async()=>{
        await deleteSceneEntry(e.entryId);
        window.sceneHistory=window.sceneHistory.filter(x=>x.entryId!==e.entryId);
        updateSceneHistory();
        showLastScene();
      });
      tile.appendChild(delBtn);

      const at=document.createElement("p");
      at.className="action-text";
      at.setAttribute("contenteditable", window.apiKey?"true":"false");
      at.innerHTML=DOMPurify.sanitize(e.content);
      at.addEventListener("blur", async()=>{
        if(!window.apiKey)return;
        e.content=at.innerText.trim();
        const up={
          entryId:e.entryId,
          scenarioId:window.currentScenarioId||0,
          type:"action",
          content:e.content
        };
        await updateSceneEntry(up);
      });
      tile.appendChild(at);

      his.appendChild(tile);

    } else if(e.type==="image"){
      const tile=document.createElement("div");
      tile.className="history-tile";

      const img=document.createElement("img");
      img.src=e.dataUrl;
      img.alt="生成画像";
      img.style.maxWidth="100%";
      tile.appendChild(img);

      const reBtn=document.createElement("button");
      reBtn.textContent="再生成";
      reBtn.addEventListener("click",()=>{
        if(!window.apiKey)return;
        const idx=window.sceneHistory.indexOf(e);
        if(idx>=0){
          openImagePromptModal(e.prompt, idx);
        }
      });
      tile.appendChild(reBtn);

      const delBtn=document.createElement("button");
      delBtn.textContent="画像だけ削除";
      delBtn.addEventListener("click",async()=>{
        if(!window.apiKey)return;
        await deleteSceneEntry(e.entryId);
        window.sceneHistory=window.sceneHistory.filter(x=>x.entryId!==e.entryId);
        updateSceneHistory();
        showLastScene();
      });
      tile.appendChild(delBtn);

      his.appendChild(tile);
    }
  }
  his.scrollTop=his.scrollHeight;
}

/** 最新シーンを表示 */
function showLastScene(){
  const storyDiv=document.getElementById("story");
  const lastSceneImagesDiv=document.getElementById("last-scene-images");
  if(!storyDiv||!lastSceneImagesDiv)return;

  const nextSceneBtn=document.getElementById("next-scene");
  const playerInput=document.getElementById("player-input");
  const playerActionLabel=document.getElementById("player-action");

  const lastScene=[...window.sceneHistory].reverse().find(e=>e.type==="scene");

  if(lastScene){
    storyDiv.innerHTML="";
    const st=document.createElement("p");
    st.className="scene-text";
    st.setAttribute("contenteditable", window.apiKey?"true":"false");
    st.innerHTML=DOMPurify.sanitize(lastScene.content);
    st.addEventListener("blur",async()=>{
      if(!window.apiKey)return;
      lastScene.content=st.innerText.trim();
      const up={
        entryId:lastScene.entryId,
        scenarioId:window.currentScenarioId||0,
        type:"scene",
        sceneId:lastScene.sceneId,
        content:lastScene.content
      };
      await updateSceneEntry(up);
    });
    storyDiv.appendChild(st);

    lastSceneImagesDiv.innerHTML="";
    const images=window.sceneHistory.filter(x=>x.type==="image"&& x.sceneId===lastScene.sceneId);
    images.forEach(imgEntry=>{
      const c=document.createElement("div");
      c.style.marginBottom="10px";

      const i=document.createElement("img");
      i.src=imgEntry.dataUrl;
      i.alt="シーン画像";
      i.style.maxWidth="100%";
      c.appendChild(i);

      const reBtn=document.createElement("button");
      reBtn.textContent="再生成";
      reBtn.addEventListener("click",()=>{
        if(!window.apiKey)return;
        const idx=window.sceneHistory.indexOf(imgEntry);
        if(idx>=0){
          openImagePromptModal(imgEntry.prompt, idx);
        }
      });
      c.appendChild(reBtn);

      const dBtn=document.createElement("button");
      dBtn.textContent="画像削除";
      dBtn.addEventListener("click",async()=>{
        if(!window.apiKey)return;
        await deleteSceneEntry(imgEntry.entryId);
        window.sceneHistory=window.sceneHistory.filter(x=>x.entryId!==imgEntry.entryId);
        showLastScene();
        updateSceneHistory();
      });
      c.appendChild(dBtn);

      lastSceneImagesDiv.appendChild(c);
    });

    if(window.apiKey){
      nextSceneBtn.style.display="inline-block";
      playerInput.style.display="inline-block";
      playerActionLabel.textContent="プレイヤーがどんな行動を？";
    } else {
      nextSceneBtn.style.display="none";
      playerInput.style.display="none";
      playerActionLabel.textContent="";
    }
  } else {
    // シーンが無い場合
    storyDiv.innerHTML="";
    lastSceneImagesDiv.innerHTML="";

    if(window.apiKey){
      nextSceneBtn.style.display="inline-block";
      playerInput.style.display="block";
      playerActionLabel.textContent="最初のシーンを作るため行動を入力してください。";
    } else {
      nextSceneBtn.style.display="none";
      playerInput.style.display="none";
      playerActionLabel.textContent="";
    }
  }
}

/** パーティ情報の文章を組み立て */
function buildPartyInsertionText(party){
  let txt="【パーティ編成情報】\n";
  const ava=party.find(e=>e.role==="avatar");
  if(ava){
    txt+=`アバター: ${ava.name}\n(実プレイヤー)\n\n`;
  }
  const pt=party.filter(e=>e.role==="partner");
  if(pt.length>0){
    txt+="パートナー:\n";
    pt.forEach(p=> txt+=" - "+p.name+"\n");
    txt+="\n";
  }
  const others=party.filter(e=>!e.role||e.role==="none");
  if(others.length>0){
    const cset=others.filter(x=>x.type==="キャラクター");
    const mset=others.filter(x=>x.type==="モンスター");
    const iset=others.filter(x=>x.type==="アイテム");
    if(cset.length>0){
      txt+="◆キャラクター\n";
      cset.forEach(c=> txt+=" - "+c.name+"\n");
      txt+="\n";
    }
    if(mset.length>0){
      txt+="◆モンスター\n";
      mset.forEach(m=> txt+=" - "+m.name+"\n");
      txt+="\n";
    }
    if(iset.length>0){
      txt+="◆アイテム\n";
      iset.forEach(i=> txt+=" - "+i.name+"\n");
      txt+="\n";
    }
  }
  txt+="以上を踏まえて、アバターは実プレイヤー、パートナーは味方NPCとして扱ってください。";
  return txt;
}

/** pakoで解凍 */
function decompressCondition(zippedBase64){
  if(!zippedBase64)return"(不明)";
  try{
    const bin=atob(zippedBase64);
    const uint8=new Uint8Array([...bin].map(c=> c.charCodeAt(0)));
    const inf = pako.inflate(uint8);
    return new TextDecoder().decode(inf);
  }catch(e){
    console.error("decompress失敗:",e);
    return"(解凍エラー)";
  }
}

/** ローディングモーダル表示 */
function showLoadingModal(show){
  const m=document.getElementById("loading-modal");
  if(!m)return;
  m.style.display= show?"flex":"none";
}

/** リクエストキャンセル */
function onCancelFetch(){
  window.cancelRequested=true;
  if(window.currentRequestController){
    window.currentRequestController.abort();
  }
  showLoadingModal(false);
}
--- 
