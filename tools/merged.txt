characterCreate.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>キャラクタ作成</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <!-- DOMPurify等必要なライブラリがあればここに読み込み -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
</head>
<body>
  <div class="container" style="max-width:800px;">
    <h1>キャラクタ作成</h1>
    <!-- キャラクタ関連ストレージのクリア -->
    <button id="clear-character-btn" style="background-color:#f44336;">キャラをクリア</button>
    <!-- ガチャボタン -->
    <button id="gacha-btn" style="margin:10px;">ガチャ</button>

    <!-- ガチャ実行中モーダル -->
    <div id="gacha-modal" class="modal" style="display:none;">
      <div class="modal-content">
        <p>生成中...</p>
        <button id="cancel-gacha-btn">キャンセル</button>
      </div>
    </div>

    <!-- 生成されたカード表示領域 -->
    <div id="card-container" style="display:flex; flex-wrap:wrap; gap:10px; margin-top:20px;"></div>

    <!-- メニューボタン -->
    <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>
  </div>

  <script src="indexedDB.js"></script>
  <script src="characterCreate.js"></script>
  <script>
    // メニューに戻るボタン
    document.getElementById("back-to-menu").addEventListener("click", function () {
      window.location.href = "index.html";
    });
  </script>
</body>
</html>
--- 
index.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>TRPG メニュー</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="container" style="text-align:center; margin-top:50px;">
    <h1>TRPG メニュー</h1>
    <div class="api-key-section">
      <label for="api-key-input">ChatGPT APIキーを入力：</label>
      <input type="text" id="api-key-input" placeholder="APIキーを入力" />
      <button id="set-api-key-button">APIキー設定</button>
      <button id="clear-api-key-button" style="background-color:#f44336;">APIキーをクリア</button>
    </div>
    <!-- キャラクタ作成ボタン有効化 -->
    <button id="character-create" style="margin:10px;">キャラクタ作成</button>
    <button id="party-create" disabled style="margin:10px; cursor:not-allowed;">パーティ作成</button>
    <button id="scenario" style="margin:10px;">シナリオ</button>
  </div>

  <!-- 外部JavaScript -->
  <script src="menu.js"></script>
  <script>
    // キャラクタ作成ボタン押下時、characterCreate.htmlへ遷移
    document.getElementById("character-create").addEventListener("click", function () {
      window.location.href = "characterCreate.html";
    });
  </script>
</body>
</html>
--- 
scenario.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>シンプルTRPG</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
</head>
<body>
  <!-- 履歴をクリア -->
  <button id="clear-history-button" style="margin-top:20px;">履歴をクリア</button>

  <!-- 新たに戻るボタンを追加 -->
  <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>

  <div class="container">
    <!-- シーン履歴やその他のセクション -->
    <div id="scene-history" class="scene-history"></div>
    
    <!-- シナリオ入力セクション -->
    <div class="input-section">
      <label for="scenario-input">シナリオを入力してください：</label>
      <textarea id="scenario-input" rows="6" placeholder="シナリオを入力..."></textarea>
      <button id="start-button">ゲーム開始</button>
    </div>

    <!-- ゲーム画面セクション -->
    <div class="game-section" style="display:none;">
      <div id="story" style="margin-bottom:20px;"></div>
      <div id="last-scene-images" style="margin-bottom:20px;"></div>
      <div>
        <button id="image-auto-generate-button">自動生成(現シーンから)</button>
        <button id="image-prompt-modal-button">編集して生成(カスタム)</button>
      </div>
      <div id="player-action" style="margin-top:20px;"></div>
      <textarea id="player-input" rows="4" placeholder="プレイヤーの行動を入力..."></textarea>
      <button id="next-scene" style="display:none; margin-top:10px;">次のシーン</button>
    </div>
  </div>

  <!-- 応答待ちモーダル -->
  <div id="loading-modal" class="modal" style="display:none;">
    <div class="modal-content">
      <p>応答を待っています...</p>
      <button id="cancel-request-button">キャンセル</button>
    </div>
  </div>

  <!-- カスタム画像生成モーダル -->
  <div id="image-prompt-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:400px;">
      <p>画像生成のプロンプトを編集してください</p>
      <textarea id="image-custom-prompt" rows="5" style="width:100%;"></textarea>
      <div style="margin-top:10px;">
        <button id="image-custom-generate-button">生成</button>
        <button id="image-custom-cancel-button">キャンセル</button>
      </div>
    </div>
  </div>

  <!-- スクリプトの読み込み -->
  <script src="indexedDB.js"></script>
  <script src="scene.js"></script>
  <script src="image.js"></script>
  <script src="main.js"></script>

  <!-- メニューに戻るボタン用のスクリプト -->
  <script>
    document.getElementById("back-to-menu").addEventListener("click", function() {
      window.location.href = "index.html";
    });
  </script>
</body>
</html>
--- 
styles.css 
/* styles.css */

/* ベース */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f5f5f5;
}

.container {
  max-width: 1000px;
  margin: 20px auto;
  padding: 20px;
  background-color: #fff;
  box-shadow: 0 0 10px rgba(0,0,0,0.1);
}

h1 {
  text-align: center;
}
h2 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

.api-key-section {
  margin-bottom:20px;
}

input, textarea {
  width:100%;
  padding:10px;
  font-size:14px;
  border:1px solid #ccc;
  border-radius:4px;
}

button {
  padding:10px 20px;
  background-color:#4CAF50;
  color:#fff;
  border:none;
  border-radius:4px;
  cursor:pointer;
  margin-bottom:10px;
}
button:hover {
  background-color:#45a049;
}

/* シーン履歴 */
.scene-history {
  max-height:300px;
  overflow-y:auto;
  border:1px solid #ddd;
  padding:10px;
  background-color:#f9f9f9;
  display:flex;
  flex-direction:column;
  gap:10px;
  margin-bottom:20px;
}

.history-tile {
  padding:10px;
  border:1px solid #ccc;
  background-color:#fff;
  border-radius:5px;
  box-shadow:0 2px 4px rgba(0,0,0,0.1);
}

/* テキスト編集領域 */
.scene-text,
.action-text,
.scenario-text {
  margin:0;
  padding:5px;
  font-size:14px;
  border:1px dashed transparent;
  cursor:text;
}
.scene-text[contenteditable]:focus,
.action-text[contenteditable]:focus,
.scenario-text[contenteditable]:focus {
  border:1px dashed #4CAF50;
  outline:none;
}

/* メイン表示するシーン部分 */
#story {
  font-size:1.4rem;
  padding-bottom:10px;
  border-bottom:1px solid #ccc;
  min-height:60px;
}

/* モーダル */
.modal {
  position: fixed;
  top:0; left:0;
  width:100%;
  height:100%;
  background-color:rgba(0,0,0,0.5);
  display:none;
  justify-content:center;
  align-items:center;
  z-index:9999;
}
.modal-content {
  background-color:#fff;
  padding:20px 40px;
  border-radius:5px;
  text-align:center;
  max-height:80vh;
  overflow-y:auto;
}

/* キャラクタカード用 */
.card {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  padding: 10px;
  margin-bottom: 10px;
}--- 
backToMenu.js 
document.getElementById("back-to-menu").addEventListener("click", function () {
    window.location.href = "index.html";
});
--- 
characterCreate.js 
// characterCreate.js

// グローバル変数
window.apiKey = localStorage.getItem("apiKey") || "";

// ※キャラクタ情報の保存形式は [{name, state, special, caption, imageData?}, ...]

// キャラクタ関連ストレージ（IndexedDB）の読み込み
window.characterData = [];

window.addEventListener("load", async function () {
    // IndexedDBの初期化を待ってからキャラクターデータをロード
    await initIndexedDB();
    const stored = await loadCharacterDataFromIndexedDB();
    if (stored) {
        window.characterData = stored;
        displayCharacterCards(window.characterData);
    }
});

/** キャラクタ関連データをクリア */
document.getElementById("clear-character-btn").addEventListener("click", async function () {
    const ok = confirm("キャラクタ情報をクリアします。よろしいですか？");
    if (ok) {
        window.characterData = [];
        // IndexedDB からも削除
        await saveCharacterDataToIndexedDB(window.characterData);
        document.getElementById("card-container").innerHTML = "";
        alert("キャラクタ情報をクリアしました。");
    }
});

/** ガチャボタン押下 */
document.getElementById("gacha-btn").addEventListener("click", function () {
    // モーダル表示
    document.getElementById("gacha-modal").style.display = "flex";
    // 呼び出し処理（キャンセル制御用にAbortControllerを利用）
    generateCharacters();
});

/** キャンセルボタン */
document.getElementById("cancel-gacha-btn").addEventListener("click", function () {
    if (window.currentGachaController) {
        window.currentGachaController.abort();
    }
    hideGachaModal();
});

/** ガチャ処理：ChatGPT APIへリクエストしてキャラクタ候補を10件取得 */
// ガチャ処理などで IndexedDB に保存するタイミングも同様に
async function generateCharacters() {
    if (!window.apiKey) {
        alert("APIキーが設定されていません。");
        hideGachaModal();
        return;
    }
    window.currentGachaController = new AbortController();
    const signal = window.currentGachaController.signal;

    const messages = [
        {
            role: "system",
            content:
                "あなたはTRPG用のキャラクター、装備品、モンスター作成のエキスパートです。以下のフォーマットで10件生成してください。\n\n生成するのがキャラクタやモンスターであれば【名前】：...\n【タイプ】：キャラクタまたはモンスター\n【状態】：...\n【特技】：...\n【キャプション】：...\n生成するのがアイテムであれば【名前】：...\n【タイプ】：アイテム\n【特技】：...\n【キャプション】：...\n",
        },
        { role: "user", content: "10件生成してください。" },
    ];

    try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${window.apiKey}`,
            },
            body: JSON.stringify({
                model: "gpt-4",
                messages: messages,
                temperature: 0.7,
            }),
            signal,
        });
        if (signal.aborted) return;

        const data = await response.json();
        if (data.error) {
            throw new Error(data.error.message);
        }
        const text = data.choices[0].message.content;
        const characters = parseCharacterData(text);
        window.characterData = characters;
        await saveCharacterDataToIndexedDB(window.characterData);
        displayCharacterCards(window.characterData);
    } catch (err) {
        if (err.name === "AbortError") {
            console.log("ガチャキャンセル");
        } else {
            console.error("キャラクタ生成失敗:", err);
            alert("キャラクタ生成に失敗しました:\n" + err.message);
        }
    } finally {
        hideGachaModal();
    }
}

/** ガチャモーダルを非表示 */
function hideGachaModal() {
    document.getElementById("gacha-modal").style.display = "none";
}

/** 取得した文字列からキャラクタ情報をパースする関数  
    各項目は「【名前】：」「【状態】：」「【特技】：」「【キャプション】：」で区切られている前提 */
function parseCharacterData(text) {
    const lines = text.split("\n");
    const characters = [];
    let currentChar = { type: "", name: "", state: "", special: "", caption: "" };
    console.log("オリジナル", lines);
    lines.forEach((line) => {
        line = line.trim();
        if (line.startsWith("【名前】")) {
            if (currentChar.name) {
                characters.push({ ...currentChar });
                currentChar = { type: "", name: "", state: "", special: "", caption: "" };
            }
            currentChar.name = line.replace("【名前】", "").replace("：", "").trim();
        } else if (line.startsWith("【タイプ】")) {
            currentChar.type = line.replace("【タイプ】", "").replace("：", "").trim();
        } else if (line.startsWith("【状態】")) {
            currentChar.state = line.replace("【状態】", "").replace("：", "").trim();
        } else if (line.startsWith("【特技】")) {
            currentChar.special = line.replace("【特技】", "").replace("：", "").trim();
        } else if (line.startsWith("【キャプション】")) {
            currentChar.caption = line.replace("【キャプション】", "").replace("：", "").trim();
        }
    });
    console.log("パース", currentChar);

    if (currentChar.name) {
        characters.push({ ...currentChar });
    }
    return characters;
}

/** 保存済みキャラクタ情報を元にカード作成して表示 */
function displayCharacterCards(characters) {
    const container = document.getElementById("card-container");
    container.innerHTML = "";
    if (!characters || characters.length === 0) {
        container.textContent = "キャラクタが生成されていません。";
        return;
    }
    characters.forEach((char, idx) => {
        const card = document.createElement("div");
        card.className = "card";
        card.style.border = "1px solid #ccc";
        card.style.padding = "10px";
        card.style.width = "calc(50% - 10px)";
        card.style.boxSizing = "border-box";

        // タイプ表示
        const typeEl = document.createElement("p");
        typeEl.className = "type";
        typeEl.innerHTML = "<strong>" + DOMPurify.sanitize(char.type) + "</strong>";
        card.appendChild(typeEl);

        // 名前表示
        const nameEl = document.createElement("h3");
        nameEl.className = "name";
        nameEl.textContent = char.name;
        card.appendChild(nameEl);

        // 状態、特技、キャプション
        if (char.state != "") {
            const stateEl = document.createElement("p");
            stateEl.className = "status";
            stateEl.innerHTML = "<strong>状態：</strong>" + DOMPurify.sanitize(char.state);
            card.appendChild(stateEl);
        }

        const specialEl = document.createElement("p");
        specialEl.className = "special";
        specialEl.innerHTML = "<strong>特技：</strong>" + DOMPurify.sanitize(char.special);
        card.appendChild(specialEl);

        const captionEl = document.createElement("p");
        captionEl.className = "caption";
        captionEl.innerHTML = DOMPurify.sanitize(char.caption);
        card.appendChild(captionEl);

        // 画像表示エリア
        const imageEl = document.createElement("img");
        imageEl.style.maxWidth = "100%";
        imageEl.style.display = char.imageData ? "block" : "none";
        imageEl.src = char.imageData || "";
        card.appendChild(imageEl);

        // 「画像生成」ボタン
        const genImgBtn = document.createElement("button");
        genImgBtn.textContent = "画像生成";
        genImgBtn.addEventListener("click", () => {
            generateCharacterImage(char, idx);
        });
        card.appendChild(genImgBtn);

        container.appendChild(card);
    });
}

/** 画像生成処理：DALL·E APIなどを利用 */
async function generateCharacterImage(char, index) {
    if (!window.apiKey) {
        alert("APIキーが設定されていません。");
        return;
    }
    const promptText = `${char.caption}というキャラクタだけを描いてください。絶対に文字を入れないでください。アイテムはお任せのスタイルで。キャラクタは可能な限り親しみやすいアニメ調にしてください。`;
    try {
        const response = await fetch("https://api.openai.com/v1/images/generations", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${window.apiKey}`
            },
            body: JSON.stringify({
                model: "dall-e-3", // 必要に応じて調整
                prompt: promptText,
                n: 1,
                size: "1024x1024",
                response_format: "b64_json"
            })
        });
        const data = await response.json();
        if (data.error) {
            throw new Error(data.error.message);
        }
        const base64 = data.data[0].b64_json;
        const dataUrl = "data:image/png;base64," + base64;
        // キャラクターデータに画像をセット
        window.characterData[index].imageData = dataUrl;
        // IndexedDB に保存
        await saveCharacterDataToIndexedDB(window.characterData);
        // 再表示
        displayCharacterCards(window.characterData);
    } catch (err) {
        console.error("画像生成失敗:", err);
        alert("画像生成に失敗しました:\n" + err.message);
    }
}
--- 
image.js 
/********************************
 * image.js - 画像生成関連
 ********************************/

/**
 * DALL·E API からBase64形式で直接画像を受け取り、CORSを回避する方法。
 * OpenAIの画像生成では以下のパラメータを指定することで、直接base64を返してもらうことが可能。
 *   response_format: "b64_json"
 */

/** 自動生成(現シーン) */
async function generateImageFromCurrentScene() {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  const lastSceneEntry = [...window.sceneHistory].reverse().find((e) => e.type === "scene");
  if (!lastSceneEntry) {
    alert("まだシーンがありません。");
    return;
  }
  const promptText = `シーンのイメージ: ${lastSceneEntry.content}`;
  const sceneId = lastSceneEntry.sceneId;

  window.cancelRequested = false;
  showLoadingModal(true);

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const response = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`,
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: promptText,
        n: 1,
        size: "1024x1024",
        response_format: "b64_json"
      }),
      signal,
    });

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }

    const data = await response.json();

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }
    if (data.error) {
      throw new Error(data.error.message);
    }

    // Base64文字列を取り出し、data:image/png;base64, に変換
    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    window.sceneHistory.push({
      type: "image",
      sceneId,
      prompt: promptText,
      dataUrl: dataUrl,
    });

    // IndexedDBに保存
    await saveSceneHistoryToIndexedDB(window.sceneHistory);

    updateSceneHistory();
    showLastScene();
  } catch (error) {
    if (error.name === "AbortError") {
      console.warn("画像生成キャンセル");
    } else {
      console.error("画像生成失敗:", error);
      alert("画像生成失敗:\n" + error.message);
    }
  } finally {
    showLoadingModal(false);
  }
}

/** カスタム画像生成モーダルを開く */
function openImagePromptModal(prompt = "", index = null) {
  window.editingImageEntry = null;
  if (index !== null) {
    // 再生成の場合
    window.editingImageEntry = { index };
    const entry = window.sceneHistory[index];
    if (entry && entry.type === "image") {
      prompt = entry.prompt;
    }
  } else {
    // 新規
    const lastSceneEntry = [...window.sceneHistory].reverse().find((e) => e.type === "scene");
    if (lastSceneEntry) {
      prompt = lastSceneEntry.content;
    } else {
      prompt = window.scenario || "Fantasy scene";
    }
  }
  document.getElementById("image-custom-prompt").value = prompt;
  document.getElementById("image-prompt-modal").style.display = "flex";
}

/** カスタム画像生成モーダルを閉じる */
function closeImagePromptModal() {
  document.getElementById("image-prompt-modal").style.display = "none";
  window.editingImageEntry = null;
}

/** カスタム画像生成ボタン押下 */
async function onCustomImageGenerate() {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  const promptText = document.getElementById("image-custom-prompt").value.trim() || "Fantasy scene";

  window.cancelRequested = false;
  showLoadingModal(true);
  closeImagePromptModal();

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const response = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`,
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: promptText,
        n: 1,
        size: "1024x1024",
        response_format: "b64_json"
      }),
      signal,
    });

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }

    const data = await response.json();

    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }
    if (data.error) {
      throw new Error(data.error.message);
    }

    // Base64文字列を取り出し、data:image/png;base64, に変換
    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    if (window.editingImageEntry) {
      // 既存画像を再生成
      const idx = window.editingImageEntry.index;
      const entry = window.sceneHistory[idx];
      if (entry && entry.type === "image") {
        entry.dataUrl = dataUrl;
        entry.prompt = promptText;
      }
    } else {
      // 新規
      const lastSceneEntry = [...window.sceneHistory].reverse().find((e) => e.type === "scene");
      if (!lastSceneEntry) {
        alert("シーンがありません。");
        return;
      }
      window.sceneHistory.push({
        type: "image",
        sceneId: lastSceneEntry.sceneId,
        prompt: promptText,
        dataUrl: dataUrl,
      });
    }

    // IndexedDBに保存
    await saveSceneHistoryToIndexedDB(window.sceneHistory);

    updateSceneHistory();
    showLastScene();
  } catch (error) {
    if (error.name === "AbortError") {
      console.warn("カスタム画像生成キャンセル");
    } else {
      console.error("カスタム画像生成失敗:", error);
      alert("カスタム画像生成失敗:\n" + error.message);
    }
  } finally {
    showLoadingModal(false);
  }
}
--- 
indexedDB.js 
/********************************
 * indexedDB.js
 * IndexedDB関連の初期化・保存・読み込み等を担当
 ********************************/

let db = null;

/**
 * DB初期化
 * "trpgDB" というDBに "sceneHistory" と "characterData" のストアを作る
 */
function initIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("trpgDB", 2);  // バージョンを 2 に更新
    request.onupgradeneeded = (event) => {
      db = event.target.result;
      // sceneHistory ストアが無ければ作成
      if (!db.objectStoreNames.contains("sceneHistory")) {
        db.createObjectStore("sceneHistory", { keyPath: "id" });
      }
      // characterData ストアが無ければ作成
      if (!db.objectStoreNames.contains("characterData")) {
        db.createObjectStore("characterData", { keyPath: "id" });
      }
    };
    request.onsuccess = (event) => {
      db = event.target.result;
      resolve();
    };
    request.onerror = (event) => {
      console.error("IndexedDBの初期化に失敗:", event.target.error);
      reject(event.target.error);
    };
  });
}

/**
 * sceneHistory をまとめて IndexedDB へ保存
 * 1レコード (id=1) に配列データを保存する
 */
function saveSceneHistoryToIndexedDB(sceneHistory) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve();
      return;
    }
    const tx = db.transaction("sceneHistory", "readwrite");
    const store = tx.objectStore("sceneHistory");

    // まず既存データをクリア
    const clearRequest = store.clear();
    clearRequest.onsuccess = () => {
      // クリア後に、id=1 として保存
      const record = { id: 1, data: sceneHistory };
      const putReq = store.put(record);
      putReq.onsuccess = () => {
        resolve();
      };
      putReq.onerror = (err) => {
        reject(err);
      };
    };
    clearRequest.onerror = (err) => {
      reject(err);
    };
  });
}

/**
 * IndexedDBから sceneHistory をロード
 * 1レコード (id=1) に格納した配列データを取り出す
 */
function loadSceneHistoryFromIndexedDB() {
  return new Promise((resolve) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve([]);
      return;
    }
    const tx = db.transaction("sceneHistory", "readonly");
    const store = tx.objectStore("sceneHistory");
    const getReq = store.get(1);
    getReq.onsuccess = (event) => {
      if (event.target.result && event.target.result.data) {
        resolve(event.target.result.data);
      } else {
        resolve([]);
      }
    };
    getReq.onerror = () => {
      resolve([]);
    };
  });
}

/**
 * キャラクターデータを IndexedDB に保存する
 * ここでは、1レコード (id="characterData") にデータ全体を保存する
 */
function saveCharacterDataToIndexedDB(characterData) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve();  // DB が未初期化の場合はエラーではなく resolve する
      return;
    }
    const tx = db.transaction("characterData", "readwrite");
    const store = tx.objectStore("characterData");
    const record = { id: "characterData", data: characterData };
    const putReq = store.put(record);
    putReq.onsuccess = () => {
      resolve();
    };
    putReq.onerror = (err) => {
      reject(err);
    };
  });
}

/**
 * IndexedDBからキャラクターデータをロードする
 */
function loadCharacterDataFromIndexedDB() {
  return new Promise((resolve) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve([]);
      return;
    }
    const tx = db.transaction("characterData", "readonly");
    const store = tx.objectStore("characterData");
    const getReq = store.get("characterData");
    getReq.onsuccess = (event) => {
      if (event.target.result && event.target.result.data) {
        resolve(event.target.result.data);
      } else {
        resolve([]);
      }
    };
    getReq.onerror = () => {
      resolve([]);
    };
  });
}
--- 
main.js 
/********************************
 * main.js - ページ全体の初期化・イベント登録
 ********************************/

window.onload = async () => {
  // まずIndexedDB初期化（sceneHistory と characterData の両方を利用）
  await initIndexedDB();

  // ローカルストレージから各種情報を取得
  const savedApiKey = localStorage.getItem('apiKey');
  if (savedApiKey) {
    window.apiKey = savedApiKey;
  }

  const savedScenario = localStorage.getItem('scenario');
  if (savedScenario) {
    window.scenario = savedScenario;
    if (window.scenario === '（シナリオは未入力です）') {
      window.scenario = '';
      localStorage.removeItem('scenario');
    }
    const scenarioInput = document.getElementById('scenario-input');
    if (scenarioInput) {
      scenarioInput.value = window.scenario;
    }
  }

  // sceneHistory は IndexedDB から取得
  const loadedHistory = await loadSceneHistoryFromIndexedDB();
  window.sceneHistory = loadedHistory || [];

  // currentScene は localStorage から読み取る
  const savedCurrentScene = localStorage.getItem('currentScene');
  if (savedCurrentScene) {
    window.currentScene = parseInt(savedCurrentScene, 10);
  } else {
    window.currentScene = 0;
  }

  // APIキーが無い場合 -> .input-section や .game-section を非表示
  if (!window.apiKey) {
    const inputSection = document.querySelector('.input-section');
    const gameSection = document.querySelector('.game-section');
    if (inputSection) inputSection.style.display = 'none';
    if (gameSection) gameSection.style.display = 'none';
  } else {
    // シナリオがあればゲーム画面を表示、なければシナリオ入力画面を表示
    if (window.scenario && window.scenario.trim() !== '') {
      if (document.querySelector('.input-section')) {
        document.querySelector('.input-section').style.display = 'none';
      }
      if (document.querySelector('.game-section')) {
        document.querySelector('.game-section').style.display = 'block';
      }
    } else {
      if (document.querySelector('.input-section')) {
        document.querySelector('.input-section').style.display = 'block';
      }
      if (document.querySelector('.game-section')) {
        document.querySelector('.game-section').style.display = 'none';
      }
    }
  }

  // シナリオタイルと履歴を表示、最後のシーンをメインに表示
  displayScenarioTile();
  updateSceneHistory();
  showLastScene();

  // 各種イベントリスナーの登録

  // 応答キャンセルボタン
  const cancelRequestBtn = document.getElementById('cancel-request-button');
  if (cancelRequestBtn) {
    cancelRequestBtn.addEventListener('click', onCancelFetch);
  }

  // APIキー設定
  const setApiKeyBtn = document.getElementById('set-api-key-button');
  if (setApiKeyBtn) {
    setApiKeyBtn.addEventListener('click', () => {
      setApiKey();
    });
  }

  // APIキークリア
  const clearApiKeyBtn = document.getElementById('clear-api-key-button');
  if (clearApiKeyBtn) {
    clearApiKeyBtn.addEventListener('click', () => {
      clearApiKey();
    });
  }

  // ゲーム開始ボタン
  const startBtn = document.getElementById('start-button');
  if (startBtn) {
    startBtn.addEventListener('click', () => {
      startGame();
    });
  }

  // 次のシーンボタン
  const nextSceneBtn = document.getElementById('next-scene');
  if (nextSceneBtn) {
    nextSceneBtn.addEventListener('click', () => {
      nextScene();
    });
  }

  // 履歴クリアボタン
  const clearHistoryBtn = document.getElementById('clear-history-button');
  if (clearHistoryBtn) {
    clearHistoryBtn.addEventListener('click', () => {
      clearHistory();
    });
  }

  // 画像生成関連のボタン
  const autoGenBtn = document.getElementById('image-auto-generate-button');
  if (autoGenBtn) {
    autoGenBtn.addEventListener('click', () => {
      generateImageFromCurrentScene();
    });
  }

  const promptModalBtn = document.getElementById('image-prompt-modal-button');
  if (promptModalBtn) {
    promptModalBtn.addEventListener('click', () => {
      openImagePromptModal();
    });
  }

  const customGenBtn = document.getElementById('image-custom-generate-button');
  if (customGenBtn) {
    customGenBtn.addEventListener('click', () => {
      onCustomImageGenerate();
    });
  }

  const customCancelBtn = document.getElementById('image-custom-cancel-button');
  if (customCancelBtn) {
    customCancelBtn.addEventListener('click', () => {
      closeImagePromptModal();
    });
  }
};

/** APIキー設定 */
function setApiKey() {
  window.apiKey = document.getElementById('api-key-input').value.trim();
  if (window.apiKey) {
    localStorage.setItem('apiKey', window.apiKey);
    alert('APIキーが設定されました。');
    // ページをリロードして反映
    location.reload();
  } else {
    alert('APIキーを入力してください。');
  }
}

/** APIキークリア */
function clearApiKey() {
  const ok = confirm('APIキーをクリアすると操作ができなくなります。よろしいですか？');
  if (!ok) return;
  localStorage.removeItem('apiKey');
  window.apiKey = '';
  // ページをリロードして反映
  location.reload();
}

/** キャンセルボタン押下時の処理 */
function onCancelFetch() {
  window.cancelRequested = true;
  if (window.currentRequestController) {
    window.currentRequestController.abort();
  }
  showLoadingModal(false);
}

/** ローディングモーダルの表示／非表示 */
function showLoadingModal(show) {
  const modal = document.getElementById('loading-modal');
  if (!modal) return;
  modal.style.display = show ? 'flex' : 'none';
}
--- 
menu.js 
// menu.js

// 「シナリオ」ボタン押下で scenario.html へ遷移
document.getElementById("scenario").addEventListener("click", function () {
    window.location.href = "scenario.html";
});

// APIキー設定
document.getElementById("set-api-key-button").addEventListener("click", function () {
    const apiKey = document.getElementById("api-key-input").value.trim();
    if (apiKey) {
        localStorage.setItem("apiKey", apiKey);
        alert("APIキーが設定されました。");
    } else {
        alert("APIキーを入力してください。");
    }
});

// APIキークリア
document.getElementById("clear-api-key-button").addEventListener("click", function () {
    const confirmClear = confirm("APIキーをクリアすると操作ができなくなります。よろしいですか？");
    if (confirmClear) {
        localStorage.removeItem("apiKey");
        alert("APIキーがクリアされました。");
    }
});

// ページ読み込み時にAPIキーを入力欄に表示
window.addEventListener("load", function () {
    const savedApiKey = localStorage.getItem("apiKey");
    if (savedApiKey) {
        document.getElementById("api-key-input").value = savedApiKey;
    }
});
--- 
scene.js 
/********************************
 * scene.js - シナリオ/シーン管理関連
 ********************************/

// グローバル変数
window.apiKey = '';
window.scenario = '';
window.currentScene = 0;
window.sceneHistory = [];
// 例: {type:'scene'|'action'|'image', sceneId?: string, content?:string, dataUrl?:string, prompt?:string}
window.currentRequestController = null;
window.cancelRequested = false;
window.editingImageEntry = null;

/** ユニークIDを生成 */
function generateUniqueId() {
  return Date.now() + '_' + Math.random().toString(36).slice(2, 9);
}

/** ゲーム開始 */
async function startGame() {
  window.scenario = document.getElementById('scenario-input').value.trim();
  if (!window.scenario) {
    alert('シナリオを入力してください');
    return;
  }
  localStorage.setItem('scenario', window.scenario);

  document.querySelector('.input-section').style.display = 'none';
  document.querySelector('.game-section').style.display = 'block';

  displayScenarioTile();
  await getNextScene();
}

/** シナリオタイルの表示 */
function displayScenarioTile() {
  const historyContainer = document.getElementById('scene-history');
  if (!historyContainer) return;

  let scenarioTile = document.getElementById('scenario-tile');
  if (!scenarioTile) {
    scenarioTile = document.createElement('div');
    scenarioTile.id = 'scenario-tile';
    scenarioTile.className = 'history-tile';
  } else {
    scenarioTile.innerHTML = '';
  }

  // シナリオ本文（contenteditable）
  const scenarioText = document.createElement('p');
  scenarioText.className = 'scenario-text';
  if (!window.apiKey) {
    scenarioText.removeAttribute('contenteditable');
  } else {
    scenarioText.setAttribute('contenteditable', 'true');
  }

  // 表示上は「（シナリオは未入力です）」をプレースホルダーに
  const displayText = (window.scenario && window.scenario.trim() !== '')
    ? window.scenario
    : '（シナリオは未入力です）';
  scenarioText.innerHTML = DOMPurify.sanitize(displayText);

  // 変更があったら保存
  scenarioText.addEventListener('blur', () => {
    if (!window.apiKey) return;
    const rawText = scenarioText.textContent.trim();

    if (!rawText || rawText === '（シナリオは未入力です）') {
      window.scenario = '';
      localStorage.removeItem('scenario');
    } else {
      window.scenario = rawText;
      localStorage.setItem('scenario', rawText);
    }

    showLastScene();
  });

  scenarioTile.appendChild(scenarioText);

  // 履歴コンテナを一旦クリアし、シナリオタイルを追加
  historyContainer.innerHTML = '';
  historyContainer.appendChild(scenarioTile);
}

/** 次のシーンを取得 */
async function getNextScene(){
  if(!window.apiKey){
    alert('APIキーが設定されていません。');
    return;
  }
  
  const playerInput = document.getElementById('player-input').value.trim();
  // シーンが既にある場合のみ、プレイヤー行動が未入力ならアラートを出す
  const hasScene = window.sceneHistory.some(e => e.type === 'scene');
  if(hasScene && !playerInput){
    alert('プレイヤーの行動を入力してください');
    return;
  }

  window.cancelRequested = false;
  showLoadingModal(true);

  const messages = [
    {role:'system', content:'あなたはTRPGのゲームマスターです。HTMLタグOK。'},
    {role:'user', content:`シナリオ概要:${window.scenario}`}
  ];

  // これまでのシーンとプレイヤー行動をすべて messages に詰める
  window.sceneHistory.forEach(e=>{
    if(e.type === 'scene'){
      messages.push({role:'assistant', content:e.content});
    } else if(e.type === 'action'){
      messages.push({role:'user', content:`プレイヤーの行動:${e.content}`});
    }
  });

  // 今回の新しい行動
  if(playerInput){
    messages.push({role:'user', content:`プレイヤーの行動:${playerInput}`});
    window.sceneHistory.push({ type:'action', content:playerInput });
  }

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'Authorization':`Bearer ${window.apiKey}`
      },
      body:JSON.stringify({
        model:'gpt-4',
        messages
      }),
      signal
    });
    if(window.cancelRequested){
      showLoadingModal(false);
      return;
    }
    const data = await response.json();
    if(window.cancelRequested){
      showLoadingModal(false);
      return;
    }
    if(data.error){
      throw new Error(data.error.message);
    }

    // 次のシーン内容
    const nextScene = data.choices[0].message.content;

    // ユニークIDを付与
    const newSceneId = generateUniqueId();
    window.sceneHistory.push({
      type: 'scene',
      sceneId: newSceneId,
      content: nextScene
    });
    window.currentScene++;

    // IndexedDB保存 & currentSceneはlocalStorageに保存
    await saveSceneHistoryToIndexedDB(window.sceneHistory);
    localStorage.setItem('currentScene', window.currentScene);

    // もしプレイヤー入力欄に入力があったならリセット
    if(playerInput){
      document.getElementById('player-input').value = '';
    }

    updateSceneHistory();
    showLastScene();
  } catch(error) {
    if(error.name === 'AbortError'){
      console.warn('シーン取得キャンセル');
    } else {
      console.error('シーン取得失敗:', error);
      alert('シーン取得に失敗:\n' + error.message);
    }
  } finally {
    showLoadingModal(false);
  }
}

/**
 * シーン履歴表示
 * - 通常は「最新シーン(末尾)」はメイン表示( showLastScene )に回すので除外するが、
 *   「APIキーが無いとき」は最新シーンも履歴に入れて表示する
 */
function updateSceneHistory() {
  const historyContainer = document.getElementById('scene-history');
  if (!historyContainer) return;

  // すでに作成していたシナリオタイルを復帰
  const scenarioTile = document.getElementById('scenario-tile');
  historyContainer.innerHTML = '';
  if (scenarioTile) {
    historyContainer.appendChild(scenarioTile);
  }

  // 最新シーンのIDを取得
  const latestScene = [...window.sceneHistory].reverse().find(e => e.type === 'scene');
  const latestSceneId = latestScene ? latestScene.sceneId : null;

  // 履歴を表示
  window.sceneHistory.forEach((entry, index) => {
    // APIキーがあれば「最新シーン」は除外してメイン表示へ回す
    if (window.apiKey) {
      if (entry.sceneId && entry.sceneId === latestSceneId) {
        return;
      }
    }

    if (entry.type === 'scene') {
      // シーン表示
      const tile = document.createElement('div');
      tile.className = 'history-tile';

      // シーン削除ボタン
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = '削除';
      deleteBtn.style.marginBottom = '5px';
      deleteBtn.addEventListener('click', async () => {
        if (!window.apiKey) return;
        // シーン + それに紐づく画像を削除
        const delId = entry.sceneId;
        window.sceneHistory = window.sceneHistory.filter(e => {
          if (e.type === 'scene' && e.sceneId === delId) return false;
          if (e.type === 'image' && e.sceneId === delId) return false;
          return true;
        });
        await saveSceneHistoryToIndexedDB(window.sceneHistory);
        updateSceneHistory();
        showLastScene();
      });
      tile.appendChild(deleteBtn);

      // シーン本文
      const sceneText = document.createElement('p');
      sceneText.className = 'scene-text';
      if (!window.apiKey) {
        sceneText.removeAttribute('contenteditable');
      } else {
        sceneText.setAttribute('contenteditable', 'true');
      }
      sceneText.innerHTML = DOMPurify.sanitize(entry.content);
      sceneText.addEventListener('blur', async () => {
        if (!window.apiKey) return;
        entry.content = sceneText.textContent.trim();
        await saveSceneHistoryToIndexedDB(window.sceneHistory);
      });
      tile.appendChild(sceneText);

      historyContainer.appendChild(tile);

    } else if (entry.type === 'action') {
      // プレイヤー行動
      const tile = document.createElement('div');
      tile.className = 'history-tile';

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = '削除';
      deleteBtn.style.marginBottom = '5px';
      deleteBtn.addEventListener('click', async () => {
        if (!window.apiKey) return;

        // 最新アクションなら、最新シーンも削除
        let lastActionIndex = -1;
        for (let i = window.sceneHistory.length - 1; i >= 0; i--) {
          if (window.sceneHistory[i].type === 'action') {
            lastActionIndex = i;
            break;
          }
        }
        if (index === lastActionIndex) {
          let lastSceneIndex = -1;
          for (let i = window.sceneHistory.length - 1; i >= 0; i--) {
            if (window.sceneHistory[i].type === 'scene') {
              lastSceneIndex = i;
              break;
            }
          }
          if (lastSceneIndex !== -1) {
            window.sceneHistory.splice(lastSceneIndex, 1);
          }
        }

        window.sceneHistory.splice(index, 1);
        await saveSceneHistoryToIndexedDB(window.sceneHistory);
        updateSceneHistory();
        showLastScene();
      });
      tile.appendChild(deleteBtn);

      const actionText = document.createElement('p');
      actionText.className = 'action-text';
      if (!window.apiKey) {
        actionText.removeAttribute('contenteditable');
      } else {
        actionText.setAttribute('contenteditable', 'true');
      }
      actionText.innerHTML = DOMPurify.sanitize(entry.content);
      actionText.addEventListener('blur', async () => {
        if (!window.apiKey) return;
        entry.content = actionText.textContent.trim();
        await saveSceneHistoryToIndexedDB(window.sceneHistory);
      });
      tile.appendChild(actionText);

      historyContainer.appendChild(tile);

    } else if (entry.type === 'image') {
      // 古いシーンの画像
      const tile = document.createElement('div');
      tile.className = 'history-tile';

      const img = document.createElement('img');
      img.src = entry.dataUrl;
      img.alt = '生成画像';
      img.style.maxWidth = '100%';
      tile.appendChild(img);

      // 画像再生成
      const regenBtn = document.createElement('button');
      regenBtn.textContent = '再生成';
      regenBtn.addEventListener('click', () => {
        if (!window.apiKey) return;
        const idxInHistory = window.sceneHistory.indexOf(entry);
        if (idxInHistory >= 0) {
          openImagePromptModal(entry.prompt, idxInHistory);
        }
      });
      tile.appendChild(regenBtn);

      // 画像削除
      const imgDeleteBtn = document.createElement('button');
      imgDeleteBtn.textContent = '画像だけ削除';
      imgDeleteBtn.addEventListener('click', async () => {
        if (!window.apiKey) return;
        const idxInHistory = window.sceneHistory.indexOf(entry);
        if (idxInHistory >= 0) {
          window.sceneHistory.splice(idxInHistory, 1);
          await saveSceneHistoryToIndexedDB(window.sceneHistory);
          updateSceneHistory();
          showLastScene();
        }
      });
      tile.appendChild(imgDeleteBtn);

      historyContainer.appendChild(tile);
    }
  });

  historyContainer.scrollTop = historyContainer.scrollHeight;
}

/** 最新のシーン(末尾) をメイン表示 (APIキーがある時のみ利用) */
function showLastScene() {
  const lastSceneEntry = [...window.sceneHistory].reverse().find(e => e.type === 'scene');
  const storyDiv = document.getElementById('story');
  const lastSceneImagesDiv = document.getElementById('last-scene-images');
  if (!storyDiv || !lastSceneImagesDiv) return;

  // APIキーがあるときはボタン類表示／非表示の処理も行う
  const nextSceneBtn = document.getElementById('next-scene');
  const playerInput = document.getElementById('player-input');
  const playerActionLabel = document.getElementById('player-action');

  // シーンが存在する場合
  if (lastSceneEntry) {
    // シーン本文
    const safeHTML = DOMPurify.sanitize(lastSceneEntry.content);
    storyDiv.innerHTML = safeHTML;

    // 画像一覧クリア
    lastSceneImagesDiv.innerHTML = '';

    // 最新シーンに紐づく画像を表示
    const sId = lastSceneEntry.sceneId;
    const images = window.sceneHistory.filter(e => e.type === 'image' && e.sceneId === sId);
    images.forEach(imgEntry => {
      const container = document.createElement('div');
      container.style.marginBottom = '10px';

      const img = document.createElement('img');
      img.src = imgEntry.dataUrl;
      img.alt = 'シーン画像';
      img.style.maxWidth = '100%';
      container.appendChild(img);

      // 画像再生成
      const regenBtn = document.createElement('button');
      regenBtn.textContent = '再生成';
      regenBtn.addEventListener('click', () => {
        if (!window.apiKey) return;
        const idxInHistory = window.sceneHistory.indexOf(imgEntry);
        if (idxInHistory >= 0) {
          openImagePromptModal(imgEntry.prompt, idxInHistory);
        }
      });
      container.appendChild(regenBtn);

      // 画像削除
      const imgDeleteBtn = document.createElement('button');
      imgDeleteBtn.textContent = '画像削除';
      imgDeleteBtn.addEventListener('click', async () => {
        if (!window.apiKey) return;
        const idxInHistory = window.sceneHistory.indexOf(imgEntry);
        if (idxInHistory >= 0) {
          window.sceneHistory.splice(idxInHistory, 1);
          await saveSceneHistoryToIndexedDB(window.sceneHistory);
          showLastScene();
          updateSceneHistory();
        }
      });
      container.appendChild(imgDeleteBtn);

      lastSceneImagesDiv.appendChild(container);
    });

    // APIキーがあるときのみボタン類を表示
    if (window.apiKey) {
      nextSceneBtn.style.display = 'inline-block';
      playerInput.style.display = 'inline-block';
      playerActionLabel.textContent = 'プレイヤーがどんな行動を取るか？';
    } else {
      nextSceneBtn.style.display = 'none';
      playerInput.style.display = 'none';
      playerActionLabel.textContent = '';
    }
  } else {
    // シーンがまだ無い場合
    storyDiv.innerHTML = '';
    lastSceneImagesDiv.innerHTML = '';
    nextSceneBtn.style.display = 'none';
    playerInput.style.display = 'none';
    playerActionLabel.textContent = '';

    // 「シーンを生成する」ボタンを追加
    // 既に同じボタンが存在していないか確認し、あれば削除
    let generateBtn = document.getElementById('generate-scene-button');
    if (!generateBtn) {
      generateBtn = document.createElement('button');
      generateBtn.id = 'generate-scene-button';
      generateBtn.textContent = 'シーンを生成する';
      // ボタン押下時に最初のシーン生成を実行
      generateBtn.addEventListener('click', () => {
        // ボタンをクリックしたら自身を削除してからシーン取得を開始
        generateBtn.remove();
        getNextScene();
      });
      // ボタンを storyDiv に追加（必要に応じ位置を調整）
      storyDiv.appendChild(generateBtn);
    }
  }
}

/** 次のシーン ボタン */
function nextScene() {
  getNextScene();
}

/** 履歴クリア */
async function clearHistory() {
  const isOk = confirm('履歴をすべて削除します。（シナリオも削除されます）よろしいですか？');
  if (!isOk) return;

  // IndexedDB の sceneHistory をクリア
  if (window.sceneHistory && window.sceneHistory.length > 0) {
    // IndexedDBのストアを直接クリアするためにトランザクションを利用
    if (window.indexedDB) {
      try {
        const tx = db.transaction("sceneHistory", "readwrite");
        const store = tx.objectStore("sceneHistory");
        await new Promise((resolve, reject) => {
          const clearRequest = store.clear();
          clearRequest.onsuccess = () => resolve();
          clearRequest.onerror = (err) => reject(err);
        });
      } catch (err) {
        console.error("IndexedDBクリア失敗:", err);
      }
    }
    window.sceneHistory = [];
    await saveSceneHistoryToIndexedDB(window.sceneHistory);
  }

  localStorage.removeItem('currentScene');

  // シナリオも削除する
  localStorage.removeItem('scenario');
  window.scenario = '';

  window.sceneHistory = [];
  window.currentScene = 0;

  document.getElementById('story').textContent = '';
  document.getElementById('player-action').textContent = '';
  document.getElementById('player-input').value = '';
  document.getElementById('next-scene').style.display = 'none';
  document.getElementById('player-input').style.display = 'none';

  // 状態に応じたセクションの表示切替
  // ※ シナリオが削除されているので input-section を表示、game-section を非表示とする
  document.querySelector('.input-section').style.display = 'block';
  document.querySelector('.game-section').style.display = 'none';

  // 履歴とシナリオタイル再表示
  displayScenarioTile();
  updateSceneHistory();
}
/** キャンセルボタン */
function onCancelFetch() {
  window.cancelRequested = true;
  if (window.currentRequestController) {
    window.currentRequestController.abort();
  }
  showLoadingModal(false);
}

/** ローディングモーダル表示/非表示 */
function showLoadingModal(show) {
  const modal = document.getElementById('loading-modal');
  if (!modal) return;
  modal.style.display = show ? 'flex' : 'none';
}
--- 
