貴方は会社の中で一番のエンジニアです。
・
・
・
・
・
以上を実施し、編集しないファイルを除き完全なコードを下さい。しかしながら、最高の成果物を出すために、少しでも不明な点があれば質問をください。
index.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>TRPG メニュー</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <!-- 黒背景 + 白文字ベースのcssを読み込む（編集不要のstyles.css） -->
  <link rel="stylesheet" href="styles.css" />

  <!-- DOMPurify(カード表示などで使用) -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>

  <!-- 背景管理用スクリプト（編集不要） -->
  <script src="js/background.js"></script>
</head>
<body>
  <div class="container" style="text-align:center; margin-top:50px;">
    <h1>TRPG メニュー</h1>

    <!-- ▼ 背景を変更するボタン -->
    <button id="change-bg-button" style="
        color: #000;
        background-color: #DDD;
        border-radius: 2px;
        box-shadow: inset 0 0 3px #000;
        position: absolute;
        top: 0;
        right: 0;
      ">
      背景を変更する
    </button>

    <!-- ▼ 背景選択モーダル -->
    <div id="bg-modal" class="modal">
      <div class="modal-content bg-modal-content">
        <h2>背景選択</h2>
        <div id="bg-stock-container" class="bg-stock-grid"></div>
        <button id="bg-none-button" class="btn-secondary" style="margin-top:10px;">背景無し</button>
        <button id="bg-generate-button" style="margin-top:10px;">生成する</button>
        <button id="bg-close-modal-button" class="btn-close-modal">閉じる</button>
      </div>
    </div>

    <!-- 生成中モーダル -->
    <div id="bg-generate-modal" class="modal">
      <div class="modal-content">
        <p>背景画像を生成中...</p>
      </div>
    </div>

    <div class="api-key-section" style="margin-top:20px;">
      <label for="api-key-input">ChatGPT APIキーを入力：</label>
      <input type="text" id="api-key-input" placeholder="APIキーを入力" />
      <button id="set-api-key-button">APIキー設定</button>
      <button id="clear-api-key-button" style="background-color:#f44336;">APIキーをクリア</button>
    </div>

    <div class="element-section">
      <!-- エレメント作成ボタン -->
      <button id="character-create">エレメント作成</button>
      <!-- パーティ一覧ボタン -->
      <button id="party-list" style="margin-left:10px;">パーティ一覧</button>

      <!-- 全エレメントクリアボタン -->
      <button id="clear-character-btn" style="background-color:#f44336;">全エレメントをクリア</button>

      <!-- 倉庫確認ボタン -->
      <button id="show-warehouse-btn" style="margin-left:10px;">倉庫確認</button>
    </div>

    <!-- 新しいシナリオを始めるボタン -->
    <div class="scenario-wizard-section" style="margin-top:20px;">
      <button id="start-new-scenario-button" style="background-color:#2196F3;">
        新しいシナリオを始める
      </button>
    </div>

    <!-- 進行中のシナリオ一覧 -->
    <div id="ongoing-scenarios" style="margin-top:30px;">
      <h2>進行中のシナリオ</h2>
      <div id="active-scenarios-container"></div>
      <div id="scenario-list-container"></div>
    </div>
  </div>

  <!-- シナリオ削除用の確認モーダル -->
  <div id="delete-scenario-modal" class="modal">
    <div class="modal-content">
      <h3>シナリオ削除の確認</h3>
      <p>このシナリオを削除します。よろしいですか？</p>
      <button id="delete-scenario-ok">OK</button>
      <button id="delete-scenario-cancel">キャンセル</button>
    </div>
  </div>

  <!-- ▼ エクスポート/インポート関連 -->
  <div style="text-align:center; margin-top:30px;">
    <button id="export-metadata-button">メタデータZIPエクスポート</button>
    <button id="export-images-button" style="margin-left:30px;">画像ZIPエクスポート</button>
    <hr>
    <button id="import-metadata-button">メタデータZIPインポート</button>
    <input type="file" id="import-metadata-file" accept=".zip" style="display:none;" />
    <button id="import-images-button" style="margin-left:30px;">画像ZIPインポート</button>
    <input type="file" id="import-images-file" accept=".zip" style="display:none;" />
  </div>

  <!-- ▼ スクリプト読み込み -->
  <script src="js/indexedDB.js"></script>

  <!-- DB初期化を先に行い、その後メニュー初期化を呼ぶ -->
  <script>
    window.addEventListener("DOMContentLoaded", async () => {
      try {
        await initIndexedDB();  // ★ここでDBを初期化
        // 背景初期化(選択済みがあれば適用)
        await initBackground("index");
        // メニュー初期化
        initMenuPage();
      } catch (e) {
        console.error("DB初期化エラー:", e);
      }
    });
  </script>

  <!-- menu.js (メニュー専用ロジック) -->
  <script src="js/menu.js"></script>
  <!-- warehouse.js (倉庫共通ロジック) -->
  <script src="js/warehouse.js"></script>

  <!-- exportImportMulti.js (ZIP入出力) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <script src="js/exportImportMulti.js"></script>

</body>
</html>
--- 
partyCreate.html 
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>パーティ編成</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <!-- DOMPurify(カード表示などで使用) -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>

  <!-- 背景管理用スクリプト（編集不要） -->
  <script src="js/background.js"></script>
</head>
<body>
  <div class="container" style="text-align:center; margin-top:50px;">

    <!-- 背景を変更するボタン -->
    <button id="change-bg-button" style="
        color: #000;
        background-color: #DDD;
        border-radius: 2px;
        box-shadow: inset 0 0 3px #000;
        position: absolute;
        top: 0;
        right: 0;
      ">
      背景を変更する
    </button>

    <div id="bg-modal" class="modal">
      <div class="modal-content bg-modal-content">
        <h2>背景選択</h2>
        <div id="bg-stock-container" class="bg-stock-grid"></div>
        <button id="bg-none-button" class="btn-secondary" style="margin-top:10px;">背景無し</button>
        <button id="bg-generate-button" style="margin-top:10px;">生成する</button>
        <button id="bg-close-modal-button" class="btn-close-modal">閉じる</button>
      </div>
    </div>

    <div id="bg-generate-modal" class="modal">
      <div class="modal-content">
        <p>背景画像を生成中...</p>
      </div>
    </div>

    <div class="container">
      <h1>パーティ編成</h1>

      <!-- パーティ名入力欄 -->
      <div>
        <label for="party-name-input">パーティ名：</label>
        <input type="text" id="party-name-input" placeholder="例: 勇者一行" style="margin-bottom:10px;" />
        <button id="save-party-name-btn">保存</button>
      </div>

      <!-- 倉庫ボタン -->
      <button id="show-warehouse-btn">倉庫</button>

      <!-- 選択モードボタン & 倉庫に戻すボタン -->
      <button id="toggle-party-selection-mode-btn" style="margin-left:10px;">選択モード</button>
      <button id="move-selected-to-warehouse-btn" style="margin-left:10px; display:none;">
        選択したカードを倉庫に戻す
      </button>

      <!-- ▼ プレイヤーの分身（アバター） -->
      <section style="margin-top:20px;">
        <h2>プレイヤーの分身（アバター）</h2>
        <p style="color:#EEE; font-size:14px;">
          ※ ここに配置できるのは1つだけ。複数設定された場合、自動で以前のアバター設定が解除されます。
        </p>
        <div id="avatar-card-container" style="display:flex; flex-wrap:wrap; gap:20px;"></div>
      </section>

      <!-- ▼ パートナー（複数可） -->
      <section style="margin-top:20px;">
        <h2>パートナー（複数可）</h2>
        <div id="partner-card-container" style="display:flex; flex-wrap:wrap; gap:20px;"></div>
      </section>

      <!-- ▼ その他パーティ枠 -->
      <section style="margin-top:20px;">
        <h2>その他パーティ枠</h2>
        <div id="party-card-container" style="display:flex; flex-wrap:wrap; gap:20px;"></div>
      </section>

      <!-- 戻るボタン -->
      <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>
    </div>
  </div>
  <!-- ▼ スクリプト読み込み -->
  <script src="js/indexedDB.js"></script>
  <script src="js/partyCreate.js"></script>
  <script src="js/warehouse.js"></script>

  <!-- ページ読込時にDB初期化 → initPartyCreatePage() -->
  <script>
    window.addEventListener("DOMContentLoaded", async () => {
      try {
        await initIndexedDB(); 
        await initBackground("partyCreate");
        initPartyCreatePage();
      } catch(e) {
        console.error("DB初期化エラー:", e);
      }
    });
  </script>
</body>
</html>
--- 
partyList.html 
<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <title>パーティ一覧</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>

  <!-- 背景管理用スクリプト -->
  <script src="js/background.js"></script>
</head>

<body>
  <div class="container" style="margin-top:50px;">

    <!-- 背景を変更するボタン + モーダル -->
    <button id="change-bg-button" style="
        color: #000;
        background-color: #DDD;
        border-radius: 2px;
        box-shadow: inset 0 0 3px #000;
        position: absolute;
        top: 0;
        right: 0;
      ">
      背景を変更する
    </button>

    <div id="bg-modal" class="modal">
      <div class="modal-content bg-modal-content">
        <h2>背景選択</h2>
        <div id="bg-stock-container" class="bg-stock-grid"></div>
        <button id="bg-none-button" class="btn-secondary" style="margin-top:10px;">背景無し</button>
        <button id="bg-generate-button" style="margin-top:10px;">生成する</button>
        <button id="bg-close-modal-button" class="btn-close-modal">閉じる</button>
      </div>
    </div>

    <div id="bg-generate-modal" class="modal">
      <div class="modal-content">
        <p>背景画像を生成中...</p>
      </div>
    </div>

    <h1>パーティ一覧</h1>
    <p style="margin-bottom:20px;">
      複数のパーティを作成して管理できます。<br>
      「カレントのパーティ」に設定すると、<br>
      以後の「パーティ編成」や「シナリオウィザード」画面でそれが使われます。
    </p>

    <div style="margin-bottom:20px;">
      <label for="new-party-name">新しいパーティ名:</label>
      <input type="text" id="new-party-name" placeholder="パーティ名..." />
      <button id="create-party-button">作成</button>
    </div>

    <div id="party-list-container" style="margin-bottom:30px;"></div>

    <button id="back-to-menu" style="margin-top:20px;">メニューに戻る</button>
  </div>

  <!-- パーティ名の変更用モーダル -->
  <div id="edit-party-modal" class="modal">
    <div class="modal-content" style="max-width:400px;">
      <h2>パーティ名の変更</h2>
      <input type="text" id="edit-party-name" style="width:100%;" />
      <button id="edit-party-save-button">保存</button>
      <button id="edit-party-cancel-button">キャンセル</button>
    </div>
  </div>

  <script src="js/indexedDB.js"></script>
  <script src="js/partyList.js"></script>

  <script>
    window.addEventListener("load", async () => {
      await initIndexedDB();
      await initBackground("partyList");
    });
  </script>
</body>

</html>--- 
menu.js 
// js/menu.js

// こちらでは「initMenuPage」という関数のみ定義し、
// index.html 側で await initIndexedDB() の完了後に呼び出す形にして、
// 「DB未初期化」エラーを防ぎます。

window.initMenuPage = async function () {
  // すでに initIndexedDB() は呼ばれている前提

  // APIキーを読み込む
  window.apiKey = localStorage.getItem("apiKey") || "";
  const savedApiKey = window.apiKey;
  if (savedApiKey) {
    const inputEl = document.getElementById("api-key-input");
    if (inputEl) {
      inputEl.value = savedApiKey;
    }
  }

  // シナリオ一覧を取得して表示
  try {
    const scenarioList = await listAllScenarios();
    const container = document.getElementById("scenario-list-container");
    container.innerHTML = "";

    if (scenarioList.length === 0) {
      container.textContent = "進行中のシナリオはありません。";
    } else {
      scenarioList.forEach(scenario => {
        const div = document.createElement("div");
        div.style.margin = "10px 0";

        const infoText = document.createElement("span");
        infoText.textContent = `ID:${scenario.scenarioId} / ${scenario.title} (更新:${scenario.updatedAt}) `;
        div.appendChild(infoText);

        // 続きへ
        const btnContinue = document.createElement("button");
        btnContinue.textContent = "続きへ";
        btnContinue.style.marginRight = "6px";
        btnContinue.addEventListener("click", () => {
          window.location.href = `scenario.html?scenarioId=${scenario.scenarioId}`;
        });
        div.appendChild(btnContinue);

        // コピー
        const btnCopy = document.createElement("button");
        btnCopy.textContent = "コピーする";
        btnCopy.style.marginRight = "6px";
        btnCopy.addEventListener("click", async () => {
          try {
            const newScenarioId = await copyScenarioById(scenario.scenarioId);
            showToast(`シナリオ(ID:${scenario.scenarioId})をコピーしました。\n新ID: ${newScenarioId}`);
            location.reload(); // リスト更新
          } catch (err) {
            console.error(err);
            showToast("シナリオのコピーに失敗:\n" + err.message);
          }
        });
        div.appendChild(btnCopy);

        // 削除
        const btnDelete = document.createElement("button");
        btnDelete.textContent = "削除";
        btnDelete.style.backgroundColor = "#f44336";
        btnDelete.addEventListener("click", () => {
          scenarioIdToDelete = scenario.scenarioId;
          showDeleteScenarioModal(true);
        });
        div.appendChild(btnDelete);

        container.appendChild(div);
      });
    }
  } catch (err) {
    console.error("シナリオ一覧の取得に失敗:", err);
    const container = document.getElementById("scenario-list-container");
    container.textContent = "シナリオ一覧の取得に失敗しました。再読み込みしてください。";
  }

  // characterDataのロード
  try {
    const stored = await loadCharacterDataFromIndexedDB();
    window.characterData = stored || [];
  } catch (err) {
    console.error("characterDataのロードに失敗:", err);
    window.characterData = [];
  }

  // 各種ボタンのイベント設定
  setupMenuButtons();
};

// シナリオ削除用で使う変数
let scenarioIdToDelete = null;

/** メニュー画面のボタン類設定 */
function setupMenuButtons() {
  // APIキーの設定・クリア
  document.getElementById("set-api-key-button").addEventListener("click", function () {
    const apiKey = document.getElementById("api-key-input").value.trim();
    if (apiKey) {
      localStorage.setItem("apiKey", apiKey);
      window.apiKey = apiKey;
      showToast("APIキーが設定されました。");
    } else {
      showToast("APIキーを入力してください。");
    }
  });

  document.getElementById("clear-api-key-button").addEventListener("click", function () {
    if (confirm("APIキーをクリアすると操作ができなくなります。よろしいですか？")) {
      localStorage.removeItem("apiKey");
      window.apiKey = "";
      showToast("APIキーがクリアされました。");
    }
  });

  // 全エレメントクリア
  document.getElementById("clear-character-btn").addEventListener("click", async () => {
    if (confirm("エレメント情報をクリアします。よろしいですか？")) {
      window.characterData = [];
      await saveCharacterDataToIndexedDB(window.characterData);
      showToast("エレメント情報をクリアしました。");
    }
  });

  // 倉庫確認 => showWarehouseModal("menu")
  document.getElementById("show-warehouse-btn").addEventListener("click", () => {
    showWarehouseModal("menu");
  });

  // エレメント作成
  document.getElementById("character-create").addEventListener("click", () => {
    window.location.href = "characterCreate.html";
  });

  // パーティ一覧
  document.getElementById("party-list").addEventListener("click", () => {
    window.location.href = "partyList.html";
  });

  // 新しいシナリオ
  document.getElementById("start-new-scenario-button").addEventListener("click", () => {
    window.location.href = "scenarioWizard.html";
  });

  // 削除モーダルのOK/CANCEL
  document.getElementById("delete-scenario-ok").addEventListener("click", async () => {
    if (scenarioIdToDelete == null) {
      showDeleteScenarioModal(false);
      return;
    }
    try {
      await deleteScenarioById(scenarioIdToDelete);
      showToast(`シナリオ(ID:${scenarioIdToDelete})を削除しました。`);
    } catch (err) {
      console.error(err);
      showToast("シナリオ削除に失敗:\n" + err.message);
    }
    scenarioIdToDelete = null;
    showDeleteScenarioModal(false);
    location.reload();
  });
  document.getElementById("delete-scenario-cancel").addEventListener("click", () => {
    scenarioIdToDelete = null;
    showDeleteScenarioModal(false);
  });
}

/** シナリオ削除モーダルの表示/非表示 */
function showDeleteScenarioModal(show) {
  const modal = document.getElementById("delete-scenario-modal");
  if (!modal) return;
  if (show) modal.classList.add("active");
  else modal.classList.remove("active");
}

/** シナリオをコピー */
async function copyScenarioById(originalScenarioId) {
  const scenario = await getScenarioById(originalScenarioId);
  if (!scenario) {
    throw new Error("コピー元シナリオが見つかりませんでした。");
  }
  const now = new Date().toISOString();
  const newScenario = {
    title: scenario.title + "_copy",
    wizardData: JSON.parse(JSON.stringify(scenario.wizardData || {})),
    createdAt: now,
    updatedAt: now
  };
  const newScenarioId = await createNewScenario(newScenario.wizardData, newScenario.title);

  const entries = await getSceneEntriesByScenarioId(originalScenarioId);
  for (const e of entries) {
    const copy = {
      scenarioId: newScenarioId,
      type: e.type,
      sceneId: e.sceneId + "_copy_" + Date.now(),
      content: e.content,
      dataUrl: e.dataUrl || null,
      prompt: e.prompt || null
    };
    await addSceneEntry(copy);
  }

  const newScen = await getScenarioById(newScenarioId);
  newScen.title = scenario.title + "_copy";
  newScen.updatedAt = new Date().toISOString();
  await updateScenario(newScen);

  return newScenarioId;
}

/** 簡易トースト表示 */
function showToast(message) {
  const oldToast = document.getElementById("toast-message");
  if (oldToast) {
    oldToast.remove();
  }

  const toast = document.createElement("div");
  toast.id = "toast-message";
  toast.textContent = message;

  toast.style.position = "fixed";
  toast.style.bottom = "20px";
  toast.style.left = "50%";
  toast.style.transform = "translateX(-50%)";
  toast.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
  toast.style.color = "#fff";
  toast.style.padding = "10px 20px";
  toast.style.borderRadius = "4px";
  toast.style.fontSize = "14px";
  toast.style.zIndex = "9999";
  toast.style.opacity = "0";
  toast.style.transition = "opacity 0.3s ease";

  document.body.appendChild(toast);

  requestAnimationFrame(() => {
    toast.style.opacity = "1";
  });

  // 3秒後に消す
  setTimeout(() => {
    toast.style.opacity = "0";
    toast.addEventListener("transitionend", () => {
      toast.remove();
    });
  }, 3000);
}
--- 
partyCreate.js 
// js/partyCreate.js

// パーティ編成画面の初期処理をまとめる関数
// index.html の「DOMContentLoaded」で initIndexedDB() 完了後に呼ばれます。
window.initPartyCreatePage = async function () {

  // URLパラメータで partyId を取得
  const urlParams = new URLSearchParams(window.location.search);
  let currentPartyId = parseInt(urlParams.get("partyId"), 10);
  if (Number.isNaN(currentPartyId)) {
    currentPartyId = null;
  }

  let currentParty = null;
  if (currentPartyId) {
    currentParty = await getPartyById(currentPartyId);
    if (currentParty) {
      // パーティ名を input に反映
      document.getElementById("party-name-input").value = currentParty.name;
    } else {
      // 無効IDなら新規扱い
      currentPartyId = null;
    }
  }

  // characterData
  try {
    const stored = await loadCharacterDataFromIndexedDB();
    window.characterData = stored || [];
  } catch (err) {
    console.error("characterDataのロードに失敗:", err);
    window.characterData = [];
  }

  // ボタンイベント
  document.getElementById("save-party-name-btn").addEventListener("click", async () => {
    const newName = document.getElementById("party-name-input").value.trim() || "名称未設定";
    if (!currentPartyId) {
      // 新規
      const newId = await createParty(newName);
      currentPartyId = newId;
      alert("パーティを新規作成しました (ID:" + newId + ")");
    } else {
      // 既存パーティ名更新
      const pt = await getPartyById(currentPartyId);
      if (pt) {
        pt.name = newName;
        await updateParty(pt);
        alert("パーティ名を更新しました (ID:" + currentPartyId + ")");
      }
    }
  });

  // 倉庫ボタン => showWarehouseModal("party", partyId, コールバック)
  document.getElementById("show-warehouse-btn").addEventListener("click", () => {
    if (!currentPartyId) {
      alert("パーティIDが未確定です。先にパーティ名を保存してください。");
      return;
    }
    showWarehouseModal("party", currentPartyId, () => {
      // パーティにカード追加後のコールバック
      renderAllParty();
    });
  });

  // パーティ側の選択モード
  let partySelectionMode = false;
  document.getElementById("toggle-party-selection-mode-btn").addEventListener("click", () => {
    partySelectionMode = !partySelectionMode;
    const btn = document.getElementById("toggle-party-selection-mode-btn");
    if (partySelectionMode) {
      btn.textContent = "選択モード解除";
    } else {
      btn.textContent = "選択モード";
      // 選択解除
      const selCards = document.querySelectorAll(
        "#avatar-card-container .card.selected, " +
        "#partner-card-container .card.selected, " +
        "#party-card-container .card.selected"
      );
      selCards.forEach(el => el.classList.remove("selected"));
    }
    updatePartyMoveButtonVisibility();
  });

  // 「選択したカードを倉庫に戻す」
  document.getElementById("move-selected-to-warehouse-btn").addEventListener("click", async () => {
    const selectedCards = document.querySelectorAll(
      "#avatar-card-container .card.selected, " +
      "#partner-card-container .card.selected, " +
      "#party-card-container .card.selected"
    );
    if (selectedCards.length === 0) {
      alert("カードが選択されていません。");
      return;
    }
    selectedCards.forEach(el => {
      const cardId = el.getAttribute("data-id");
      const idx = window.characterData.findIndex(c => c.id === cardId);
      if (idx !== -1) {
        window.characterData[idx].group = "Warehouse";
        window.characterData[idx].role = "none";
        window.characterData[idx].partyId = null;
      }
    });
    await saveCharacterDataToIndexedDB(window.characterData);
    // 選択解除 & 再描画
    selectedCards.forEach(el => el.classList.remove("selected"));
    renderAllParty();
    updatePartyMoveButtonVisibility();
  });

  // 「メニューに戻る」
  document.getElementById("back-to-menu").addEventListener("click", () => {
    window.location.href = "index.html";
  });

  // パーティ描画
  function renderAllParty() {
    const partyCards = window.characterData.filter(
      c => c.group === "Party" && c.partyId === currentPartyId
    );
    const avatarContainer = document.getElementById("avatar-card-container");
    const partnerContainer = document.getElementById("partner-card-container");
    const partyContainer = document.getElementById("party-card-container");

    avatarContainer.innerHTML = "";
    partnerContainer.innerHTML = "";
    partyContainer.innerHTML = "";

    const avatarCards = partyCards.filter(c => c.role === "avatar");
    const partnerCards = partyCards.filter(c => c.role === "partner");
    const noneCards = partyCards.filter(c => !c.role || c.role === "none");

    avatarCards.forEach(card => {
      avatarContainer.appendChild(createPartyCardElement(card));
    });
    partnerCards.forEach(card => {
      partnerContainer.appendChild(createPartyCardElement(card));
    });
    noneCards.forEach(card => {
      partyContainer.appendChild(createPartyCardElement(card));
    });
  }

  // カード生成
  function createPartyCardElement(card) {
    const cardEl = document.createElement("div");
    cardEl.className = "card rarity" + card.rarity.replace("★", "").trim();
    cardEl.setAttribute("data-id", card.id);

    cardEl.addEventListener("click", (e) => {
      if (document.getElementById("toggle-party-selection-mode-btn").textContent.includes("解除")) {
        // 選択モード中
        e.stopPropagation();
        cardEl.classList.toggle("selected");
        updatePartyMoveButtonVisibility();
      } else {
        // 通常時: 裏返し
        cardEl.classList.toggle("flipped");
      }
    });

    const cardInner = document.createElement("div");
    cardInner.className = "card-inner";

    const cardFront = document.createElement("div");
    cardFront.className = "card-front";

    // 背景
    const bgStyle = (card.backgroundcss || "")
      .replace("background-image:", "")
      .replace("background", "")
      .trim();
    if (bgStyle) {
      cardFront.style.backgroundImage = bgStyle;
    }

    // レアリティ
    const rv = card.rarity.replace("★", "").trim();
    cardFront.innerHTML = `<div class='bezel rarity${rv}'></div>`;

    // タイプ
    const typeEl = document.createElement("div");
    typeEl.className = "card-type";
    typeEl.textContent = card.type || "不明";
    cardFront.appendChild(typeEl);

    // 画像領域
    const imageContainer = document.createElement("div");
    imageContainer.className = "card-image";
    if (card.imageData) {
      const imageEl = document.createElement("img");
      imageEl.src = card.imageData;
      imageEl.alt = card.name;
      imageContainer.appendChild(imageEl);
    }
    cardFront.appendChild(imageContainer);

    // 情報
    const infoContainer = document.createElement("div");
    infoContainer.className = "card-info";

    const nameEl = document.createElement("p");
    nameEl.innerHTML = `<h3>${DOMPurify.sanitize(card.name)}</h3>`;
    infoContainer.appendChild(nameEl);

    if (card.state) {
      const stateEl = document.createElement("p");
      stateEl.innerHTML = `<strong>状態：</strong>${DOMPurify.sanitize(card.state)}`;
      infoContainer.appendChild(stateEl);
    }
    const specialEl = document.createElement("p");
    specialEl.innerHTML = `<strong>特技：</strong>${DOMPurify.sanitize(card.special)}`;
    infoContainer.appendChild(specialEl);

    const captionEl = document.createElement("p");
    captionEl.innerHTML = `<span>${DOMPurify.sanitize(card.caption)}</span>`;
    infoContainer.appendChild(captionEl);

    // キャラクターのみ role 切り替えボタン
    if (card.type === "キャラクター") {
      const roleDiv = document.createElement("div");
      roleDiv.style.marginTop = "8px";

      const avatarBtn = document.createElement("button");
      avatarBtn.textContent = (card.role === "avatar") ? "アバター解除" : "アバターに設定";
      avatarBtn.style.marginRight = "5px";
      avatarBtn.addEventListener("click", async (e) => {
        e.stopPropagation();
        await toggleAvatar(card);
      });
      roleDiv.appendChild(avatarBtn);

      const partnerBtn = document.createElement("button");
      partnerBtn.textContent = (card.role === "partner") ? "パートナー解除" : "パートナーに設定";
      partnerBtn.addEventListener("click", async (e) => {
        e.stopPropagation();
        await togglePartner(card);
      });
      roleDiv.appendChild(partnerBtn);

      infoContainer.appendChild(roleDiv);
    }

    cardFront.appendChild(infoContainer);
    const cardBack = document.createElement("div");
    cardBack.className = "card-back";
    cardBack.innerHTML = `<strong>${DOMPurify.sanitize(card.type)}</strong>`;

    cardInner.appendChild(cardFront);
    cardInner.appendChild(cardBack);
    cardEl.appendChild(cardInner);

    return cardEl;
  }

  async function toggleAvatar(card) {
    if (card.role === "avatar") {
      card.role = "none";
    } else {
      // 他のavatarを解除
      window.characterData.forEach(c => {
        if (c.group === "Party" && c.partyId === currentPartyId && c.role === "avatar") {
          c.role = "none";
        }
      });
      card.role = "avatar";
    }
    await saveCharacterDataToIndexedDB(window.characterData);
    renderAllParty();
  }

  async function togglePartner(card) {
    if (card.role === "partner") {
      card.role = "none";
    } else {
      card.role = "partner";
    }
    await saveCharacterDataToIndexedDB(window.characterData);
    renderAllParty();
  }

  function updatePartyMoveButtonVisibility() {
    const moveBtn = document.getElementById("move-selected-to-warehouse-btn");
    const sel = document.querySelectorAll(
      "#avatar-card-container .card.selected, " +
      "#partner-card-container .card.selected, " +
      "#party-card-container .card.selected"
    );
    moveBtn.style.display = (sel.length > 0) ? "inline-block" : "none";
  }

  // 最後に一度だけレンダリング実行
  renderAllParty();
};
--- 
warehouse.js 
// js/warehouse.js
// 倉庫表示ロジックを一括管理

(() => {
  let warehouseModal = null;
  let previewModal = null;
  let warehouseMode = "menu";         // "menu" or "party"
  let currentPartyIdForAdd = null;    // パーティID
  let afterAddCallback = null;        // パーティ追加後のコールバック
  let currentTab = "キャラクター";      // タブ (キャラクター / アイテム / モンスター)

  let warehouseSelectionMode = false;
  let allWarehouseCards = [];
  let cardsPerRow = 1;
  let loadedLineCount = 0;
  const LINES_PER_LOAD = 1;

  // -------------------------------
  // モーダルHTMLの動的挿入
  // -------------------------------
  function ensureWarehouseModalExists() {
    if (document.getElementById("warehouse-modal")) {
      warehouseModal = document.getElementById("warehouse-modal");
      previewModal = document.getElementById("card-image-preview-modal");
      return;
    }
    // まだ無い場合、body末尾に挿入
    const modalHTML = `
<div id="warehouse-modal" class="modal" ">
  <button id="close-warehouse-btn" style="margin: 0;display: flex;right: 0;top: 0;position: fixed;">閉じる</button>
  <div class="modal-content">
    <h2>倉庫</h2>
    <div class="manipulate-panel">
      <div class="button-container">
          <button id="toggle-warehouse-selection-mode-btn" style="margin:0">選択モード</button>
          <button id="delete-selected-warehouse-btn" style="margin:0;display:none;">選択したカードを削除</button>
          <button id="add-to-party-btn" style="margin:0;display:none;">パーティに入れる</button>
      </div
      <div class="warehouse-tab-container" style="overflow-x:auto; white-space:nowrap; margin-bottom:10px;">
        <div class="warehouse-tabs" style="display:inline-flex; gap:10px;">
          <div class="warehouse-tab" data-tab="キャラクター" style="flex:0 0 auto; cursor:pointer; padding:6px 12px; background-color:#444; border-radius:4px;">キャラクター</div>
          <div class="warehouse-tab" data-tab="アイテム" style="flex:0 0 auto; cursor:pointer; padding:6px 12px; background-color:#444; border-radius:4px;">アイテム</div>
          <div class="warehouse-tab" data-tab="モンスター" style="flex:0 0 auto; cursor:pointer; padding:6px 12px; background-color:#444; border-radius:4px;">モンスター</div>
        </div>
      </div>
    </div>
    <div id="warehouse-card-scroll-container" style="margin:10px 0; max-height:70vh; overflow-y:auto; width:100%">
      <div id="warehouse-card-container" style="display:flex; flex-wrap:wrap; gap:20px;"></div>
    </div>
  </div>
</div>

<div id="card-image-preview-modal" class="modal">
  <div class="modal-content">
    <img id="card-preview-img" src="" alt="card image" style="max-width:95vw; max-height:95vh;" />
    <button id="card-preview-close-btn" style="margin-top:10px;">閉じる</button>
  </div>
</div>
    `;
    document.body.insertAdjacentHTML("beforeend", modalHTML);

    warehouseModal = document.getElementById("warehouse-modal");
    previewModal = document.getElementById("card-image-preview-modal");

    // 閉じるボタン
    document.getElementById("close-warehouse-btn").addEventListener("click", closeWarehouseModal);

    // 選択モード
    document.getElementById("toggle-warehouse-selection-mode-btn")
      .addEventListener("click", toggleWarehouseSelectionMode);

    // 削除ボタン
    document.getElementById("delete-selected-warehouse-btn")
      .addEventListener("click", deleteSelectedWarehouseCards);

    // パーティに入れる
    document.getElementById("add-to-party-btn")
      .addEventListener("click", addSelectedCardsToParty);

    // タブ切り替え
    const tabEls = warehouseModal.querySelectorAll(".warehouse-tab");
    tabEls.forEach(tabEl => {
      tabEl.addEventListener("click", () => {
        tabEls.forEach(t => t.style.backgroundColor = "#444");
        tabEl.style.backgroundColor = "#666";
        currentTab = tabEl.getAttribute("data-tab");
        loadCardsByTab();
      });
    });
    // 最初のタブを少し強調
    tabEls[0].style.backgroundColor = "#666";

    // プレビュー閉じる
    document.getElementById("card-preview-close-btn").addEventListener("click", () => {
      previewModal.classList.remove("active");
    });
    previewModal.addEventListener("click", (e) => {
      if (e.target === previewModal) {
        previewModal.classList.remove("active");
      }
    });

    // スクロール監視
    const scrollContainer = document.getElementById("warehouse-card-scroll-container");
    scrollContainer.addEventListener("scroll", onScrollCheck);
  }

  // -------------------------------
  // モーダルを開く
  // -------------------------------
  function showWarehouseModal(mode = "menu", partyId = null, onAddCb = null) {
    ensureWarehouseModalExists();

    warehouseMode = mode;
    currentPartyIdForAdd = partyId;
    afterAddCallback = onAddCb || null;

    // ボタン表示切り替え
    /*
    if (mode === "menu") {
      document.getElementById("delete-selected-warehouse-btn").style.display = "inline-block";
      document.getElementById("add-to-party-btn").style.display = "none";
    } else {
      document.getElementById("delete-selected-warehouse-btn").style.display = "none";
      document.getElementById("add-to-party-btn").style.display = "inline-block";
    }
*/
    // 選択モード解除
    warehouseSelectionMode = false;
    document.getElementById("toggle-warehouse-selection-mode-btn").textContent = "選択モード";
    clearSelectedCards();

    // タブを初期化して再読み込み
    currentTab = "キャラクター";
    const tabEls = warehouseModal.querySelectorAll(".warehouse-tab");
    tabEls.forEach(t => t.style.backgroundColor = "#444");
    const charTab = Array.from(tabEls).find(t => t.getAttribute("data-tab") === "キャラクター");
    if (charTab) {
      charTab.style.backgroundColor = "#666";
    }

    warehouseModal.classList.add("active");

    loadCardsByTab();
  }

  // -------------------------------
  // モーダルを閉じる
  // -------------------------------
  function closeWarehouseModal() {
    warehouseModal.classList.remove("active");
    previewModal.classList.remove("active");
    warehouseMode = "menu";
    currentPartyIdForAdd = null;
    afterAddCallback = null;
  }

  // -------------------------------
  // タブ切り替え時のカード読み込み
  // -------------------------------
  function loadCardsByTab() {
    const container = document.getElementById("warehouse-card-container");
    const scrollContainer = document.getElementById("warehouse-card-scroll-container");
    if (!container || !scrollContainer) return;

    // ★ いったん隠しておく（チラつき防止）
    container.style.visibility = "hidden";

    // 既存リセット
    allWarehouseCards = (window.characterData || [])
      .filter(c => c.group === "Warehouse" && c.type === currentTab);
    loadedLineCount = 0;
    container.innerHTML = "";

    // 1行あたり枚数を再計算
    cardsPerRow = calcCardsPerRow();

    // とりあえず2行ぶん読み込み
    loadNextLines(LINES_PER_LOAD);

    // ↓ ここで「スクロールが出るまで繰り返し読み込み」してみる
    fillContainerIfNeeded(() => {
      // すべて完了したら可視化
      container.style.visibility = "visible";
      // フェード用に opacity=1
      container.style.opacity = "1";
    });
  }

  /**
 * スクロールが必要になるまで自動で追加行を読み込み、
 * 終わったら callback() する。
 */
  function fillContainerIfNeeded(callback) {
    const scrollContainer = document.getElementById("warehouse-card-scroll-container");
    if (!scrollContainer) {
      if (callback) callback();
      return;
    }

    // 安全策: 無限ループ回避用
    let safeCounter = 0;

    // while ループで追加行を読み込んでみる
    while (
      scrollContainer.scrollHeight <= scrollContainer.clientHeight &&        // まだ縦スクロールが出ていない
      loadedLineCount * cardsPerRow < allWarehouseCards.length &&           // まだカードが残っている
      safeCounter < 50                                                      // 50回くらいで打ち止め
    ) {
      loadNextLines(LINES_PER_LOAD);
      safeCounter++;
    }

    // 全部読み終わったか、スクロールが出るまで読み込んだか
    if (callback) callback();

  }


  // スクロールで下端付近になったら2行ずつ読み込む
  function onScrollCheck() {
    const scrollC = document.getElementById("warehouse-card-scroll-container");
    if (!scrollC) return;
    const threshold = 50;
    if (scrollC.scrollTop + scrollC.clientHeight + threshold >= scrollC.scrollHeight) {
      loadNextLines(2);
    }
  }

  function loadNextLines(lineCount) {
    const container = document.getElementById("warehouse-card-container");
    if (!container) return;

    // いま何行分表示しているか → すでに loadedLineCount 行
    const displayedCount = loadedLineCount * cardsPerRow;
    const newCount = lineCount * cardsPerRow;

    const nextCards = allWarehouseCards.slice(displayedCount, displayedCount + newCount);
    nextCards.forEach(card => {
      const cardEl = createWarehouseCardElement(card);
      container.appendChild(cardEl);
    });

    // 行数更新
    loadedLineCount += lineCount;

    // ============================================
    // ▼ここが重要: 「スクロールバーが出ない場合」は
    //  さらに追加行を読み込む (カードが残っているなら)
    // ============================================
    const scrollContainer = document.getElementById("warehouse-card-scroll-container");
    if (!scrollContainer) return;

    // 少し遅延させて高さが反映されるのを待つ
    setTimeout(() => {
      const stillNoScroll =
        scrollContainer.scrollHeight <= scrollContainer.clientHeight;
      // scrollHeight <= clientHeight → スクロール不要

      const notAllLoaded =
        (loadedLineCount * cardsPerRow < allWarehouseCards.length);

      if (stillNoScroll && notAllLoaded) {
        // さらに2行ぶん追加読み込みしてみる
        loadNextLines(LINES_PER_LOAD);
      }
    }, 0);
  }


  // 1行あたり何枚入りそうか計算
  function calcCardsPerRow() {
    const container = document.getElementById("warehouse-card-container");
    if (!container) return 1;
    const containerWidth = container.clientWidth;
    if (containerWidth <= 0) return 1;

    // 仮にカード幅300 + gap20として概算
    let cardW = 300;
    let gap = 20;
    let per = 1;
    for (let n = 1; n <= 50; n++) {
      const totalW = n * cardW + (n - 1) * gap;
      if (totalW <= containerWidth) {
        per = n;
      } else {
        break;
      }
    }
    return per;
  }

  // -------------------------------
  // カード生成 (menu仕様優先)
  // -------------------------------
  function createWarehouseCardElement(card) {
    const cardEl = document.createElement("div");
    cardEl.className = "card rarity" + card.rarity.replace("★", "").trim();
    cardEl.setAttribute("data-id", card.id);

    if (card.flipped) {
      cardEl.classList.add("flipped");
    }

    cardEl.addEventListener("click", (e) => {
      if (warehouseSelectionMode) {
        e.stopPropagation();
        cardEl.classList.toggle("selected");
        updateSelectionButtonsVisibility();
      } else {
        // 裏返し→表  or 画像プレビュー
        if (cardEl.classList.contains("flipped")) {
          cardEl.classList.remove("flipped");
          card.flipped = false;
          saveFlippedState(card.id, false);
        } else {
          if (card.imageData) {
            openImagePreview(card.imageData);
          } else {
            alert("画像がありません。");
          }
        }
      }
    });

    const cardInner = document.createElement("div");
    cardInner.className = "card-inner";

    const cardFront = document.createElement("div");
    cardFront.className = "card-front";

    const bgStyle = (card.backgroundcss || "")
      .replace("background-image:", "")
      .replace("background", "")
      .trim();
    if (bgStyle) {
      cardFront.style.backgroundImage = bgStyle;
    }

    const rarityValue = card.rarity.replace("★", "").trim();
    cardFront.innerHTML = `<div class='bezel rarity${rarityValue}'></div>`;

    const typeEl = document.createElement("div");
    typeEl.className = "card-type";
    typeEl.textContent = card.type || "不明";
    cardFront.appendChild(typeEl);

    const imageContainer = document.createElement("div");
    imageContainer.className = "card-image";
    if (card.imageData) {
      const imageEl = document.createElement("img");
      imageEl.src = card.imageData;
      imageEl.alt = card.name;
      imageContainer.appendChild(imageEl);
    } else {
      // 画像生成ボタン
      const genImgBtn = document.createElement("button");
      genImgBtn.className = "gen-image-btn";
      genImgBtn.textContent = "画像生成";
      genImgBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        generateWarehouseImage(card, genImgBtn);
      });
      imageContainer.appendChild(genImgBtn);
    }
    cardFront.appendChild(imageContainer);

    const infoContainer = document.createElement("div");
    infoContainer.className = "card-info";

    const nameEl = document.createElement("p");
    nameEl.innerHTML = `<h3>${DOMPurify.sanitize(card.name)}</h3>`;
    infoContainer.appendChild(nameEl);

    if (card.state) {
      const stateEl = document.createElement("p");
      stateEl.innerHTML = `<strong>状態：</strong>${DOMPurify.sanitize(card.state)}`;
      infoContainer.appendChild(stateEl);
    }
    const specialEl = document.createElement("p");
    specialEl.innerHTML = `<strong>特技：</strong>${DOMPurify.sanitize(card.special)}`;
    infoContainer.appendChild(specialEl);

    const captionEl = document.createElement("p");
    captionEl.innerHTML = `<span>${DOMPurify.sanitize(card.caption)}</span>`;
    infoContainer.appendChild(captionEl);

    cardFront.appendChild(infoContainer);

    const cardBack = document.createElement("div");
    cardBack.className = "card-back";
    cardBack.innerHTML = `<strong>${DOMPurify.sanitize(card.type)}</strong>`;

    cardInner.appendChild(cardFront);
    cardInner.appendChild(cardBack);
    cardEl.appendChild(cardInner);

    return cardEl;
  }

  async function saveFlippedState(cardId, flipped) {
    const idx = (window.characterData || []).findIndex(c => c.id === cardId);
    if (idx !== -1) {
      window.characterData[idx].flipped = flipped;
      await saveCharacterDataToIndexedDB(window.characterData);
    }
  }

  function openImagePreview(imageUrl) {
    if (!previewModal) return;
    const imgEl = document.getElementById("card-preview-img");
    if (!imgEl) return;
    imgEl.src = imageUrl;
    previewModal.classList.add("active");
  }

  // 画像生成
  async function generateWarehouseImage(card, btnElement) {
    const apiKey = window.apiKey || localStorage.getItem("apiKey");
    if (!apiKey) {
      alert("APIキーが設定されていません。");
      return;
    }
    if (btnElement) {
      btnElement.disabled = true;
    }
    alert("画像を生成しています... (DALL-E API)");

    const rarityNum = parseInt(card.rarity.replace("★", "").trim()) || 0;
    const size = (rarityNum >= 3) ? "1024x1792" : "1792x1024";

    const promptText =
      "As a high-performance chatbot, you create the highest quality illustrations discreetly." +
      "Please do not include text in illustrations for any reason." +
      "If you can do that, I'll give you a super high tip." +
      "Now generate the next anime wide image.\n↓↓↓↓↓↓\n" +
      (card.imageprompt || "");

    try {
      const response = await fetch("https://api.openai.com/v1/images/generations", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          model: "dall-e-3",
          prompt: promptText,
          n: 1,
          size: size,
          response_format: "b64_json",
        }),
      });

      const data = await response.json();
      if (data.error) {
        throw new Error(data.error.message);
      }
      const base64 = data.data[0].b64_json;
      const dataUrl = "data:image/png;base64," + base64;

      // characterData 更新
      const idx = window.characterData.findIndex(c => c.id === card.id);
      if (idx !== -1) {
        window.characterData[idx].imageData = dataUrl;
        await saveCharacterDataToIndexedDB(window.characterData);
      }

      alert("画像の生成が完了しました");
      reloadCurrentView();
    } catch (err) {
      console.error("画像生成失敗:", err);
      alert("画像生成に失敗しました:\n" + err.message);
    } finally {
      if (btnElement) {
        btnElement.disabled = false;
      }
    }
  }

  // -------------------------------
  // 選択モード
  // -------------------------------
  function toggleWarehouseSelectionMode() {
    warehouseSelectionMode = !warehouseSelectionMode;
    const btn = document.getElementById("toggle-warehouse-selection-mode-btn");
    if (warehouseSelectionMode) {
      btn.textContent = "選択モード解除";
    } else {
      btn.textContent = "選択モード";
      clearSelectedCards();
    }
    updateSelectionButtonsVisibility();
  }

  function clearSelectedCards() {
    const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
    selectedCards.forEach(card => card.classList.remove("selected"));
  }

  function updateSelectionButtonsVisibility() {
    if (!warehouseSelectionMode) {
      document.getElementById("delete-selected-warehouse-btn").style.display = "none";
      document.getElementById("add-to-party-btn").style.display = "none";
      return;
    }
    const selected = document.querySelectorAll("#warehouse-card-container .card.selected");
    if (warehouseMode === "menu") {
      document.getElementById("delete-selected-warehouse-btn").style.display =
        (selected.length > 0) ? "inline-block" : "none";
      document.getElementById("add-to-party-btn").style.display = "none";
    } else {
      document.getElementById("delete-selected-warehouse-btn").style.display = "none";
      document.getElementById("add-to-party-btn").style.display =
        (selected.length > 0) ? "inline-block" : "none";
    }
  }

  // -------------------------------
  // 倉庫カード削除 (menuモード)
  // -------------------------------
  async function deleteSelectedWarehouseCards() {
    if (warehouseMode !== "menu") return;
    const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
    if (selectedCards.length === 0) {
      alert("カードが選択されていません。");
      return;
    }
    if (!confirm("選択したカードを削除します。よろしいですか？")) {
      return;
    }
    selectedCards.forEach(cardEl => {
      const cardId = cardEl.getAttribute("data-id");
      const idx = window.characterData.findIndex(c => c.id === cardId);
      if (idx !== -1) {
        window.characterData.splice(idx, 1);
      }
    });
    await saveCharacterDataToIndexedDB(window.characterData);
    reloadCurrentView();
  }

  // -------------------------------
  // パーティに追加 (partyモード)
  // -------------------------------
  async function addSelectedCardsToParty() {
    if (warehouseMode !== "party") return;
    if (!currentPartyIdForAdd) {
      alert("パーティIDがありません。");
      return;
    }
    const selectedCards = document.querySelectorAll("#warehouse-card-container .card.selected");
    if (selectedCards.length === 0) {
      alert("カードが選択されていません。");
      return;
    }
    selectedCards.forEach(el => {
      const cardId = el.getAttribute("data-id");
      const idx = window.characterData.findIndex(c => c.id === cardId);
      if (idx !== -1) {
        window.characterData[idx].group = "Party";
        window.characterData[idx].role = "none";
        window.characterData[idx].partyId = currentPartyIdForAdd;
      }
    });
    await saveCharacterDataToIndexedDB(window.characterData);

    clearSelectedCards();
    reloadCurrentView();

    if (typeof afterAddCallback === "function") {
      afterAddCallback();
    }
    updateSelectionButtonsVisibility();
  }

  // -------------------------------
  // 再描画
  // -------------------------------
  function reloadCurrentView() {
    const container = document.getElementById("warehouse-card-container");
    if (container) container.innerHTML = "";
    loadedLineCount = 0;

    let all = (window.characterData || [])
      .filter(c => c.group === "Warehouse" && c.type === currentTab);
    allWarehouseCards = all;

    loadNextLines(LINES_PER_LOAD);
  }

  // グローバル公開
  window.showWarehouseModal = showWarehouseModal;
})();
--- 
styles.css 
/* styles.css */

/* ベース */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #3d3d3d;
}

.container {
  box-sizing: border-box;
  max-width: 90%;
  margin: 20px auto;
  padding: 20px;
  background-color: rgba(0, 0, 0, 0.7);
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  color: #f0f0f0;
}

.button-container {
  display: flex;
  flex-direction: row;
  gap: 20px;
  justify-content: center;
}
#warehouse-card-container {
  opacity: 0;
  transition: opacity 0.3s ease;
}

h1 {
  text-align: center;
}

h2 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

.api-key-section {
  margin-bottom: 20px;
}

input,
textarea {
  box-sizing: border-box;
  width: 100%;
  padding: 10px;
  font-size: 1.5rem;
  border: 1px solid #ccc;
  background-color: #434343;
  color: #f0f0f0;
  margin-bottom: 10px;
}

input[type="checkbox"] {
  width: initial;
  margin: auto 10px auto 0;
  padding: 0;
  width: 2rem;
  height: 2rem;
}

button {
  padding: 10px 20px;
  background-color: #4caf50;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-bottom: 10px;
  min-height: 2.5rem;
}

button:hover {
  background-color: #45a049;
}

/* シーン履歴 */
.scene-history {
  max-height: 50vh;
  overflow-y: auto;
  border: none;
  padding: 0;
  background-color: transparent;
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-bottom: 20px;
  margin-right: -20px;
  margin-left: -20px;
  margin-top: -20px;
}

.history-tile.summary {
  font-size: 0.8rem;
  font-family: serif;
  background-color: #1111115e;
  padding: 10px 20px;
  align-items: flex-start;
}
.history-tile.summary.separator {
  padding: 0;
  border-bottom: 1px dashed #666;
}

.history-tile.summary.title {
  font-size: 1rem;
}

.history-tile {
  position: relative;
  box-sizing: border-box;
  padding: 20px 20px 60px 20px;
  background-color: transparent;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin: 0 auto;
  text-align: right;
  width: 100%;
  display: flex;
  flex-direction: column;
}

.history-tile:nth-child(odd) {
  background-color: #111111a8;
}
.history-tile:last-of-type {
  padding-bottom: 0;
}
.scene-text,
.action-text,
.scenario-text {
  text-align: left;
  font-family: serif;
  line-height: 1.8em;
  margin: 0;
  padding: 5px;
  font-size: 22px;
  letter-spacing: 0.1em;
  border: 1px dashed transparent;
  cursor: text;
}

.history-tile .scene-text,
.history-tile .action-text,
.history-tile .scenario-text {
  font-size: 0.8rem;
}
.history-tile .action-text {
  font-size: 1rem;
}

.history-tile:last-child .action-text {
  font-size: 1.4rem;
}

.history-tile button {
  position: absolute;
  bottom: 20px;
  margin-bottom: 0px;
  max-width: 10rem;
  background-color: transparent;
  border: 1px dashed #bbb;
  color: #bbb;
  width: 100%;
  border-radius: 20px;
}

.delete-scene {
  max-width: 10rem;
  background-color: transparent;
  border: 1px dashed #bbb;
  color: #bbb;
  width: 100%;
  border-radius: 20px;
}
.delete-scene:hover {
  background-color: #aaa;
  color: #000;
}

.history-tile button:hover {
  background-color: #aaa;
  color: #000;
}

.scene-text[contenteditable]:focus,
.action-text[contenteditable]:focus,
.scenario-text[contenteditable]:focus {
  border: 1px dashed #4caf50;
  outline: none;
}

#story {
  font-size: 1.4rem;
  padding-bottom: 10px;
  min-height: 60px;
}

/* ▼ モーダル（フェードイン／アウトで表示） */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* 背景の黒み */
  background-color: rgba(0, 0, 0, 0.8);

  /* フレックスで中央寄せ */
  display: flex;
  justify-content: center;
  align-items: center;

  /* ▼ フェードイン/アウトに使う */
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  z-index: 9999;
}

.modal.active {
  opacity: 1;
  pointer-events: auto;
  flex-direction: column;
  justify-content: center;
}

/* モーダル内部 */
.modal-content {
  box-sizing: border-box;
  background-color: rgba(0, 0, 0, 0.6);
  color: #f0f0f0;
  padding: 0;
  border-radius: 5px;
  text-align: center;
  max-height: 100vh;
  overflow-y: auto;
  width: 100%;

  /* ふわっと拡大 */
  transform: scale(0.9);
  transition: transform 0.3s ease;
}

.modal.active .modal-content {
  transform: scale(1);
}

.modal-content {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* カード関連 */
#card-container,
#party-modal-card-container,
#warehouse-card-container {
  box-sizing: border-box;
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
}

.card {
  width: 100%;
  aspect-ratio: 63 / 88;
  perspective: 1000px;
  cursor: pointer;
  transition: transform 0.3s ease;
  position: relative;
  max-width: 300px;
}

.card-inner {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 0.6s;
}

.card.flipped .card-inner {
  transform: rotateY(180deg);
}

.card-front,
.card-back {
  color: #222;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 15px;
  backface-visibility: hidden;
  box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2);
}

.card-front {
  box-sizing: border-box;
  padding: 3%;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  position: relative;
}

.card-front h3 {
  padding: 0;
  margin: 0;
  font-size: 1rem;
}

.card-front .card-type {
  position: absolute;
  right: 10px;
  background-color: rgba(255, 255, 255, 0.8);
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: bold;
  font-size: 0.85rem;
  z-index: 2;
}

.card-front .card-image {
  width: 100%;
  height: 40%;
  background: linear-gradient(135deg, #cccccc70, #eeeeee70);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.card-front .card-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: top;
}

.card-front .gen-image-btn {
  position: absolute;
  bottom: 8px;
  right: 8px;
  padding: 4px 8px;
  background-color: rgba(0, 0, 0, 0.6);
  color: #fff;
  border: none;
  border-radius: 4px;
  font-size: 0.8rem;
  z-index: 2;
}

.gen-image-btn:disabled {
  background-color: #999;
  color: #ccc;
  cursor: not-allowed;
  opacity: 0.6;
}

.card-front .card-info {
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  flex-grow: 1;
  overflow: auto;
  background-color: rgba(255, 255, 255, 0.7);
}

.card-front .card-info p {
  margin: 0;
  font-size: 0.85rem;
}

.card-front .card-info p:last-child {
  padding: 0;
  height: 100%;
  font-size: 0.85rem;
  align-items: center;
  display: flex;
  background-color: #eee;
  margin-top: 10px;
}

.card-front .card-info p:last-child span {
  transform: skew(-5deg);
  display: flex;
  padding: 10px;
}

.card-back {
  box-sizing: border-box;
  background: linear-gradient(135deg, #1e3c72, #2a5298);
  color: #fff;
  transform: rotateY(180deg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  padding: 10px;
  text-align: center;
}

@media (max-width: 600px) {
  #card-container {
    grid-template-columns: repeat(1, 1fr);
  }
}

.bezel {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  z-index: 100;
  border-radius: 2%;
  padding: 3%;
}

.bezel.rarity0 {
  background: linear-gradient(145deg, #c0c0c0, #d3d3d3, #e0e0e0, #a9a9a9);
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity1 {
  background: linear-gradient(145deg, #b87333, #da8a67, #e97451, #c35817);
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity2 {
  background: linear-gradient(145deg, #c0c0c0, #d3d3d3, #e0e0e0, #a9a9a9);
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity3 {
  background: linear-gradient(145deg, #b69a00, #ffda64, #ffda6b, #d79000);
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity4 {
  position: absolute;
  background: linear-gradient(145deg, #d1d1d1, #aeb9ff, #c0c0c0, #ecebe8);
  background-size: 400% 400%;
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: platinum-shimmer 5s ease-in-out infinite;
}

.bezel.rarity5 {
  background: linear-gradient(145deg, #4b0082, #0000cd, #008080, #fff);
  background-size: 150% 150%;
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: jewel-glow 5s ease-in-out infinite;
}

@keyframes platinum-shimmer {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

@keyframes jewel-glow {
  0% {
    filter: brightness(1);
    background-position: 0% 50%;
  }
  50% {
    filter: brightness(1.2);
    background-position: 100% 50%;
  }
  100% {
    filter: brightness(1);
    background-position: 0% 50%;
  }
}

#party-card-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
}

.card.selected .bezel {
  outline: 10px solid #f44336;
  outline-offset: -10px;
  outline: 10px solid #f44336;
  outline-offset: -10px;
  background-image: none;
  -webkit-mask-image: none;
  background-color: #0000004d;
}

.manipulate-panel {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
  justify-content: center;
  align-items: center;
}

.chips-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.chip {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  border-radius: 20px;
  background-color: rgba(227, 227, 227, 0.4);
  color: #f0f0f0;
  box-shadow: inset 0px 0px 4px #fff;
  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s;
  min-width: 12rem;
  justify-content: center;
}

.chip:hover {
  background-color: #cfcfcf;
}

.chip.selected {
  background-color: #8bc34a;
  color: #fff;
}

.bg-thumb {
  position: relative;
  cursor: pointer;
  transition: transform 0.2s;
}

.bg-thumb:hover {
  transform: scale(1.02);
}

.bg-thumb-delete {
  position: absolute;
  top: 5px;
  right: 5px;
  background-color: rgba(200, 0, 0, 0.7);
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
  padding: 4px;
  display: none;
}

.bg-thumb:hover .bg-thumb-delete {
  display: inline-block;
}

.bg-stock-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 16px;
  margin: 20px 0;
}

/* ダミー要素用 */
.dummy {
  visibility: hidden;
  pointer-events: none;
  background-color: transparent;
  border: none;
}

/* レア度3以上で背景画像が大きくなりがちな場合に対応 */
.card.rarity3 .card-front .card-image,
.card.rarity4 .card-front .card-image,
.card.rarity5 .card-front .card-image {
  z-index: 0;
  height: 100%;
  width: 100%;
}

.card.rarity3 .card-front .card-image img,
.card.rarity4 .card-front .card-image img,
.card.rarity5 .card-front .card-image img {
  object-position: bottom;
  opacity: 0.9;
}

.card.rarity3 .card-info,
.card.rarity4 .card-info,
.card.rarity5 .card-info {
  position: absolute;
  box-sizing: border-box;
  width: 100%;
  left: 0;
  bottom: 0;
  padding-left: calc(3% + 8px);
  padding-right: calc(3% + 8px);
  padding-top: 3%;
  padding-bottom: 3%;
  border-radius: 0 0 20px 20px;
  background-color: rgba(37, 37, 37, 0.85);
  color: #fff;
  text-shadow: 0 0 10px #fff;
}

.card.rarity3 .card-front .card-info p:last-child,
.card.rarity4 .card-front .card-info p:last-child,
.card.rarity5 .card-front .card-info p:last-child {
  margin-left: -3%;
  margin-right: -3%;
  background-color: rgba(0, 0, 0, 0.7);
  color: #fff;
}

.card.rarity3 .card-front .card-info p:last-child span,
.card.rarity4 .card-front .card-info p:last-child span,
.card.rarity5 .card-front .card-info p:last-child span {
  padding-top: 20px;
  padding-bottom: 20px;
}

.card.rarity3 .card-front .gen-image-btn,
.card.rarity4 .card-front .gen-image-btn,
.card.rarity5 .card-front .gen-image-btn {
  top: calc(40% - 0.8rem);
  bottom: initial;
}
--- 
