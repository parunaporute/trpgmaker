/*
 * scenarioPage.js
 * - 「セクション」情報や「導入シーン」を可視化
 * - 全セクション閲覧/トークン調整などのUI制御
 * - エンディング(クリア/未クリア)ボタン～モーダル表示・再生成も担当
 */

window.apiKey = '';
window.sceneHistory = [];
window.currentScenarioId = null;
window.currentScenario = null;
window.currentRequestController = null;
window.cancelRequested = false;

window.scenarioType = null;
window.clearCondition = null;
window.sections = [];

// 要約をメモリ上でも管理
window.sceneSummaries = []; // sceneSummaries[chunkIndex] = { en: '...', ja: '...' }


// 画面起動時
window.addEventListener("load", async () => {
  // IndexedDB初期化 & characterDataロード
  await initIndexedDB();
  const storedChars = await loadCharacterDataFromIndexedDB();
  window.characterData = storedChars || [];

  // トークン調整ボタン
  const tokenAdjustBtn = document.getElementById("token-adjust-button");
  if (tokenAdjustBtn) {
    tokenAdjustBtn.addEventListener("click", onOpenTokenAdjustModal);
  }
  const tokenAdjustOk = document.getElementById("token-adjust-ok-button");
  const tokenAdjustCancel = document.getElementById("token-adjust-cancel-button");
  if (tokenAdjustOk) tokenAdjustOk.addEventListener("click", onConfirmTokenAdjust);
  if (tokenAdjustCancel) tokenAdjustCancel.addEventListener("click", () => {
    const mod = document.getElementById("token-adjust-modal");
    if (mod) mod.classList.remove("active");
  });

  // ネタバレ関連
  const spoilerModal = document.getElementById("spoiler-modal");
  const spoilerButton = document.getElementById("spoiler-button");
  const closeSpoilerModalBtn = document.getElementById("close-spoiler-modal");
  if (spoilerButton) {
    spoilerButton.addEventListener("click", () => {
      spoilerModal.classList.add("active");
    });
  }
  if (closeSpoilerModalBtn) {
    closeSpoilerModalBtn.addEventListener("click", () => {
      spoilerModal.classList.remove("active");
    });
  }

  // 「カードを取得する」ボタン
  const getCardButton = document.getElementById("get-card-button");
  if (getCardButton) {
    getCardButton.addEventListener("click", async () => {
      const sceneSummary = await getLastSceneSummary();
      let onlyTitle = "";
      let onlyType = "";
      let addPrompt = "";

      const lines = sceneSummary.split("\n");
      lines.forEach(line => {
        const t = line.trim();
        if (t.startsWith("【名前】")) {
          onlyTitle = t.replace("【名前】", "").replace("：", "").trim();
        } else if (t.startsWith("【タイプ】")) {
          onlyType = t.replace("【タイプ】", "").replace("：", "").trim();
        } else if (t.startsWith("【外見】")) {
          addPrompt = t.replace("【外見】", "").replace("：", "").trim();
        }
      });

      const previewModal = document.getElementById("card-preview-modal");
      const previewContainer = document.getElementById("preview-card-container");
      if (!previewModal || !previewContainer) return;

      previewContainer.innerHTML = "";
      const p = document.createElement("p");
      p.textContent =
        `【名前】：${onlyTitle}\n【タイプ】：${onlyType}\n【外見】：${addPrompt}\nこの内容で作成しますか？`;
      p.style.whiteSpace = "pre-wrap";
      previewContainer.appendChild(p);

      previewModal.classList.add("active");

      const addBtn = document.getElementById("add-to-gachabox-button");
      if (addBtn) {
        addBtn.onclick = async () => {
          previewModal.classList.remove("active");
          const gachaModal = document.getElementById("gacha-modal");
          if (gachaModal) gachaModal.classList.add("active");

          try {
            await runGacha(1, addPrompt, onlyTitle, onlyType);
            alert("ガチャ箱に追加しました。");
          } catch (e) {
            console.error(e);
            alert("カード生成失敗:" + e.message);
          } finally {
            if (gachaModal) gachaModal.classList.remove("active");
          }
        };
      }
      const cancelBtn = document.getElementById("cancel-card-preview-button");
      if (cancelBtn) {
        cancelBtn.onclick = () => {
          previewModal.classList.remove("active");
        };
      }
    });
  }

  // 回答候補生成
  const generateActionCandidatesBtn = document.getElementById("generate-action-candidates-button");
  if (generateActionCandidatesBtn) {
    generateActionCandidatesBtn.addEventListener("click", onGenerateActionCandidates);
  }

  // パーティモーダル
  const showPartyBtn = document.getElementById("show-party-button");
  if (showPartyBtn) {
    showPartyBtn.addEventListener("click", showPartyModal);
  }
  const closePartyModalBtn = document.getElementById("close-party-modal");
  if (closePartyModalBtn) {
    closePartyModalBtn.addEventListener("click", () => {
      const modal = document.getElementById("party-modal");
      if (modal) modal.classList.remove("active");
    });
  }

  // 全セクション閲覧
  const viewAllSectionsBtn = document.getElementById("view-all-sections-button");
  if (viewAllSectionsBtn) {
    viewAllSectionsBtn.addEventListener("click", showAllSectionsModal);
  }
  const closeAllSecBtn = document.getElementById("close-all-sections-modal");
  if (closeAllSecBtn) {
    closeAllSecBtn.addEventListener("click", () => {
      const allSecModal = document.getElementById("all-sections-modal");
      if (allSecModal) allSecModal.classList.remove("active");
    });
  }

  // エンディング関連ボタン
  const endingBtn = document.getElementById("ending-button");
  const clearEndingBtn = document.getElementById("clear-ending-button");
  if (endingBtn) {
    endingBtn.addEventListener("click", () => {
      showEndingModal("bad");
    });
  }
  if (clearEndingBtn) {
    clearEndingBtn.addEventListener("click", () => {
      showEndingModal("clear");
    });
  }

  // エンディングモーダルのボタン
  const endingModalClose = document.getElementById("ending-modal-close-button");
  if (endingModalClose) {
    endingModalClose.addEventListener("click", () => {
      const m = document.getElementById("ending-modal");
      if (m) m.classList.remove("active");
    });
  }
  const endingModalRegen = document.getElementById("ending-modal-regenerate-button");
  if (endingModalRegen) {
    endingModalRegen.addEventListener("click", onClickRegenerateEnding);
  }

  // ▼ 「履歴」ボタンをアプリケーションバーに追加 (Javascriptで生成)
  const applicationBar = document.querySelector(".application-bar");
  const changeBgButton = document.getElementById("change-bg-button");
  if (applicationBar) {
    const historyBtn = document.createElement("button");
    historyBtn.id = "toggle-history-button";
    historyBtn.innerHTML = '<div class="iconmoon icon-newspaper"></div>履歴';

    // ▼ 「change-bg-button」の左に挿入
    applicationBar.insertBefore(historyBtn, changeBgButton);

    historyBtn.addEventListener("click", toggleHistory);

    // 「パーティを確認」ボタンを作成
    const partyButton = document.createElement("button");
    partyButton.id = "show-party-button";
    partyButton.innerHTML = '<div class="iconmoon icon-strategy"></div>PT';

    applicationBar.insertBefore(partyButton, changeBgButton);

    // クリックイベントを追加
    partyButton.addEventListener("click", showPartyModal);
  }
});

/**
 * シナリオを読み込み＆表示用初期化
 */
async function loadScenarioData(scenarioId) {
  try {
    const sc = await getScenarioById(scenarioId);
    if (!sc) {
      alert("指定シナリオが存在しません。");
      return;
    }
    window.currentScenario = sc;

    const wd = sc.wizardData || {};
    window.scenarioType = wd.scenarioType;
    window.clearCondition = wd.clearCondition || "";
    window.sections = wd.sections || [];

    // シーン履歴
    const ents = await getSceneEntriesByScenarioId(scenarioId);
    window.sceneHistory = ents.map(e => ({
      entryId: e.entryId,
      type: e.type,
      sceneId: e.sceneId,
      content: e.content,
      content_en: e.content_en || "",
      dataUrl: e.dataUrl,
      prompt: e.prompt || ""
    }));

    // sceneSummaries
    for (let i = 0; i < 100; i++) {
      const sumRec = await getSceneSummaryByChunkIndex(i);
      if (!sumRec) break;
      window.sceneSummaries[i] = {
        en: sumRec.content_en,
        ja: sumRec.content_ja
      };
    }

    // ネタバレ(目的達成型)
    if (window.scenarioType === "objective") {
      const sb = document.getElementById("spoiler-button");
      if (sb) sb.style.display = "inline-block";
      const sp = document.getElementById("clear-condition-text");
      if (sp) sp.textContent = window.clearCondition || "(クリア条件なし)";
    } else if (window.scenarioType === "exploration") {
      const gcb = document.getElementById("get-card-button");
      if (gcb) gcb.style.display = "inline-block";
    }

    // ▼ 履歴の表示/非表示を復元 (なければ false 初期化)
    if (typeof sc.showHistory === 'undefined') {
      sc.showHistory = false;
    }
    const histDiv = document.getElementById("scene-history");
    if (histDiv) {
      histDiv.style.display = sc.showHistory ? "block" : "none";
    }

    // セクション全クリアチェック
    refreshEndingButtons();
  } catch (err) {
    console.error("シナリオ読み込み失敗:", err);
    alert("読み込み失敗:" + err.message);
  }
}

/**
 * 「履歴」ボタン押下時の処理
 * - IndexedDB上のシナリオフラグを反転して保存
 * - 表示/非表示を切り替え
 */
async function toggleHistory() {
  if (!window.currentScenario) return;
  const hist = document.getElementById("scene-history");
  if (!hist) return;

  // true/falseを反転
  window.currentScenario.showHistory = !window.currentScenario.showHistory;

  // 見た目を更新
  hist.style.display = window.currentScenario.showHistory ? 'block' : 'none';

  // IndexedDBに保存
  await updateScenario(window.currentScenario);
}


/** 「エンディング」ボタンと「クリアエンディング」ボタンの表示切替 */
function refreshEndingButtons() {
  const endingBtn = document.getElementById("ending-button");
  const clearEndingBtn = document.getElementById("clear-ending-button");

  if (!endingBtn || !clearEndingBtn) return;

  const allCleared = areAllSectionsCleared();

  if (allCleared) {
    endingBtn.style.display = "none";
    clearEndingBtn.style.display = "inline-block";
  } else {
    endingBtn.style.display = "inline-block";
    clearEndingBtn.style.display = "none";
  }
}

function areAllSectionsCleared() {
  if (!window.sections || !window.sections.length) return false;
  return window.sections.every(s => s.cleared);
}

/** エンディングモーダルを表示 */
async function showEndingModal(type) {
  const scenarioId = window.currentScenario?.scenarioId;
  if (!scenarioId) {
    alert("シナリオ未選択");
    return;
  }
  const existing = await getEnding(scenarioId, type);
  if (existing) {
    openEndingModal(type, existing.story);
  } else {
    const newStory = await generateEndingStory(type);
    if (!newStory) {
      return;
    }
    await saveEnding(scenarioId, type, newStory);
    openEndingModal(type, newStory);
  }
}

/** エンディングモーダルを再生成 */
async function onClickRegenerateEnding() {
  const titleEl = document.getElementById("ending-modal-title");
  const scenarioId = window.currentScenario?.scenarioId;
  if (!titleEl || !scenarioId) return;

  let type = "bad";
  if (titleEl.textContent.includes("クリア")) {
    type = "clear";
  }
  // 一旦削除
  await deleteEnding(scenarioId, type);

  // 再生成
  const newStory = await generateEndingStory(type);
  if (!newStory) return;
  await saveEnding(scenarioId, type, newStory);

  const storyEl = document.getElementById("ending-modal-story");
  if (storyEl) {
    storyEl.textContent = newStory;
  }
}

/** モーダルを開く */
function openEndingModal(type, story) {
  const modal = document.getElementById("ending-modal");
  const titleEl = document.getElementById("ending-modal-title");
  const storyEl = document.getElementById("ending-modal-story");

  if (type === "clear") {
    titleEl.textContent = "クリアエンディング";
  } else {
    titleEl.textContent = "エンディング";
  }
  storyEl.innerHTML = DOMPurify.sanitize(story, DOMPURIFY_CONFIG) || "";
  modal.classList.add("active");
}

/** エンディングストーリーをChatGPTで生成 */
async function generateEndingStory(type) {
  if (!window.apiKey) {
    alert("APIキーが未設定です");
    return "";
  }

  const scenario = window.currentScenario;
  if (!scenario) {
    alert("シナリオデータがありません");
    return "";
  }
  const wd = scenario.wizardData || {};
  const isClear = (type === "clear");

  const scenarioSummary = wd.scenarioSummary || "(シナリオ概要なし)";
  const party = wd.party || [];

  // 最新10シーン
  let sceneTexts = window.sceneHistory
    .filter(e => e.type === "scene")
    .map(e => e.content || "");
  if (sceneTexts.length > 10) {
    sceneTexts = sceneTexts.slice(-10);
  }
  const combinedScene = sceneTexts.join("\n------\n");

  // セクション情報
  const sectionTextArr = (wd.sections || []).map(s => {
    const cond = decompressCondition(s.conditionZipped);
    return `・セクション${s.number}(${s.cleared ? "クリア" : "未クリア"}): ${cond}`;
  });
  const joinedSections = sectionTextArr.join("\n");

  const endTypePrompt = isClear ? "ハッピーエンド" : "バッドエンド";

  let prompt = `
以下の情報をもとに、
1)シナリオ概要
2)パーティ構成
3)あらすじ
4)セクション
5)その後の話

この5部構成でエンディングストーリーを作ってください。結末は必ず「${endTypePrompt}」にしてください。
あらすじ部分は、下記のシーン履歴をベースにしつつ、あまり簡潔になりすぎないように描写してください。

■シナリオ概要
${scenarioSummary}

`;

  if (party.length !== 0) {
    prompt += `\n■パーティ構成\n`;
    prompt += party.map(p => `- ${p.name}(${p.type || "?"})`).join("\n");
  }

  prompt += `■シーン履歴(最新～最大10シーン)
${combinedScene}

■セクション情報
${joinedSections}
`;

  try {
    showLoadingModal(true);
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: "あなたは優秀なTRPGエンディング生成アシスタントです。日本語で回答してください。" },
          { role: "user", content: prompt }
        ],
        temperature: 0.7
      }),
      signal
    });
    if (window.cancelRequested) {
      return "";
    }
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    return (data.choices[0].message.content || "").trim();
  } catch (err) {
    if (err.name === "AbortError") {
      console.warn("エンディング生成キャンセル");
      return "";
    }
    console.error("エンディング生成失敗:", err);
    alert("エンディング生成に失敗:\n" + err.message);
    return "";
  } finally {
    showLoadingModal(false);
  }
}

/** 圧縮テキスト解凍 */
function decompressCondition(zippedBase64) {
  if (!zippedBase64) return "(不明)";
  try {
    const bin = atob(zippedBase64);
    const uint8 = new Uint8Array([...bin].map(c => c.charCodeAt(0)));
    const inf = pako.inflate(uint8);
    return new TextDecoder().decode(inf);
  } catch (e) {
    console.error("decompress失敗:", e);
    return "(解凍エラー)";
  }
}

/** トークン調整ボタン押下 → モーダルを開く */
function onOpenTokenAdjustModal() {
  let missingCount = 0;
  missingCount = window.sceneHistory.filter(e => !e.content_en).length;
  const msg = `${missingCount}件のシーン/行動に内部英語データがありません。生成しますか？`;
  document.getElementById("token-adjust-message").textContent = msg;
  document.getElementById("token-adjust-progress").textContent = "";
  const mod = document.getElementById("token-adjust-modal");
  mod.classList.add("active");
}

/** トークン調整のOK→不足している英語をまとめて生成 */
async function onConfirmTokenAdjust() {
  const mod = document.getElementById("token-adjust-modal");
  const prog = document.getElementById("token-adjust-progress");
  let targets = window.sceneHistory.filter(e => !e.content_en && (e.type === "scene" || e.type === "action"));

  if (!window.apiKey) {
    alert("APIキー未設定");
    return;
  }
  if (targets.length === 0) {
    alert("不足はありません。");
    mod.classList.remove("active");
    return;
  }

  let doneCount = 0;
  const total = targets.length;

  for (const entry of targets) {
    doneCount++;
    prog.textContent = `${doneCount}/${total}件処理中...`;
    // 英訳生成
    const tr = await generateEnglishTranslation(entry.content);
    entry.content_en = tr;
    const updated = {
      ...entry,
      content_en: tr
    };
    await updateSceneEntry(updated);
  }
  prog.textContent = `${total}/${total}件完了`;
  alert("英語データ生成が完了しました。");
  mod.classList.remove("active");
}

/** 日本語→英語翻訳 */
async function generateEnglishTranslation(japaneseText) {
  if (!japaneseText.trim()) return "";
  const sys = "あなたは優秀な翻訳家です。";
  const u = `以下の日本語テキストを自然な英語に翻訳してください:\n${japaneseText}\n`;
  try {
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: sys },
          { role: "user", content: u }
        ],
        temperature: 0.3
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);
    return data.choices[0].message.content.trim();
  } catch (err) {
    console.error("翻訳失敗:", err);
    return "";
  }
}

/** 回答候補を生成 */
async function onGenerateActionCandidates() {
  if (!window.apiKey) {
    alert("APIキー未設定");
    return;
  }
  const lastSceneEntry = [...window.sceneHistory].reverse().find(e => e.type === "scene");
  const lastSceneText = lastSceneEntry ? lastSceneEntry.content : "(シーン無し)";

  // ▼ ここで wizardData から未クリアセクションの条件テキストを取得する
  const wd = window.currentScenario?.wizardData;
  let conditionText = "";
  if (wd && wd.sections && wd.sections.length > 0) {
    // セクションを番号順にソート
    const sorted = wd.sections.slice().sort((a, b) => a.number - b.number);

    // まだクリアしていない最初のセクションを探す
    const firstUncleared = sorted.find(sec => !sec.cleared);
    if (firstUncleared) {
      // 圧縮されている条件テキストを解凍
      conditionText = decompressCondition(firstUncleared.conditionZipped);
    }
  }
  window.cancelRequested = false;
  showLoadingModal(true);

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const prompt = `
      あなたはTRPGのGMです。
      下記シーンとセクションクリア条件を踏まえ、プレイヤーが可能な行動案を4つ提案してください。
      １：セクションのクリアに関係しそうなものを1つ
      ２：妥当なものを2つ
      ３：少し頭がおかしい行動案を1つ
      合計４行構成にしてください。
      順番はシャッフルしてください。
      言葉の表現でどれがクリアに関係しそうなのかわからないようにしてください。
      ---
      シーン：
      ${lastSceneText}
      ---
      クリア条件：
      ${conditionText}
    `;
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": 'Bearer ' + window.apiKey
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: "あなたは優秀なTRPGアシスタント" },
          { role: "user", content: prompt }
        ],
        temperature: 0.7
      }),
      signal
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    const content = data.choices[0].message.content || "";
    const lines = content.split("\n").map(l => l.trim()).filter(l => l);

    const container = document.getElementById("action-candidates-container");
    if (!container) return;
    container.innerHTML = "";

    lines.forEach(line => {
      const btn = document.createElement("button");
      btn.textContent = line.replace(/^\d+\.\s*/, "");
      btn.style.display = "block";
      btn.style.margin = "5px 0";
      btn.addEventListener("click", () => {
        const playerInput = document.getElementById("player-input");
        if (playerInput) {
          playerInput.value = btn.textContent;
        }
      });
      container.appendChild(btn);
    });
  } catch (e) {
    if (e.name === "AbortError") {
      console.log("候補生成キャンセル");
    } else {
      console.error(e);
      alert("候補生成失敗:" + e.message);
    }
  } finally {
    showLoadingModal(false);
  }
}

/** 全セクション表示モーダル */
function showAllSectionsModal() {
  const modal = document.getElementById("all-sections-modal");
  if (!modal) return;

  const wd = (window.currentScenario && window.currentScenario.wizardData) || {};
  const sections = wd.sections || [];

  const container = document.getElementById("all-sections-content");
  container.textContent = "";

  if (!sections.length) {
    container.textContent = "セクション情報がありません。";
  } else {
    let text = "";
    for (const sec of sections) {
      text += `【セクション${sec.number}】` + (sec.cleared ? "(クリア済み)" : "(未クリア)") + "\n";
      text += "条件: " + (decompressCondition(sec.conditionZipped)) + "\n\n";
    }
    container.textContent = text;
  }

  modal.classList.add("active");
}

/** パーティ確認モーダル */
function showPartyModal() {
  const modal = document.getElementById("party-modal");
  if (!modal) return;
  modal.classList.add("active");
  renderPartyCardsInModal();
}

function renderPartyCardsInModal() {
  const container = document.getElementById("party-modal-card-container");
  if (!container) return;
  container.innerHTML = "";

  const scenario = window.currentScenario;
  if (!scenario?.wizardData?.party) {
    container.textContent = "パーティ情報がありません。";
    return;
  }

  const wizardPartyCards = scenario.wizardData.party;
  const dbCards = window.characterData;

  const merged = wizardPartyCards.map(wCard => {
    const dbMatch = dbCards.find(dbC => dbC.id === wCard.id);
    if (!dbMatch) {
      return wCard;
    }
    return {
      ...dbMatch,
      ...wCard,
      imageData: dbMatch.imageData || wCard.imageData
    };
  });

  merged.forEach(card => {
    const cardEl = createPartyCardElement(card);
    container.appendChild(cardEl);
  });
}

function createPartyCardElement(c) {
  const cardEl = document.createElement("div");
  cardEl.className = "card ";
  cardEl.className += "rarity" + (c.rarity || "").replace("★", "").trim();

  cardEl.setAttribute("data-id", c.id);
  cardEl.addEventListener("click", () => {
    cardEl.classList.toggle("flipped");
  });

  const cardInner = document.createElement("div");
  cardInner.className = "card-inner";

  const cf = document.createElement("div");
  cf.className = "card-front";

  const bg = (c.backgroundcss || "")
    .replace("background-image:", "")
    .replace("background", "")
    .trim();
  if (bg) {
    cf.style.backgroundImage = bg;
  }

  const rv = (typeof c.rarity === "string") ? c.rarity.replace("★", "").trim() : "0";
  const bezel = document.createElement("div");
  bezel.className = "bezel rarity" + rv;
  cf.appendChild(bezel);

  let roleLabel = "";
  if (c.role === "avatar") roleLabel = "(アバター)";
  else if (c.role === "partner") roleLabel = "(パートナー)";

  const tEl = document.createElement("div");
  tEl.className = "card-type";
  tEl.textContent = (c.type || "不明") + roleLabel;
  cf.appendChild(tEl);

  const imgCont = document.createElement("div");
  imgCont.className = "card-image";
  if (c.imageData) {
    const im = document.createElement("img");
    im.src = c.imageData;
    im.alt = c.name;
    imgCont.appendChild(im);
  }
  cf.appendChild(imgCont);

  const info = document.createElement("div");
  info.className = "card-info";

  const nm = document.createElement("p");
  nm.innerHTML = "<h3>" + DOMPurify.sanitize(c.name) + "</h3>";
  info.appendChild(nm);

  if (c.state) {
    const st = document.createElement("p");
    st.innerHTML = "<strong>状態：</strong>" + DOMPurify.sanitize(c.state);
    info.appendChild(st);
  }
  const sp = document.createElement("p");
  sp.innerHTML = "<strong>特技：</strong>" + DOMPurify.sanitize(c.special);
  info.appendChild(sp);

  const cap = document.createElement("p");
  cap.innerHTML = "<span>" + DOMPurify.sanitize(c.caption) + "</span>";
  info.appendChild(cap);

  cf.appendChild(info);

  const cb = document.createElement("div");
  cb.className = "card-back";
  cb.innerHTML = `<strong>${DOMPurify.sanitize(c.type)}</strong>`;

  cardInner.appendChild(cf);
  cardInner.appendChild(cb);
  cardEl.appendChild(cardInner);
  return cardEl;
}

/** 最新シーンを要約しカード化に向けた情報を抽出 */
async function getLastSceneSummary() {
  const lastSceneEntry = [...window.sceneHistory].reverse().find(e => e.type === "scene");
  if (!lastSceneEntry) return "シーンがありません。";

  const text = lastSceneEntry.content;
  const systemPrompt = `
あなたは優秀なカード作成用プロンプト生成者。
以下フォーマットで【名前】【タイプ】【外見】を作ってください。`;
  const userPrompt = `
シーン文:
${text}
ここからエレメントにできそうな対象1つを抽出し、【名前】【タイプ】【外見】を生成してください。
`;

  try {
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": 'Bearer ' + window.apiKey
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ]
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    return data.choices[0].message.content || "";
  } catch (e) {
    console.error("要約失敗:", e);
    return "(要約失敗)";
  }
}

/** ローディングモーダル表示/非表示 */
function showLoadingModal(show) {
  const m = document.getElementById("loading-modal");
  if (!m) return;
  if (show) {
    m.classList.add("active");
  } else {
    m.classList.remove("active");
  }
}

function onCancelFetch() {
  if (window.currentRequestController) {
    window.currentRequestController.abort();
  }
  showLoadingModal(false);
}

// ====== 新規: 指定シーンから挿絵を生成する関数 ======
async function generateImageForScene(sceneEntry) {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  if (!sceneEntry.prompt) {
    alert("生成するためのプロンプトがありません。");
    return;
  }

  const promptText =
    "As a high-performance chatbot, you create the highest quality illustrations discreetly." +
    "Please do not include text in illustrations for any reason." +
    "If you can do that, I'll give you a super high tip." +
    "Now generate the next anime wide image.\n↓↓↓↓\n" +
    sceneEntry.prompt;

  try {
    showLoadingModal(true);
    window.cancelRequested = false;
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const resp = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: promptText,
        n: 1,
        size: "1792x1024",
        response_format: "b64_json"
      }),
      signal
    });
    const data = await resp.json();
    if (window.cancelRequested) {
      return;
    }
    if (data.error) throw new Error(data.error.message);

    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    // 新しい image entry
    const newEntry = {
      scenarioId: window.currentScenarioId || 0,
      type: "image",
      sceneId: sceneEntry.sceneId,
      content: "",
      content_en: "",
      dataUrl,
      prompt: sceneEntry.prompt
    };
    const newId = await addSceneEntry(newEntry);
    window.sceneHistory.push({
      ...newEntry,
      entryId: newId
    });

    // UI更新
    updateSceneHistory();
    showLastScene();
  } catch (err) {
    if (err.name === "AbortError") {
      console.warn("画像生成キャンセル");
    } else {
      console.error("画像生成失敗:", err);
      alert("画像生成に失敗:\n" + err.message);
    }
  } finally {
    showLoadingModal(false);
  }
}

// ====== シーン履歴を表示 (改修: シーン削除/挿絵生成のUIをドロップダウンへ) ======
function updateSceneHistory() {
  const his = document.getElementById("scene-history");
  if (!his) return;
  his.innerHTML = "";

  // セクション表示
  const wd = window.currentScenario?.wizardData;
  let sections = [];
  if (wd && wd.sections) {
    sections = wd.sections;
  }
  let sorted = [...sections].sort((a, b) => a.number - b.number);
  const firstUncleared = sorted.find(s => !s.cleared);
  sorted = sections;
  if (!firstUncleared && sorted.length > 0) {
    const tile = document.createElement("div");
    tile.className = "history-tile summary title";
    tile.textContent = "シナリオ達成!";
    his.appendChild(tile);
  }

  for (const s of sorted) {
    const t = document.createElement("div");
    if (s.number < (firstUncleared?.number || Infinity)) {
      t.className = "history-tile summary";
      t.textContent = `${decompressCondition(s.conditionZipped)}(クリア済み)`;
      refreshEndingButtons();
    } else if (s.number === firstUncleared?.number) {
      t.className = "history-tile summary";
      t.textContent = `セクション${s.number} (未クリア)`;
    }
    his.appendChild(t);
  }
  let tile = document.createElement("div");
  tile.className = "history-tile summary separator";
  his.appendChild(tile);

  // シナリオ概要
  const scenarioSummaryEl = document.createElement("div");
  scenarioSummaryEl.id = "scenario-summary";
  scenarioSummaryEl.innerHTML = wd.scenarioSummary || "";
  his.appendChild(scenarioSummaryEl);

  // 最後のシーン + その画像は showLastScene() で扱うので、履歴には出さない
  const lastScene = [...window.sceneHistory].reverse().find(e => e.type === "scene");
  const skipIds = [];
  if (lastScene) {
    skipIds.push(lastScene.entryId);
    window.sceneHistory.forEach(x => {
      if (x.type === "image" && x.sceneId === lastScene.sceneId) {
        skipIds.push(x.entryId);
      }
    });
  }
  const showEntries = window.sceneHistory
    .filter(e => !skipIds.includes(e.entryId))
    .sort((a, b) => a.entryId - b.entryId);

  tile = document.createElement("div");
  for (const [index, e] of showEntries.entries()) {
    console.log("hoge", index);

    const c = document.createElement("div");
    c.className = "r-flexbox";

    if (e.type === "action") {
      tile = document.createElement("div");
      tile.className = "history-tile";

      const at = document.createElement("p");
      at.className = "action-text";
      at.setAttribute("contenteditable", window.apiKey ? "true" : "false");
      at.innerHTML = DOMPurify.sanitize(e.content);
      at.addEventListener("blur", async () => {
        await onSceneOrActionContentEdited(e, at.innerHTML.trim());
      });

      tile.appendChild(at);
      his.appendChild(tile);
    } else if (e.type === "scene") {
      tile.className = "history-tile";
      // ▼ シーン本文
      const st = document.createElement("p");
      st.className = "scene-text";
      st.setAttribute("contenteditable", window.apiKey ? "true" : "false");
      st.innerHTML = DOMPurify.sanitize(e.content);
      st.addEventListener("blur", async () => {
        await onSceneOrActionContentEdited(e, st.innerHTML.trim());
      });
      tile.appendChild(st);

      //      tile.appendChild(c);
      his.appendChild(tile);
    } else if (e.type === "image") {
      //画像だったとき。これのせいで面倒だ
      tile.className = "history-tile";

      const img = document.createElement("img");
      img.src = e.dataUrl;
      img.alt = "生成画像";
      img.style.maxHeight = "350px";
      img.style.alignSelf = "flex-end";
      img.style.width = "100%";
      img.style.objectFit = "contain";
      img.style.marginBottom = "60px";
      img.style.objectPosition = "right";

      tile.appendChild(img);

      const cc = document.createElement("div");
      cc.className = "button-conteiner";
      // 画像再生成ボタン
      const reBtn = document.createElement("button");
      reBtn.textContent = "再生成";
/*      reBtn.style.width = "10rem";
      reBtn.style.right = "calc(10rem + 4rem)";*/
      reBtn.addEventListener("click", () => {
        if (!window.apiKey) return;
        const idx = window.sceneHistory.indexOf(e);
        if (idx >= 0) {
          openImagePromptModal(e.prompt, idx);
        }
      });
      cc.appendChild(reBtn);

      // 画像削除
      const delBtn = document.createElement("button");
      delBtn.textContent = "画像削除";
/*      delBtn.style.bottom = "70px";
      delBtn.style.right = "20px";*/
      delBtn.addEventListener("click", async () => {
        await deleteSceneEntry(e.entryId);
        window.sceneHistory = window.sceneHistory.filter(x => x.entryId !== e.entryId);
        updateSceneHistory();
        showLastScene();
      });
      cc.appendChild(delBtn);
      tile.appendChild(cc);

      his.appendChild(tile);
    }

    if (
//      showEntries.length - 1 == index || // 最後
      (e.type == "scene" && showEntries[index + 1].type == "action") || // シーンであり、次がアクション
      e.type == "image"// イメージ
    ) {
      c.innerText = "";

      // ▼ 置き換え: wandボタン + ドロップダウン
      const wandBtn = document.createElement("button");
      wandBtn.className = "scene-menu-button";
      wandBtn.innerHTML = '<div class="iconmoon icon-magic-wand"></div>';
      c.appendChild(wandBtn);

      // ドロップダウン本体
      const dropdown = document.createElement("div");
      dropdown.className = "scene-dropdown-menu";
      dropdown.style.display = "none"; // 初期は非表示
      dropdown.innerHTML = `
        <button class="dropdown-item scene-delete">
          <div class="iconmoon icon-bin"></div>シーンを削除
        </button>
        <button class="dropdown-item scene-illustration">
          <div class="iconmoon icon-picture"></div>挿絵を生成
        </button>
      `;
      c.appendChild(dropdown);

      // ボタン押下でメニュー開閉
      wandBtn.addEventListener("click", () => {
        dropdown.style.display = (dropdown.style.display === "none") ? "block" : "none";
      });

      // 「シーンを削除」クリック
      const delBtn = dropdown.querySelector(".scene-delete");
      if (delBtn) {
        delBtn.addEventListener("click", async () => {
          dropdown.style.display = "none";
          await deleteSceneAndPreviousAction(e);
        });
      }
      // 「挿絵を生成」クリック
      const illustBtn = dropdown.querySelector(".scene-illustration");
      if (illustBtn) {
        illustBtn.addEventListener("click", async () => {
          dropdown.style.display = "none";
          await generateImageForScene(e);
        });
      }
      his.appendChild(c);
    }

  }

  his.scrollTop = his.scrollHeight;
}


// ====== シーン削除 + 直前アクション削除 → 再描画 ======
async function deleteSceneAndPreviousAction(sceneEntry) {
  // このシーンと同じ sceneId の画像をまとめて削除
  const removeIds = [sceneEntry.entryId];
  window.sceneHistory.forEach(x => {
    if (x.type === "image" && x.sceneId === sceneEntry.sceneId) {
      removeIds.push(x.entryId);
    }
  });

  // さらに「直前のアクション」を探して削除
  const idx = window.sceneHistory.findIndex(e => e.entryId === sceneEntry.entryId);
  if (idx > 0) {
    for (let i = idx - 1; i >= 0; i--) {
      if (window.sceneHistory[i].type === "action") {
        removeIds.push(window.sceneHistory[i].entryId);
        break;
      }
    }
  }
/*
  // DB削除
  for (const rid of removeIds) {
    await deleteSceneEntry(rid);
  }
  // メモリ上から削除
  window.sceneHistory = window.sceneHistory.filter(x => !removeIds.includes(x.entryId));
*/

  // 要約再計算 & 再描画
  await handleSceneSummaries();
  updateSceneHistory();
  showLastScene();
}


/** シーン or 行動を編集したら英訳を作り直す */
async function onSceneOrActionContentEdited(entry, newText) {
  if (!window.apiKey) {
    return;
  }
  if (newText.trim() === entry.content.trim()) {
    return;
  }
  // 翻訳を作り直す
  // モーダルを一時的に表示
  showLoadingModal(true);
  try {
    const en = await generateEnglishTranslation(newText);
    entry.content = newText;
    entry.content_en = en;
    const up = {
      ...entry,
      content: newText,
      content_en: en
    };
    await updateSceneEntry(up);
  } catch (err) {
    console.error("再翻訳失敗:", err);
  } finally {
    showLoadingModal(false);
  }
}


/** 行動数に応じて要約を作成/削除する */
async function handleSceneSummaries() {
  const actionCount = window.sceneHistory.filter(e => e.type === "action").length;
  // 新規要約作成チェック
  if (actionCount >= 15) {
    const chunkIndex = Math.floor((actionCount - 15) / 10);
    if (chunkIndex >= 0) {
      if (!window.sceneSummaries[chunkIndex]) {
        const startAction = chunkIndex * 10 + 1;
        const endAction = (chunkIndex + 1) * 10;
        let gathered = [];
        let actionCounter = 0;
        for (const e of window.sceneHistory) {
          if (e.type === "action") {
            actionCounter++;
          }
          if (actionCounter >= startAction && actionCounter <= endAction) {
            gathered.push(e);
          }
        }
        const textForSummary = gathered.map(x => x.type === "action" ? `A:${x.content}` : `S:${x.content}`).join("\n");

        const enSummary = await generateSummaryWithLimit(textForSummary, 5, "en");
        const jaSummary = await generateSummaryWithLimit(textForSummary, 5, "ja");

        const sumRec = {
          chunkIndex,
          content_en: enSummary,
          content_ja: jaSummary
        };
        await addSceneSummaryRecord(sumRec);
        window.sceneSummaries[chunkIndex] = {
          en: enSummary,
          ja: jaSummary
        };
      }
    }
  }

  // 削除チェック
  const checks = [15, 25, 35, 45, 55, 65, 75];
  for (let i = 0; i < checks.length; i++) {
    const boundary = checks[i];
    if (actionCount <= boundary) {
      await deleteSceneSummaryByChunkIndex(i);
      window.sceneSummaries[i] = null;
    }
  }
}


/** 指定テキストを (英/日) で N行程度に要約 */
async function generateSummaryWithLimit(text, lines = 5, lang = "en") {
  if (!text.trim()) return "";
  let sys = "You are a talented summarizer. The final language must be English.";
  let user = `
Summarize the following text in ${lines} lines of English:
${text}
`;
  if (lang === "ja") {
    sys = "あなたは優秀な要約者です。必ず日本語で。";
    user = `
以下のテキストを${lines}行程度で簡潔にまとめてください:
${text}
`;
  }
  try {
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: sys },
          { role: "user", content: user }
        ],
        temperature: 0.5
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);
    return data.choices[0].message.content.trim();
  } catch (err) {
    console.error("要約失敗:", err);
    return "";
  }
}


/** 最新シーンを表示 (改修: ドロップダウン化) */
function showLastScene() {
  const storyDiv = document.getElementById("story");
  const lastSceneImagesDiv = document.getElementById("last-scene-images");
  if (!storyDiv || !lastSceneImagesDiv) return;

  const nextSceneBtn = document.getElementById("next-scene");
  const playerInput = document.getElementById("player-input");
  const playerActionLabel = document.getElementById("player-action");

  const lastScene = [...window.sceneHistory].reverse().find(e => e.type === "scene");

  if (lastScene) {
    storyDiv.innerHTML = "";
    // ▼ シーン本文
    const st = document.createElement("p");
    st.className = "scene-text";
    st.setAttribute("contenteditable", window.apiKey ? "true" : "false");
    st.innerHTML = DOMPurify.sanitize(lastScene.content, DOMPURIFY_CONFIG);
    st.addEventListener("blur", async () => {
      await onSceneOrActionContentEdited(lastScene, st.innerHTML.trim());
    });
    storyDiv.appendChild(st);

    // ▼ 画像エリア
    lastSceneImagesDiv.innerHTML = "";
    const images = window.sceneHistory.filter(x => x.type === "image" && x.sceneId === lastScene.sceneId);
    images.forEach(imgEntry => {
      const c = document.createElement("div");
      c.className = "image-container";

      const i = document.createElement("img");
      i.src = imgEntry.dataUrl;
      i.alt = "シーン画像";
      c.appendChild(i);

      const cc = document.createElement("div");
      cc.className = "button-conteiner";
      const reBtn = document.createElement("button");
      reBtn.textContent = "再生成";
      reBtn.addEventListener("click", () => {
        if (!window.apiKey) return;
        const idx = window.sceneHistory.indexOf(imgEntry);
        if (idx >= 0) {
          openImagePromptModal(imgEntry.prompt, idx);
        }
      });
      cc.appendChild(reBtn);

      const dBtn = document.createElement("button");
      dBtn.textContent = "画像削除";
      dBtn.addEventListener("click", async () => {
        await deleteSceneEntry(imgEntry.entryId);
        window.sceneHistory = window.sceneHistory.filter(x => x.entryId !== imgEntry.entryId);
        showLastScene();
        updateSceneHistory();
      });
      cc.appendChild(dBtn);
      c.appendChild(cc);
      lastSceneImagesDiv.appendChild(c);
    });

    // ▼ 新しい wand ボタン + ドロップダウン
    const c = document.createElement("div");
    c.className = "r-flexbox";

    const wandBtn = document.createElement("button");
    wandBtn.className = "scene-menu-button";
    wandBtn.innerHTML = '<div class="iconmoon icon-magic-wand"></div>';
    c.appendChild(wandBtn);

    const dropdown = document.createElement("div");
    dropdown.className = "scene-dropdown-menu";
    dropdown.style.display = "none";
    dropdown.innerHTML = `
      <button class="dropdown-item last-scene-delete"><div class="iconmoon icon-bin"></div>シーンを削除</button>
      <button class="dropdown-item last-scene-illustration"><div class="iconmoon icon-picture"></div>挿絵を生成</button>
    `;
    c.appendChild(dropdown);

    wandBtn.addEventListener("click", () => {
      dropdown.style.display = (dropdown.style.display === "none") ? "block" : "none";
    });

    // 「シーンを削除」
    dropdown.querySelector(".last-scene-delete").addEventListener("click", async () => {
      dropdown.style.display = "none";
      await deleteSceneAndPreviousAction(lastScene);
    });

    // 「挿絵を生成」
    dropdown.querySelector(".last-scene-illustration").addEventListener("click", async () => {
      dropdown.style.display = "none";
      await generateImageForScene(lastScene);
    });
    storyDiv.appendChild(c);

    if (window.apiKey) {
      nextSceneBtn.style.display = "inline-block";
      playerInput.style.display = "inline-block";
      playerActionLabel.textContent = "プレイヤーはどんな行動をしますか？";
    } else {
      nextSceneBtn.style.display = "none";
      playerInput.style.display = "none";
      playerActionLabel.textContent = "";
    }
  } else {
    // シーンが無い
    storyDiv.innerHTML = "";
    lastSceneImagesDiv.innerHTML = "";

    if (window.apiKey) {
      nextSceneBtn.style.display = "inline-block";
      playerInput.style.display = "block";
      playerActionLabel.textContent = "最初のシーンを作るため行動を入力してください。";
    } else {
      nextSceneBtn.style.display = "none";
      playerInput.style.display = "none";
      playerActionLabel.textContent = "";
    }
  }
}


// 外部から呼べるようにexport
window.loadScenarioData = loadScenarioData;
window.onCancelFetch = onCancelFetch;
